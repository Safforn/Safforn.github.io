<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSAPP 5.1 优化编译器的能力和局限性</title>
    <url>/2022/02/21/CSAPP-5.1-optimizes-compiler-capabilities-and-limitations/</url>
    <content><![CDATA[<h2 id="5-1-优化编译器的能力和局限性"><a href="#5-1-优化编译器的能力和局限性" class="headerlink" title="5.1 优化编译器的能力和局限性"></a>5.1 优化编译器的能力和局限性</h2><p>现代编译器运用复杂精细的算法来确定一个程序中计算的值，以及他们是被如何使用的，然后利用一些机会来简化表达式，如：在几个不同的地方使用同一个计算，以及降低一个给定的计算必须被执行的次数。大多数编译器，包括 GCC，向用户提供了一些对它们所使用的优化的控制。就像在第3章中讨论过的，最简单的控制就是指定<code>优先级别</code>。例如，以命令行选项 “-Og” 调用 GCC 是让 GCC 使用一组基本的优化。以选项 “-O1” 或更高(如 “-O2” 或 “-O3” ) 调用 GCC 会让他使用更多的优化，进一步提高程序的性能，但是也可能增加程序的规模，也可能使标准的调试工具更难对程序进行调试。</p>
<p>编译器必须很小心地对程序进行<code>安全</code>的优化，即对于程序可能遇到的所有可能的情况，在C语言标准提供的保证之下，优化后得到的程序和为优化的版本有一样的行为。这一限制消除了一些造成不希望的运行时行为的隐患，但是也意味着程序员要花费更多精力写出编译器能够将之转换成有效及其代码的程序。下面这个简单的例子帮助理解编译器优化限制：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">twiddle1</span><span class="params">(<span class="type">long</span> *xp, <span class="type">long</span> *yp)</span> &#123;</span><br><span class="line">    *xp += *yp;</span><br><span class="line">    *xp += *yp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">twiddle2</span><span class="params">(<span class="type">long</span> *xp, <span class="type">long</span> *yp)</span> &#123;</span><br><span class="line">	*xp += <span class="number">2</span>* *yp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>twiddle1 和 twiddle2 两个函数“似乎”有相同的功能（把存储在指针yp指向的值两次加到指针xp所指的值上）。从另一个角度来看，函数 twiddle2 效率更高一些，它只要求三次内存引用（读*xp、读*yp、写*xp），而 twiddle1需要6次（重复twiddle2需要的内存引用操作两次）。因此，如果要编译器编译函数 twiddle1，我们认为基于 twiddle2 执行的计算能产生更有效的代码。.</p>
<p>不过，考虑到 xp 和 yp 指向同一地址（xp 和 yp相等）的情况，此时，函数 twiddle1 的结果使 xp 变为原来的 4 倍，函数 twiddle2 的结果使 xp 变为原来的 3 倍。编译器不知道 twiddle1 会在何种情况被调用，因此必须假设 xp 和 yp 可能会相等。因此，编译器不能产生 twiddle2 风格的代码作为 twiddle1 的优化版本。这种两个指针指向同一个内存地址的情况称为 <strong><code>memory aliasing</code>（内存别名使用）</strong>，这可能会造成一个主要的<code>妨碍优化</code>的因素，限制了可能的优化策略。</p>
<hr>
<p>第二个妨碍优化的因素是 <strong>函数调用</strong>。考虑下面这个示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> f()+f()+f()+f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">func2</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span> * f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最初看上去两个函数实现的都是相同的功能，但是 func2() 只调用 f() 1次，而 func1() 调用 f() 4次。以func1() 作为源代码时，会很想产生 func2()  风格的代码。不过考虑下面 有关 f() 的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> counter++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数有个“副作用”，他修改了全局程序状态的一部分，改变该函数的调用次数会改变程序的功能。假设开始时去全局变量 counter 的值设为0，调用 func1() 会返回 0+1+2+3&#x3D;6，而调用 func2()返回 4*0&#x3D;0。大多数编译器会试图判断一个函数是否有副作用，如果有，编译器会假设最坏的情况并保持所有的函数调用不变。反之，则会进行一定程度的优化。</p>
<hr>
<h3 id="用内联优化函数调用"><a href="#用内联优化函数调用" class="headerlink" title="用内联优化函数调用"></a>用内联优化函数调用</h3><p>包含函数函数调用的代码可以用 <strong><code>inline substitution</code>（内敛函数替换）</strong> 或者简称 <strong><code>inlining</code>（内联）</strong> 的过程进行优化，此时，将函数调用替换为函数体。下面是 func1() 的内联版代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Result of inlining f in func1 */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">funclin</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> t = counter++;  <span class="comment">/* +0 */</span></span><br><span class="line">    t += counter++;      <span class="comment">/* +1 */</span></span><br><span class="line">    t += counter++;      <span class="comment">/* +2 */</span></span><br><span class="line">    t += counter++;      <span class="comment">/* +3 */</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的转换即减少了函数调用的开销，也允许对展开的代码做进一步优化。例如，编译器可以统一funclin() 中对全局变量的更新，产生这个函数的一个优化版本：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Optimization of inlined func1 code */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">funclopt</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">long</span> t = <span class="number">4</span> * counter + <span class="number">6</span>;</span><br><span class="line">	counter += <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 对于这个特定的函数 f 的定义，上述代码重现了 func1 的行为。</p>
<p>最近版本的 GCC 会尝试进行这种形式的优化，可以用命令行选项<code>-finline</code>指示编译器，或者使用优化等级 “-O1” 或更高等级。但是目前 GCC 尝试在单个文件中定义的函数的内联，意味着它无法用于常见的情况（<strong>一组库函数在一个文件中被定义，在其他文件的函数中被调用</strong>）。</p>
<p>在某些情况下，最好能阻止编译器的内联优化。一种情况是 用符号调试器(如GDB)来评估代码，如果一个函数调用已经用内联替换优化过了，那么任何对这个调用进行追踪或设置断点的尝试都会失败。还有一种情况是用代码剖析的方式来评估程序性能，用内联替换消除的函数调用是不能被正确剖析的。</p>
<hr>
]]></content>
      <categories>
        <category>学习</category>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Studio安装教程及踩坑</title>
    <url>/2023/02/27/Android-Studio-Install-Q&amp;A/</url>
    <content><![CDATA[<h2 id="0-准备"><a href="#0-准备" class="headerlink" title="0. 准备"></a>0. 准备</h2><p><a href="https://developer.android.google.cn/studio/archive?hl=zh-cn">Android Studio下载文件(推荐3.5.2)</a></p>
<hr>
<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><p>教程1：<a href="https://blog.csdn.net/m0_38076341/article/details/115562334">Android Studio（3.5.2）安装和配置</a><br>教程2(B站视频)：<a href="https://www.bilibili.com/video/BV1S44y1572j">保姆级Android Studio+JDK安装配置教程带字幕-bilibili</a><br>补充：<a href="https://www.cnblogs.com/martin-1/p/15240843.html">更换Android studio中的SDK和AVD位置</a></p>
<hr>
<h2 id="2-遇到问题及解决"><a href="#2-遇到问题及解决" class="headerlink" title="2. 遇到问题及解决"></a>2. 遇到问题及解决</h2><p><a href="https://blog.csdn.net/yw00yw/article/details/105397976">Android Studio 解决 Error : module not specified错误</a><br><a href="https://blog.csdn.net/weixin_42473228/article/details/118542634">Could not install Gradle distribution from “https://services.gradle.org/..."</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算与取模运算%</title>
    <url>/2021/08/22/Bit-operation-and-modular-operation%25/</url>
    <content><![CDATA[<p>在研究某大佬的代码时，突然发现了这样一条用来<strong>判断奇偶数</strong>的语句：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(x&amp;<span class="number">1</span>) &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>带着<del>想探究事物本质的好奇心</del> (想把代码变得高大上)，去搜了搜<code>取模运算%</code>和<code>按位与&amp;</code>的关系，<del>于是打开了新世界的大门</del>  <strong>(｢･ω･)｢</strong></p>
<ul>
<li>注：<code>位运算与&amp;</code>的效率要比<code>取模运算%</code>快<strong>10倍以上</strong></li>
</ul>
<hr>
<h2 id="位运算符简介"><a href="#位运算符简介" class="headerlink" title="位运算符简介"></a>位运算符简介</h2><p>与<code>&amp;</code>、或<code>|</code>、异或<code>^</code>、右移<code>&gt;&gt;</code>、左移<code>&lt;&lt; </code>，取反<code>~</code></p>
<h3 id="按位与-amp"><a href="#按位与-amp" class="headerlink" title="按位与 &amp;"></a>按位与 &amp;</h3><ul>
<li>0&amp;0&#x3D;0；  0&amp;1&#x3D;0；  1&amp;0&#x3D;0；  1&amp;1&#x3D;1；  简记为“<strong>同1则1</strong>”</li>
<li>应用：<ul>
<li>清零：x&amp;0</li>
<li><strong>取二进制数的某一位</strong>：例如取x&#x3D;10010110的右数第三位，则<code>x&amp;00000100 = 00000100</code>，说明x的右数第三位是1</li>
<li><strong>判断奇偶数</strong>代替<code>取模运算x%2==1</code>: <strong>奇数x&amp;1&#x3D;1，偶数x&amp;1&#x3D;0</strong>，效率更高</li>
</ul>
</li>
</ul>
<h3 id="按位或"><a href="#按位或" class="headerlink" title="按位或 |"></a>按位或 |</h3><ul>
<li>0|0&#x3D;0；  0|1&#x3D;1；  1|0&#x3D;1；  1|1&#x3D;1；  简记为“<strong>有1则1</strong>”</li>
<li>应用：<ul>
<li>使二进制数的某些位为1：例如使x&#x3D;10001000的右数第1,2位取1，则<code>x|00000011 = 10001011</code></li>
</ul>
</li>
</ul>
<h3 id="按位异或"><a href="#按位异或" class="headerlink" title="按位异或 ^"></a>按位异或 ^</h3><ul>
<li>0^0&#x3D;0；  0^1&#x3D;1；  1^0&#x3D;1；  1^1&#x3D;0；  简记为“<strong>同0异1</strong>”</li>
<li>自反性： <code>x^y^y = x  </code>；<code>x^0 = 0</code>；<code>x^x = 0</code></li>
<li>应用：<ul>
<li><strong>不利用中间变量</strong>实现<strong>变量值互换</strong>：  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//x = 3 = 0011  y = 5 = 0101</span></span><br><span class="line">x = x^y; <span class="comment">// x1 = (x^y=0110)</span></span><br><span class="line">y = x^y; <span class="comment">// y = (x1^y=0110^0101=0011=3)</span></span><br><span class="line">x = x^y; <span class="comment">// x = (x1^y1=0110^0011=0101=5) 交换完成</span></span><br></pre></td></tr></table></figure></li>
<li>特殊的数组筛选重复值：1~100放在长度为101的数组中，只有唯一的一个值重复，其它均只出现一次 -&gt; 将数组中的元素全部异或，再减去1-100的全部异或，即可得到重复的数值</li>
</ul>
</li>
</ul>
<h3 id="按位右移-gt-gt"><a href="#按位右移-gt-gt" class="headerlink" title="按位右移 &gt;&gt;"></a>按位右移 &gt;&gt;</h3><ul>
<li>将某数的二进制位全部右移指定位，相当于除以2^n^，正数左补0，负数左补1，右边移出去的位丢弃，例如<code>00100110&gt;&gt;2 = 00001001 即 38&gt;&gt;2 = 38/4 = 9（余数舍弃)</code></li>
</ul>
<h3 id="按位左移-lt-lt"><a href="#按位左移-lt-lt" class="headerlink" title="按位左移 &lt;&lt;"></a>按位左移 &lt;&lt;</h3><ul>
<li>将某数的二进制位全部左移指定位（<strong>当移出的位中不含1时，相当于乘以2^n^</strong>）右补0，左边移出去的位丢弃，例如<code>00001101&lt;&lt;2 = 00110100 即 13&lt;&lt;2 = 13*4 =52</code></li>
</ul>
<h3 id="按位取反"><a href="#按位取反" class="headerlink" title="按位取反 ~"></a>按位取反 ~</h3><ul>
<li>将某数的二进制位数全部取反，0变1，1变0，例如<code>~52 = ~00110100 = 11001011 = 203 = 255-52</code></li>
</ul>
<hr>
<h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><ol>
<li>防溢出求平均数：<code>(x+y)/2</code> ⇒ <code>(x&amp;y)+((x^y)&gt;&gt;1)</code></li>
<li>求绝对值： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">abs</span><span class="params">(<span class="type">int</span> x)</span> &#123; </span><br><span class="line">	<span class="type">int</span> y; </span><br><span class="line">	y = x &gt;&gt; <span class="number">31</span>; </span><br><span class="line">	<span class="keyword">return</span> (x^y)-y;  <span class="comment">//(x+y)^y </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
<li>替代部分条件语句：<code>if (x==a) x = b; else x = a;</code> ⇒ <code>x = (x==a ? b : a);</code> ⇒ <code>x = a ^ b ^ x;</code></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>bit Operation</tag>
      </tags>
  </entry>
  <entry>
    <title>用Hexo搭建个人博客并部署到Github</title>
    <url>/2023/02/28/Blog-Built-with-Hexo&amp;Github/</url>
    <content><![CDATA[<p>若想部署到Gitee码云上，可以参考博客：<a href="https://blog.csdn.net/qq_46036214/article/details/110137239">在Gitee搭建属于自己的博客</a></p>
<p>若想部署到已有域名上，可以参考视频：<a href="https://www.bilibili.com/video/BV1Vg411w7os">1小时WordPress从0到1建站系列</a> </p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>下载 Git 和 Node.js 安装包，注册一个Github账号</p>
<p>Git：<a href="https://git-scm.com/downloads">Downloads | Git (git-scm.com)</a></p>
<p>Node.js：<a href="https://nodejs.org/en/download/">Download | Node.js (nodejs.org)</a></p>
<p>安装Git后，鼠标右键有 <code>Git Bash Here</code> 选项，点击打开Git终端，输入命令<code>git --version</code> 能看到版本号即安装成功</p>
<p>安装Node.js后，配置环境变量（在系统变量Path中添加Node.js目录即可），在Git终端中输入命令<code>node -v</code> 能看到版本号即安装成功</p>
<hr>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li><p>在本地磁盘建个文件夹，用来放Hexo</p>
</li>
<li><p>进入文件夹，执行下方命令安装Hexo：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo -g</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入命令<code>hexo -v</code> 能看到好多版本号即安装成功（若安装失败看最下面 问题1）</p>
</li>
<li><p>安装 git部署依赖：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建Github仓库（参考博客<a href="https://zhuanlan.zhihu.com/p/60578464">使用Hexo+GitHub 搭建个人免费博客教程</a>的 3.创建Github仓库 部分）</p>
<p>注意：如果你的Github用户名为<code>User</code>，仓库名(repository name)最好为 <code>User.github.io</code>，否则可能404，或Github Pages网址变奇怪，看评论区→<a href="https://zhuanlan.zhihu.com/p/28321740">三分钟在GitHub上搭建个人博客</a></p>
</li>
<li><p>部署 Hexo 到 GitHub Pages（参考博客<a href="https://zhuanlan.zhihu.com/p/60578464">使用Hexo+GitHub 搭建个人免费博客教程</a>的 5.部署 部分）</p>
<p>注：<strong>hexo-deployer-git</strong>已安装；<code>_config.yml</code>  文件在Hexo安装根目录，修改最下方deploy部分的repo内容为：<code>https://github.com/用户名/用户名.github.io.git</code>（仓库Clone代码的位置可以复制）；修改branch时，注意你的Github仓库分支是<code>main</code>还是<code>master</code></p>
</li>
<li><p>完成后打开Git终端运行命令：（使用Hexo相关命令报错 看最下方 问题2）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>进入本地浏览器打开<code>http://localhost:4000/</code>测试（回到终端，<code>Ctrl+C</code>退出）</p>
</li>
<li><p>输入下方命令进行部署：（超时或断联可以多试几次，或换用<code>npx hexo d</code>试试）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>看到 <code>INFO  Deploy done: git</code> 表示部署完成</p>
</li>
<li><p>在浏览器输入 <code>https://用户名.github.io/</code> 即可访问个人博客啦</p>
</li>
</ol>
<hr>
<h2 id="博客优化"><a href="#博客优化" class="headerlink" title="博客优化"></a>博客优化</h2><h4 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h4><ol>
<li><p>进入Hexo安装根目录（能看到_config.yml文件）</p>
</li>
<li><p>下载ayer主题（以ayer主题为例，参考<a href="https://shen-yu.gitee.io/2019/ayer/">Ayer中文说明</a>）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Shen-Yu/hexo-theme-ayer.git themes/ayer</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置根目录<code>_config.yml</code>文件，找到<code>theme</code>修改为<code>ayer</code>保存退出</p>
</li>
<li><p>依次执行命令<code>hexo clean</code>，<code>hexo g</code> ，<code>hexo d</code>更新部署即可</p>
</li>
</ol>
<h4 id="添加分类和标签"><a href="#添加分类和标签" class="headerlink" title="添加分类和标签"></a>添加分类和标签</h4><ol>
<li><p>进入Hexo根目录blog中，打开Git终端，执行以下命令生成分类页</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入 .&#x2F;source&#x2F;categories&#x2F;中，打开<code>index.md</code>，添加 <code>type: &quot;categories&quot;</code>到内容中，示例结果如下所示：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2020-12-31 11:11:11</span><br><span class="line"><span class="section">type: &quot;categories&quot;</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>

<p>保存关闭文件</p>
</li>
<li><p>打开需要添加分类的文章，为其添加categories属性。下方的<code>categories: - 技术</code>表示添加这篇文章到 <code>技术</code> 这个分类，二级分类 <code>- web前端</code>表示添加这篇文章到 <code>技术</code>分类下的 <code>web前端</code>二级分类中（一篇文章不能属于多个同级分类）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2020-12-31 12:12:12</span><br><span class="line">categories:</span><br><span class="line">- 技术</span><br><span class="line">- web前端</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
</li>
<li><p>保存退出，依次执行命令<code>hexo clean</code>，<code>hexo g</code> ，<code>hexo d</code>更新即可</p>
</li>
<li><p>添加标签与添加分类过程类似，只需要把<code>categories</code>更换成<code>tags</code>即可（标签不存在层级关系，一篇文章可以属于多个标签）</p>
<p>注：多个tags的另一种写法：<code>tags: [tag1, tag2, tag3, ...]</code></p>
</li>
</ol>
<hr>
<h2 id="遇到问题及解决方案"><a href="#遇到问题及解决方案" class="headerlink" title="遇到问题及解决方案"></a>遇到问题及解决方案</h2><ul>
<li><p><b>问题1：安装Hexo报错 bash: hexo: command not found</b></p>
<p> 官网安装命令如下(一般第二句hexo会出问题)：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p> 解决方案：进入文件夹，<code>Shift</code>+<code>鼠标右键</code>打开Powershell输入以下命令：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npx hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line">npx hexo server</span><br></pre></td></tr></table></figure>

<p> 在本地浏览器打开<code>http://localhost:4000/</code>即可看到Hexo界面（回到终端，<code>Ctrl+C</code>退出）</p>
<p> （如果hexo相关命令找不到，可以尝试在命令首部加<code>npx</code>，即<code>npx hexo clean</code>等）</p>
</li>
<li><p><b>问题2：安装Hexo后使用Hexo相关命令报错 hexo: command not found</b></p>
<p> 在环境变量Path中添加 <code>Hexo安装路径\node_modules\hexo\bin</code>，重新打开Git终端即可</p>
</li>
</ul>
<hr>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/The_X_One/article/details/106753814">使用hexo框架+ayer主题+gitalk评论插件搭建个人博客</a></p>
<p><a href="https://blog.csdn.net/qq_42893625/article/details/100852221">安装Hexo报错bash: hexo: command not found问题解决</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/28321740">三分钟在GitHub上搭建个人博客</a></p>
<p><a href="https://www.cnblogs.com/chenlove/p/15058170.html">【保姆级】利用Github搭建自己的个人博客，看完就会</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/60578464">使用 Hexo+GitHub 搭建个人免费博客教程（小白向）</a></p>
<p><a href="https://gitee.com/shen-yu/hexo-theme-ayer">hexo-theme-ayer: 一个安静且优雅的Hexo主题</a></p>
<p><a href="https://www.jianshu.com/p/e17711e44e00">Hexo使用攻略-添加分类及标签</a></p>
<p><a href="https://www.nickyam.com/tech/hexo-multi-tags.html">Hexo 多标签及分级目录设置方法举例</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 开发入门</title>
    <url>/2023/03/10/Android-develop-introduction/</url>
    <content><![CDATA[<h2 id="各种布局"><a href="#各种布局" class="headerlink" title="各种布局"></a>各种布局</h2><ol start="0">
<li><p><strong>主布局</strong>（以线性布局为例）</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 需要在主布局的标签中 声明命名空间的引用(xmlns:android) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p> 参考：<a href="https://blog.csdn.net/weixin_40316053/article/details/100735950">xmlns: android相关</a></p>
</li>
<li><p><strong>线性布局</strong>（水平）</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;horizontal&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> <code>match_parent</code> 表示尽可能的占满该方向的空间<br> <code>wrap_content</code> 表示只占用内容物大小的空间<br> <code>orientation</code>属性 用于控制布局的方向，<code>horizontal</code>为水平方向，<code>vertical</code>表示竖直方向</p>
</li>
<li><p><strong>相对布局</strong>（内部组件居中）</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;20dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>表格布局</strong>（下面示例的首行为 文本框，第二行为文字+编辑框）</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TableLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TableRow</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">TableRow</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">TableLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 直接往<code>TableLayout</code>中添加组件, 该组件会占满一行；如果想要一行上有多个组件, 就要添加<code>TableRow</code>容器。</p>
</li>
<li><p><strong>框架布局 &#x2F; 帧布局</strong></p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>补充说明</strong>：</p>
<ol>
<li>在以上所有布局中都可以添加 <code>layoutDirection</code>属性，表示布局的内部方向，默认值为<code>ltr</code>从左向右，<code>rtl</code>表示从右向左</li>
<li>关于<code>layout_gravity</code>和<code>gravity</code>属性：<br>(1) <code>layout_gravity</code> 是设置自身相对于它外层容器的对齐方式。<br>(2) <code>gravity</code> 是设置自身内部元素的对齐方式。<br>比如在 TextView 中设置，是设置它内部文字的对齐方式。<br>如果是 ViewGroup 组件如 LinearLayout，则为设置它内部view组件的对齐方式。</li>
</ol>
<hr>
<h2 id="各种组件"><a href="#各种组件" class="headerlink" title="各种组件"></a>各种组件</h2><ol>
<li><p>文本视图（TextView）</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/tv_username&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginStart</span>=<span class="string">&quot;5dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;5dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;用户名&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">&quot;#000000&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;20sp&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p> <code>android:autoLink</code> 属性用于识别链接，<code>&quot;web&quot;</code>识别web网址，<code>&quot;phone&quot;</code>识别电话号码，<code>&quot;email&quot;</code>识别邮件地址，<code>&quot;all&quot;</code>识别所有类型</p>
</li>
<li><p>图像视图（ImageView）</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/img_id&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;150dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:src</span>=<span class="string">&quot;@drawable/img_name_without_suffix&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>按钮（Button）</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/login_btn&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;100dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginStart</span>=<span class="string">&quot;160dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;5dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:backgroundTint</span>=<span class="string">&quot;@android:color/background_dark&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;登录&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">&quot;#ffffff&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:onClick</span>=<span class="string">&quot;myClick&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;18sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:visibility</span>=<span class="string">&quot;visible&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑框（EditText）</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/et_pwd&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;60dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginStart</span>=<span class="string">&quot;5dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;5dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:hint</span>=<span class="string">&quot;请输入密码&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColorHint</span>=<span class="string">&quot;#747373&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p> <code>android:inputType</code>属性用于识别输入文字类型，<code>&quot;phone&quot;</code>识别电话号码，……<br> 关于更多inputType属性相关内容可以参考：<a href="https://www.jianshu.com/p/ca73cc4464f6">android: inputType - 简书</a><br> 获取编辑框输入：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">EditText</span> <span class="variable">et_name</span> <span class="operator">=</span> findViewById(R.id.et_name);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> et_name.getText().toString();</span><br></pre></td></tr></table></figure>
</li>
<li><p>单选框（RadioButton）</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RadioGroup</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/rg&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;250dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;230dp&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RadioButton</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/size_S&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;160dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;30dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_weight</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;size_S&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;18sp&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RadioGroup</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 获取选中值（e.g. 男女性别选择）：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RadioButton</span> <span class="variable">rb_male</span> <span class="operator">=</span> findViewById(R.id.rb_male);</span><br><span class="line"><span class="type">String</span> <span class="variable">sex</span> <span class="operator">=</span> male.isChecked() ? <span class="string">&quot;男&quot;</span> : <span class="string">&quot;女&quot;</span>;、</span><br></pre></td></tr></table></figure>
</li>
<li><p>复选框（Checkbox）</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">CheckBox</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/cb_run&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;160dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;30dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginStart</span>=<span class="string">&quot;50dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;早起跑10km&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;20sp&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p> 是否选中：<code>cb_run.isChecked()</code></p>
</li>
<li><p>会话框（Dialog）</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AlertDialog.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AlertDialog</span>.Builder(MainActivity.<span class="built_in">this</span>);</span><br><span class="line">builder.setTitle(<span class="string">&quot;尊敬的&quot;</span>+username+<span class="string">&quot; 舰长&quot;</span>);</span><br><span class="line">builder.setMessage(<span class="string">&quot;我是一个对话框~QwQ~&quot;</span>);</span><br><span class="line">builder.setPositiveButton(<span class="string">&quot;正面回答&quot;</span>, (dialog, which) -&gt; posOnClickListenerMethod());</span><br><span class="line">builder.setNegativeButton(<span class="string">&quot;消极回答&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="type">AlertDialog</span> <span class="variable">dialog</span> <span class="operator">=</span> bd.create();</span><br><span class="line">dialog.show();</span><br></pre></td></tr></table></figure>
</li>
<li><p>Toast（短时提示信息）</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Toast</span> <span class="variable">toast</span> <span class="operator">=</span> Toast.makeText(getApplicationContext(), <span class="string">&quot;提示信息&quot;</span>, Toast.LENGTH_SHORT);</span><br><span class="line">toast.show();</span><br></pre></td></tr></table></figure>
<p> makeText的获取上下文参数 <code>MainActivity.this</code> 也可以用 <code>getApplicationContext()</code></p>
</li>
<li><p>Spinner（下拉栏）</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要在MainActivity类中添加成员变量 Spinner spinner; 和 String[] deptsArray;</span></span><br><span class="line"><span class="comment">// 在onCreate()函数中添加以下代码</span></span><br><span class="line">spinner = findViewById(R.id.spinner);  <span class="comment">//获取Spinner组件</span></span><br><span class="line">deptsArray = getResources().getStringArray(R.array.spinner_data);  <span class="comment">//获取array中定义的值</span></span><br><span class="line">spinner.setOnItemSelectedListener(<span class="keyword">new</span> <span class="title class_">AdapterView</span>.OnItemSelectedListener() &#123;  <span class="comment">//添加Spinner监听事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onItemSelected</span><span class="params">(AdapterView&lt;?&gt; parent, View view, <span class="type">int</span> pos, <span class="type">long</span> id)</span> &#123;</span><br><span class="line">        spinnerContent = deptsArray[pos];&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNothingSelected</span><span class="params">(AdapterView&lt;?&gt; parent)</span> &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p> 其他 获取spinner选中的值 的方法可以参考：<a href="https://blog.csdn.net/paokuhuashang/article/details/104882857">Android 获取spinner选中的值-小小白的CSDN博客</a> 和 <a href="https://www.cnblogs.com/does/p/12795980.html">Android Spinner下拉框的基本使用-博客园 </a></p>
</li>
<li><p>Intent（将信息传给其他Activity）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送方 MainActivity</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MainActivity.<span class="built_in">this</span>, ReceiverActivity.class);</span><br><span class="line">intent.putExtra(<span class="string">&quot;data&quot;</span>, message);  <span class="comment">// 参数分别为 信息名, 信息体</span></span><br><span class="line">startActivity(intent);  <span class="comment">//启动Activity</span></span><br><span class="line">finish();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接收方 ReceiverActivity</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> getIntent();</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> intent.getStringExtra(<span class="string">&quot;data&quot;</span>);  <span class="comment">// 根据信息名获取信息</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://blog.csdn.net/weixin_43615488/article/details/102553268">Android TabLayout 实现底部导航栏和顶部导航栏</a></p>
</li>
<li><p>xxx</p>
</li>
</ol>
<hr>
<h2 id="组件控制"><a href="#组件控制" class="headerlink" title="组件控制"></a>组件控制</h2><ul>
<li>示例：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_xxx);  <span class="comment">//设置activity</span></span><br><span class="line">        <span class="comment">// 为清除按钮绑定点击监听函数</span></span><br><span class="line">        <span class="type">Button</span> <span class="variable">btn</span> <span class="operator">=</span> findViewById(R.id.clear_btn);</span><br><span class="line">        btn.setOnClickListener(<span class="keyword">new</span> <span class="title class_">clearOnClickListener</span>());</span><br><span class="line">        <span class="comment">// findViewById(R.id.login_btn).setOnClickListener(new loginOnClickListener());  //绑定(简写)</span></span><br><span class="line">    &#125; <span class="comment">// end onCreate</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">clearOnClickListener</span> <span class="keyword">implements</span> <span class="title class_">View</span>.OnClickListener &#123;  <span class="comment">// 自定义按钮点击事件监听类</span></span><br><span class="line">        <span class="comment">// static防止内存泄露，但在使用findViewById函数时不能用</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(((CheckBox)findViewById(R.id.cb_dontclearme)).isChecked())</span><br><span class="line">                ((TextView)findViewById(R.id.tv_print)).setText(output_str);</span><br><span class="line">            ((EditText)findViewById(R.id.et_pwd)).setText(<span class="string">&quot;&quot;</span>);  <span class="comment">// 清空密码编辑框(简写)</span></span><br><span class="line">            <span class="type">EditText</span> <span class="variable">et</span> <span class="operator">=</span> findViewById(R.id.et_username);</span><br><span class="line">            et.setText(<span class="string">&quot;&quot;</span>);  <span class="comment">// 清空用户名编辑框</span></span><br><span class="line">            et.setHint(<span class="string">&quot;请输入姓名&quot;</span>);  <span class="comment">// 设置提示信息</span></span><br><span class="line">        &#125; <span class="comment">// end onClick</span></span><br><span class="line">    &#125; <span class="comment">// end class</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h2><ol>
<li><p>匿名内部类（或用 lambda表达式简写）</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">findViewById(R.id.register_btn)</span><br><span class="line">    .setOnClickListener( (v) -&gt; &#123;</span><br><span class="line">        Toast.makeText(MainActivity.<span class="built_in">this</span>,</span><br><span class="line">                <span class="string">&quot;注册&quot;</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>为每一个按钮 创建一个 实现监听接口 的内部监听类</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The following codes are all in MainActivity Class</span></span><br><span class="line"><span class="keyword">private</span> Button login_btn;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    login_btn = findViewById(R.id.login_btn);</span><br><span class="line">    login_btn.setOnClickListener(<span class="keyword">new</span> <span class="title class_">loginOnClickListener</span>());</span><br><span class="line">    <span class="comment">// 一次性使用的绑定监听器缩写（不推荐）</span></span><br><span class="line">    ((Button)findViewById(R.id.login_btn))</span><br><span class="line">        .setOnClickListener(<span class="keyword">new</span> <span class="title class_">loginOnClickListener</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部监听类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">loginOnClickListener</span> <span class="keyword">implements</span> <span class="title class_">View</span>.OnClickListener &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">        <span class="type">Toast</span> <span class="variable">toast</span> <span class="operator">=</span> Toast.makeText(getApplicationContext(), <span class="string">&quot;登录&quot;</span>, Toast.LENGTH_SHORT);</span><br><span class="line">        toast.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>给组件设置onClick属性，绑定java代码中的响应函数。这种方式允许多个按钮注册 到同一个事件的监听器上，实现代码重用</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listener</span><span class="params">(View v)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (v.getId()) &#123;</span><br><span class="line">        <span class="keyword">case</span> R.id.forget_btn:</span><br><span class="line">            Toast.makeText(getApplicationContext(),<span class="string">&quot;忘记密码&quot;</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> R.id.checkbox_remember:</span><br><span class="line">            Toast.makeText(getApplicationContext(),<span class="string">&quot;记住密码复选框&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> R.id.checkbox_autoLogin:</span><br><span class="line">            Toast.makeText(getApplicationContext(),“自动登录复选框<span class="string">&quot;, Toast.LENGTH_SHORT).show();</span></span><br><span class="line"><span class="string">            break;</span></span><br><span class="line"><span class="string">        default:</span></span><br><span class="line"><span class="string">            break;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="安卓项目结构"><a href="#安卓项目结构" class="headerlink" title="安卓项目结构"></a>安卓项目结构</h2><h3 id="res（资源）"><a href="#res（资源）" class="headerlink" title="res（资源）"></a>res（资源）</h3><ul>
<li><p><strong>res&#x2F;drawable</strong><br><strong>drawable文件夹</strong>存储bitmap文件(png, jpeg, gif)，9-patch文件和xml文件等<strong>应用内部需要的大部分图像资源</strong>，这些文件用于描述包含多种状态(normal, pressed, focused)的可绘制形状或可绘制对象。</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">&quot;@drawable/hitwh002&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">...</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>res&#x2F;mipmap</strong><br><strong>mipmap文件夹</strong>用于存放<strong>APP的icon图标文件</strong> 或 <strong>经常被放大缩小且其图像质量对应用程序至关重要的图像</strong>。Android系统会保留这个文件夹中所有的图片资源，而不受到应用安装的设备的屏幕分辨率的影响。这个行为允许启动程序为应用选择最好的分辨率图标显示在主屏幕上。</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher”</span></span></span><br><span class="line"><span class="string"><span class="tag">    android:roundIcon=&quot;</span>@<span class="attr">mipmap</span>/<span class="attr">ic_launcher_round</span>”</span></span><br><span class="line"><span class="tag">    <span class="attr">...</span> &gt;</span></span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://blog.csdn.net/wq6ylg08/article/details/114543624">Android中drawable或mipmap文件夹存放图片的区别-CSDN快乐李同学</a></p>
</li>
<li><p><strong>res&#x2F;values</strong><br>默认存放4个安卓XML资源（colors, dimens, strings, styles），也可以添加其他资源文件<br><strong>colors.xml</strong>：保存颜色资源，<code>&lt;color name=&quot;xxcolor&quot;&gt;#000000&lt;/color&gt;</code><br><strong>dimens.xml</strong>：尺寸控制，<code>&lt;dimen name=&quot;xx&quot;&gt;16dp&lt;/dimen&gt;</code><br><strong>strings.xml</strong>：字符串，<code>&lt;string name=&quot;xxstr&quot;&gt;某字符串&lt;/dimen&gt;</code><br><strong>styles.xml</strong>：样式主题<br><strong>还可以在新建xml文件中添加Spinner组件需要的string-array资源</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;string-array name=&quot;spinner_data&quot;&gt;</span><br><span class="line">        &lt;item&gt;item_1&lt;/item&gt;</span><br><span class="line">        &lt;item&gt;item_2&lt;/item&gt;</span><br><span class="line">&lt;/string-array&gt;</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://blog.csdn.net/Small_Mouse0/article/details/58593354">Android Values文件作用及使用方法-CSDN鼠晓</a></p>
</li>
<li><p><strong>res&#x2F;layout</strong><br><a href="https://blog.csdn.net/weixin_42814000/article/details/108249762">Android Studio 在layout文件夹下建立子文件夹-CSDN林伟茂</a><br><a href="https://blog.csdn.net/weixin_43615488/article/details/104107658">Android布局文件夹layout下分模块管理布局-CSDN笔画888</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络3 传输层</title>
    <url>/2022/11/16/Computer-Network-3-Transport-Layer/</url>
    <content><![CDATA[<h1 id="第3章-传输层-Transport-Layer"><a href="#第3章-传输层-Transport-Layer" class="headerlink" title="第3章 传输层(Transport Layer)"></a>第3章 传输层(Transport Layer)</h1><p><code>传输层</code> <strong>&#x3D;&#x3D;</strong> <code>运输层</code><br><code>套接字(Socket)</code> <strong>&#x3D;</strong> <code>IP地址</code> + <code>端口号(port)</code>，位于<strong>应用层</strong></p>
<h2 id="3-1-传输层服务与协议"><a href="#3-1-传输层服务与协议" class="headerlink" title="3.1 传输层服务与协议"></a>3.1 传输层服务与协议</h2><ul>
<li>运输层协议为运行在不同主机上的应用进程之间提供了<strong>逻辑通信</strong> (logic communication) 功能</li>
<li>运输层协议是在<u>端系统</u>中实现。<u>发送端将从发送应用程序进程接收到的报文分段</u>(转换成运输层分组)，传递给网络层；<u>接收端将报文段重组成完整报文</u>，传递给应用层。</li>
<li>关于 <strong>运输层 和 网络层 的关系</strong>：<br>1）网络层 负责在不同主机之间提供 逻辑通信 服务；<br>2）运输层 负责 通过网络层 进行不同主机的进程之间的 逻辑通信。</li>
<li>两种主要的网络传输协议：TCP 和 UDP<br>1）TCP：可靠、有序传输、拥塞控制、流量控制、连接建立<br>2）UDP：不可靠、不保序传输、没有为尽力而为的IP服务添加更多的其它额外服务<br>3）都不提供的服务：延迟保证、带宽保证</li>
</ul>
<hr>
<h2 id="3-2-复用-分用"><a href="#3-2-复用-分用" class="headerlink" title="3.2 复用 分用"></a>3.2 复用 分用</h2><ul>
<li>**复用 &#x2F; 多路复用(multiplexing)**：<u>从源主机的不同套接字中收集数据块，并为每个数据块封装上首部信息(“传输头”)，进而生成报文段，然后将报文段传递到网络层</u>，就是 把多个数据流 (streams) 合并为一个数据流</li>
<li>**分用 &#x2F; 多路分解(demultiplexing)**：<u>将运输层报文段中的数据交付到正确的套接字的工作</u>，就是 复用的逆过程，数据流被分离成单独的部分，相当于解码。具体操作为：接收端的运输层标识出报文段中的接受套接字，进而将报文段定向到该套接字</li>
<li>多路复用和多路分解服务是所有计算机网络都需要的</li>
</ul>
<p>理解：你的的手机正在浏览网页，刷新电子邮件，同时连接到微信。所有这些连接都通过同一链路发送，这一过程为<u>复用</u>；手机接收到的数据包流将被分割并发送到相应的网络、电子邮件、微信程序，该过程为<u>分用</u></p>
<h3 id="无连接的分用、复用-UDP"><a href="#无连接的分用、复用-UDP" class="headerlink" title="无连接的分用、复用(UDP)"></a>无连接的分用、复用(UDP)</h3><ul>
<li>UDP Socket &#x3D; (dstIP, dstPort)<br><strong>UDP 套接字</strong> &#x3D; (<strong>目标IP地址</strong> + <strong>目标端口号</strong>)</li>
<li><strong>发送方</strong>创建UDP套接字的数据报时，必须指定 <strong>目标IP地址</strong>、<strong>目标端口</strong>，而且包含<strong>源端口号</strong><br>（A send <u>b-ip, b-port, a-ip, a-port</u> to B，包含源端口号是为了 接受方B回发报文段给发送方A时，使用recvfrom()方法从发送方的UDP报文段中取源端口号的值，当然完整的返回地址为 源IP+源端口）</li>
<li><strong>接收方</strong>接收UDP报文段时，<strong>检查段中的目的端口</strong>，<strong>将UDP报文段定向到 具有指定目标端口的套接字</strong></li>
<li>不同源IP地址或源端口号的数据报，具有相同目标端口，发送到同一个目标IP地址，会定向到同一目标套接字<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/95cc2c4a0b844503810f60aa39fd6e65.png">https://img-blog.csdnimg.cn/95cc2c4a0b844503810f60aa39fd6e65.png</a> &#x3D;600x)</li>
</ul>
<h3 id="面向连接的分用、复用-TCP"><a href="#面向连接的分用、复用-TCP" class="headerlink" title="面向连接的分用、复用(TCP)"></a>面向连接的分用、复用(TCP)</h3><ul>
<li>TCP socket &#x3D; (sourceIP, sourcePort, destIP, destPort)<br><strong>TCP 套接字</strong> &#x3D; (<strong>源IP地址</strong> + <strong>源端口号</strong> + <strong>目标IP地址</strong> + <strong>目标端口号</strong>)</li>
<li>服务器主机支持许多并行的TCP套接字，<strong>每个套接字与 1 个进程&#x2F;线程相联系</strong>，且由四元组来标识套接字</li>
<li>(与UDP不同) <u>两个不同源IP地址或源端口号的数据报，即使具有相同的目标端口和目标IP地址，也会定向到不同的套接字</u><br>（若TCP报文段中包含 初始创建TCP连接的请求，接收方服务器会创建新的套接字）<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/a175ba3071e44ec486576df361ef1bf2.png">https://img-blog.csdnimg.cn/a175ba3071e44ec486576df361ef1bf2.png</a> &#x3D;600x)<br>参考上图3.5，主机A，Web服务器B，主机C的IP地址分别为A、B、C。主机C 与 服务器B 之间有两个HTTP会话连接，会话源端口号分别为7532、26145，目标端口号都为80，在服务器传输层 分用 至两个不同的套接字；主机A 与 服务器B 之间由一个HTTP会话连接，源端口号为26145，目标端口号为80，与主机A的其中一个会话源端口号相同，但在服务器传输层也会 分用 至两个套接字。（总结：每个套接字由其四元组标识；目标端口相同的数据被分用至不同的套接字）</li>
</ul>
<h3 id="持续-x2F-非持续HTTP连接-与-常见端口"><a href="#持续-x2F-非持续HTTP连接-与-常见端口" class="headerlink" title="持续&#x2F;非持续HTTP连接 与 常见端口"></a>持续&#x2F;非持续HTTP连接 与 常见端口</h3><ul>
<li>持续HTTP：在整个连接持续期间，客户端与服务器之间 经由 同一个服务器套接字交换 HTTP报文</li>
<li>非持续HTTP：对每一对请求&#x2F;响应都创建一个新的TCP连接和一个套接字并随后就关闭（这种套接字的频繁创建-关闭会严重影响服务器性能，即使可以通过操作系统技巧减轻影响）</li>
<li><strong>常见端口</strong>：<br>Port 80：标准HTTP连接<br>Port 22：SSH 远程计算机而当路<br>Port 25：SMTP端口，邮件服务器使用的默认端口<br>Port 143：IMAP端口，接收电子邮件，类似与POP3<br>Port 443：标准HTTPS连接，安全<br><a href="https://www.ssl2buy.com/wiki/port-80-http-vs-port-443-https">端口对比：Port 80 (HTTP) vs. Port 443 (HTTPS)</a></li>
</ul>
<hr>
<h2 id="3-3-无连接传输-UDP"><a href="#3-3-无连接传输-UDP" class="headerlink" title="3.3 无连接传输: UDP"></a>3.3 无连接传输: UDP</h2><ul>
<li>UDP 协议 是 实现了端口的 IP协议，可以让数据包在送到某个IP地址的基础上，进而送到运行在某一端口的通信进程<br>UDP 协议是TCP 协议的简化版，出现于TCP之后<br>应用场景：直播等流媒体应用程序、域名系统DNS、NFS等</li>
<li>UDP 协议的<strong>优点</strong>：<u>简单、快、高效(Efficient)、没有拥塞控制</u>；<strong>缺点</strong>：<u>传输不可靠、尽力而为(Best Effort)、UDP报文段可能会丢包、乱序</u></li>
<li><strong>UDP 报文段(segment) &#x3D; [ 源端口号，目标端口号，长度，校验和，应用程序数据 ]</strong><br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/24d49240b961405ca5787d4ec99f771e.png">https://img-blog.csdnimg.cn/24d49240b961405ca5787d4ec99f771e.png</a> &#x3D;250x)<br><strong>length</strong>：<u>以 bytes 为单位的UDP报文段长度，包含传输头(UDP Segment Header)的长度 和 原始数据(Payload)长度</u>，其中 udpSegmentHeader &#x3D; sPort+dPort+Length+CheckSum &#x3D; 16 bits*4 &#x3D; 8 bytes)<br><strong>checksum</strong>：用于检测整个数据包是否损坏（包括整个UDP数据包，以及IP头部的源IP和目标IP等信息），没有改正能力，在IPv4中可以不使用checksum，即checksum为0</li>
<li>检验和 checksum 的具体计算方式还没写, 可以先看书 ：）</li>
</ul>
<hr>
<h2 id="3-4-可靠数据传输原理-rdt"><a href="#3-4-可靠数据传输原理-rdt" class="headerlink" title="3.4 可靠数据传输原理(rdt)"></a>3.4 可靠数据传输原理(rdt)</h2><ul>
<li>背景：期望每次信息传输都是理想状态是不太可能的，而且 “Best Effort”的 IP协议不会修复，传输自己时还可能产生错误或丢失，所以需要可靠数据传输(Reliable Data Transfer)</li>
</ul>
<hr>
<h3 id="rdt-1-0：经完全可靠信道的可靠数据传输"><a href="#rdt-1-0：经完全可靠信道的可靠数据传输" class="headerlink" title="rdt 1.0：经完全可靠信道的可靠数据传输"></a>rdt 1.0：经完全可靠信道的可靠数据传输</h3><p>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/2d26bd0af7de46dfbb1eb58e5d85c9fc.png">https://img-blog.csdnimg.cn/2d26bd0af7de46dfbb1eb58e5d85c9fc.png</a> &#x3D;420x)</p>
<hr>
<h3 id="rdt-2-0：发现并修复位差错"><a href="#rdt-2-0：发现并修复位差错" class="headerlink" title="rdt 2.0：发现并修复位差错"></a>rdt 2.0：发现并修复位差错</h3><p>引入3种功能：<br>    1. 通过 checksum 来校验错误<br>    2. 接收者 反馈接受 ACK 和 NAK信息<br>    3. 重传<br>    理解：传输层对应用层的数据进行打包处理时，新增checksum（校验和），从而接收端可以对其数据包进行检验，如果正确，返回ACK，发送者继续发送下一个数据包；如果不正确，返回NAK，发送者重传数据。</p>
<ul>
<li>rdt2.0 没有错误时的操作<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/d5cf8c294ac049fd9cf878ceecbf8e37.png">https://img-blog.csdnimg.cn/d5cf8c294ac049fd9cf878ceecbf8e37.png</a> &#x3D;550x)</li>
<li>rdt2.0 发生错误时的流程<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/b7c5d0f7f14d4c38ae99fb81c6ea2fb0.png">https://img-blog.csdnimg.cn/b7c5d0f7f14d4c38ae99fb81c6ea2fb0.png</a> &#x3D;600x)</li>
</ul>
<hr>
<h3 id="rdt-2-1：数据包带序号"><a href="#rdt-2-1：数据包带序号" class="headerlink" title="rdt 2.1：数据包带序号"></a>rdt 2.1：数据包带序号</h3><ul>
<li>背景：rdt2.0不能解决ACK和NAK出错的问题，重传可能会导致重复</li>
<li><strong>解决</strong>：<br>  ① 发送方为每一个数据包添加 <strong>编号</strong>(seq)<br>  ② ACK &#x2F; NAK出错，发送方重传<br>  ③ 接收方丢弃重复的数据包<br>  ④ <strong>“stop and wait” 停等</strong>机制，发送方发送一个包，等待接收方回应</li>
<li>机制：<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/d58e985528844639aeaa4b31cbb05fc9.png">https://img-blog.csdnimg.cn/d58e985528844639aeaa4b31cbb05fc9.png</a> &#x3D;700x)<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/37207f40a6bd4f42999828b7573810f2.png">https://img-blog.csdnimg.cn/37207f40a6bd4f42999828b7573810f2.png</a> &#x3D;750x)<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/img_convert/e24ac0ff9649e468371040625179aaba.webp?x-oss-process=image/format,png">https://img-blog.csdnimg.cn/img_convert/e24ac0ff9649e468371040625179aaba.webp?x-oss-process=image/format,png</a> &#x3D;700x)</li>
</ul>
<h3 id="rdt-2-2：ACK取代NAK"><a href="#rdt-2-2：ACK取代NAK" class="headerlink" title="rdt 2.2：ACK取代NAK"></a>rdt 2.2：ACK取代NAK</h3><ul>
<li>用 <strong>带序号的ACK</strong> 代替 ACK &#x2F; NAK，接收方接收ACK信号时检查ACK的序号</li>
<li>机制<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/2a547ba52a1f4d15a009a9ff851fb393.png">https://img-blog.csdnimg.cn/2a547ba52a1f4d15a009a9ff851fb393.png</a> &#x3D;700x)<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/9f49bb550b4b4d3e95e5a64ef397ce1f.png">https://img-blog.csdnimg.cn/9f49bb550b4b4d3e95e5a64ef397ce1f.png</a> &#x3D;700x)</li>
</ul>
<h3 id="rdt-3-0：超时重传-治疗数据包丢失"><a href="#rdt-3-0：超时重传-治疗数据包丢失" class="headerlink" title="rdt 3.0：超时重传 治疗数据包丢失"></a>rdt 3.0：超时重传 治疗数据包丢失</h3><ul>
<li>问题背景：数据包或ACK丢失，可能会导致重传和数据重复</li>
<li>解决：<strong>超时重传</strong><br>发送端在设定时间内没有收到指定编号的ACK则重传<br>重传虽然会导致数据重复，但可以通过序列号解决</li>
<li>机制：<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/e61f3b679814457eb1cc8afb17d2fbdc.png">https://img-blog.csdnimg.cn/e61f3b679814457eb1cc8afb17d2fbdc.png</a> &#x3D;700x)<br>![f3.0.1](<a href="https://img-blog.csdnimg.cn/ac2f28e9bb99482da4d0acee654a6767.png">https://img-blog.csdnimg.cn/ac2f28e9bb99482da4d0acee654a6767.png</a> &#x3D;700x)<br><img src="https://img-blog.csdnimg.cn/a35a79b156de4fc98f67b68d31f74725.png" alt="在这里插入图片描述"></li>
</ul>
<hr>
<h2 id="3-5-流水线技术-GoBackN-amp-Selective-Repeat"><a href="#3-5-流水线技术-GoBackN-amp-Selective-Repeat" class="headerlink" title="3.5 流水线技术(GoBackN &amp; Selective Repeat)"></a>3.5 流水线技术(GoBackN &amp; Selective Repeat)</h2><ul>
<li>问题：1 Gbps link, 15ms 延迟, 8000bit 大小的包，将round-trip-time作为传播到那里和返回的时间（rtt，即两倍的end-to-end延时)，传输延时和信道利用率是多少？<br>答：$L$-包大小；$R$-传输速率。<br>$D_{trans}&#x3D;L&#x2F;R&#x3D;\frac{8000bits}{10^{9}bit&#x2F;s}&#x3D;8ms$<br>$U_{sender}&#x3D;\frac{L&#x2F;R}{RTT+L&#x2F;R}&#x3D;\frac{0.008}{15*2+0.008}&#x3D;0.027%$</li>
<li><strong>流水线技术(Pipelining)<strong>：允许发送方在</strong>未得到对方确认</strong>的情况下<strong>一次发送多个包</strong></li>
<li>条件：<br>① <strong>增加 包&#x2F;应答 的序号范围</strong><br>② <strong>发送方 设置缓存</strong>（未得到确认，可能需要重传 &#x3D;&#x3D;？&#x3D;&#x3D;）<br>③ <strong>接收方 设置缓存</strong>（上层用户取用数据的速率≠接收到的数据速率；接收的数据包可能乱序；可能需要重新排序后交付）<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/d33bc0ea55e24c5f90d14c8abe4447d4.png">https://img-blog.csdnimg.cn/d33bc0ea55e24c5f90d14c8abe4447d4.png</a> &#x3D;600x)<br><a href="https://www2.tkn.tu-berlin.de/teaching/rn/animations/gbn_sr/"><strong>Go-Back-N 与 Selective Repeat 过程动画演示</strong></a></li>
</ul>
<h3 id="Go-Back-N"><a href="#Go-Back-N" class="headerlink" title="Go-Back-N"></a>Go-Back-N</h3><ul>
<li>核心：sender能够在收到确认之前发送多个分组，但receiver只能缓存一个符合要求的分组并回复确认<ul>
<li><strong>发送方一次发送 N 个包</strong></li>
<li><strong>接收方 只缓存并确认 按顺序正确到达的包</strong></li>
<li>发送方设置计时器，<strong>超时(没收到回应)重传</strong></li>
</ul>
</li>
<li>机制：<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/141038371226432eb82f13356dd72aab.png">https://img-blog.csdnimg.cn/141038371226432eb82f13356dd72aab.png</a> &#x3D;600x)</li>
<li>缺点：<br>Go-Back-N在一定程度上避免了停等协议中信道利用率低下的问题，但在窗口N较大时，Go-Back-N需要重传的包较多，代价大</li>
</ul>
<h3 id="选择重传-Selective-Repeat"><a href="#选择重传-Selective-Repeat" class="headerlink" title="选择重传(Selective Repeat)"></a>选择重传(Selective Repeat)</h3><ul>
<li>核心：<br>① <strong>接收方单独确认所有正确接受的包</strong>(不按顺序)<br>② 根据需要，将缓冲区中的包按顺序传给上层<br>③ 发送方仅发送 未收到ACK的包<br>④ 每个未确认的包都有计时器，超时重传</li>
<li><strong>机制</strong>：<br><strong>Sender</strong>：<br>① 收到上层数据，如果 发送窗格的下一个序号可用，打包发送<br>② packet(n) 超时，重发n号包，计时器重置<br>③ 收到 ACK(n)，如果 n 是未确认的包中编号最小的，右移发送窗格<br><strong>Receiver</strong>：<br>① 收到 packet(n)后，回复 ACK(n)<br>② 如果编号顺序乱&#x2F;缺失，缓存并等待接受前面的包<br>③ 如果编号顺序正确，将包传给上层，移动 接收窗格<br>④ 重复的包直接丢弃<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/9a84cffaab7144e5b47d161c477d5e9f.png">https://img-blog.csdnimg.cn/9a84cffaab7144e5b47d161c477d5e9f.png</a> &#x3D;600x)</li>
<li><strong>存在的问题</strong>：<ul>
<li>设帧序号为0,1,2,3 重复使用但内容不同，窗格大小为3，传输过程如下图<br>  ![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/ece3d44fc32142d4b6debfee520e1393.png">https://img-blog.csdnimg.cn/ece3d44fc32142d4b6debfee520e1393.png</a> &#x3D;400x)</li>
<li>当 receiver接受到 0,1,2号包之后，发送ACKs(0,1,2)，移动接收窗格到 [3,0,1] 等待接收packet(3,0,1)。<br>  如果 sender 没有在设定时间内接收到ACKs，会超时重传 packet(0,1,2)。<br>  当 receiver 接收到 sender 重发的 packet(0,1)时，会认为它们是新一轮序号的包，并将其缓存（正常应该直接丢弃的包），造成二义性</li>
<li>解决：<br>  ① 发送窗格 &lt;&#x3D; 接受窗格<br>  ② <strong>发送窗格大小 &lt;&#x3D; $\frac{1}{2}*$序号数</strong>（n比特编码，发送窗格长度最大为$2^{n-1}$）</li>
</ul>
</li>
</ul>
<h2 id="3-6-面向连接传输-TCP"><a href="#3-6-面向连接传输-TCP" class="headerlink" title="3.6 面向连接传输: TCP"></a>3.6 面向连接传输: TCP</h2><ul>
<li><p><strong>面向连接</strong>：只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费</p>
</li>
<li><p><strong>TCP 报文段结构</strong>：<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/89a1a4328a0c4d318e498b1d6a689e00.png">https://img-blog.csdnimg.cn/89a1a4328a0c4d318e498b1d6a689e00.png</a> &#x3D;500x)</p>
<ul>
<li><strong>源端口号 &#x2F; 目的端口号</strong>：16 bits</li>
<li>**序号(sequence number)**：32 bits，段数据中第一个字节的在整个字节流中“编号”，用来标明位置</li>
<li>**确认号(acknowledgements)**：32 bits，期望从对方收到的下一个字节的序号</li>
</ul>
</li>
<li><p><strong>具体应用</strong>：<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/69f75d2998b3474e8ccdb893185322d0.png">https://img-blog.csdnimg.cn/69f75d2998b3474e8ccdb893185322d0.png</a> &#x3D;550x)</p>
</li>
<li><p><a href="https://blog.csdn.net/wgl307293845/article/details/122403761">超时时长的设置</a><br>$DevRTT &#x3D; (1-\beta)<em>DevRTT + \beta</em>|SampleRTT-EstimatedRTT|$</p>
<p>  $Timeout &#x3D; EstimatedRTT + 4 * DevRTT$</p>
<p>  其中 $RTT$为 round-trip-time 往返时间；$DevRTT$为 RTT偏差值(safety margin)；</p>
</li>
</ul>
<p>$SampleRTT$为 报文段的样本RTT； $EstimatedRTT$为TCP对下一个数据往返值进行的估计</p>
<h3 id="TCP可靠数据传输"><a href="#TCP可靠数据传输" class="headerlink" title="TCP可靠数据传输"></a>TCP可靠数据传输</h3><ul>
<li><p>实现：</p>
<ul>
<li><strong>收到上层应用层传来的数据</strong><br>  ① 将数据划分为多个数据段，并编号Seq_num<br>  ② 编号Seq_num是该段中第一个数据字节在整个字节流的位置<br>  ③ 没开始前设置计时器，超时周期为 刚计算出得TimeOutInterval</li>
<li><strong>超时</strong><br>  重传导致超时的段，重启计时器</li>
<li><strong>之前未确认过的段被确认了</strong><br>  ① 标记它被确认了<br>  ② 设置计时器，继续传没被确认的段</li>
</ul>
</li>
<li><p>TCP 重传方案<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/f3c22bece2964deba7d6b10df47862e3.png">https://img-blog.csdnimg.cn/f3c22bece2964deba7d6b10df47862e3.png</a> &#x3D;600x)<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/4dba3bd0b4694a2f94ac6ce24bad8095.png">https://img-blog.csdnimg.cn/4dba3bd0b4694a2f94ac6ce24bad8095.png</a> &#x3D;450x)</p>
</li>
<li><p><strong>快速重传</strong><br>通过 <strong>重复的ACK</strong> 来检测报文段丢失：发送方通常连续发送大量报文段，如果报文段丢失，发送方一般会收到多个重复的ACK<br><strong>如果发送方收到同一数据的3个重复ACK，重传对方需要的数据段</strong>（第一个ACK正常，后面三个为重复ACK）<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/3d3aab1eff184a189046a73ece95abfd.png">https://img-blog.csdnimg.cn/3d3aab1eff184a189046a73ece95abfd.png</a> &#x3D;600x)</p>
</li>
</ul>
<h2 id="3-7-流量控制-flow-control"><a href="#3-7-流量控制-flow-control" class="headerlink" title="3.7 流量控制(flow control)"></a>3.7 流量控制(flow control)</h2><ul>
<li>背景：应用层从传输层socket中提取数据，然而往往数据不会提的这么快，这时候要是 sender 还一直发数据就会挤满 接收端的缓存（RcvBuffer），挤满后传输的数据就只能作废。</li>
</ul>
<hr>
<h2 id="END-练习"><a href="#END-练习" class="headerlink" title="END 练习"></a>END 练习</h2><ul>
<li><p><strong>问题：考虑一个可靠的数据传输（rdt）协议，通过一个有比特错误的信道（数据包被破坏但没有丢失）。解释检测错误并恢复的过程</strong>。</p>
<blockquote>
<p>Q：Consider a reliable data transfer (rdt) protocol over a channel with bit errors (packets are corrupted but not lost). Explain the procedure to detect and recover from errors.</p>
</blockquote>
<p>  答：① 从数据包头部解析出校验和 checksum，② 通过数据包及头部计算新的校验和，③ 如果两者不匹配，则说明包错误，④ 接收方回应NAK(rdt2.1) 或 回应带有错误编号的ACK(rdt2.2&#x2F;rdt3.0)</p>
</li>
<li><p>(往年考题) <strong>rdt2.1相关问题</strong> (书 P191 第三章习题 P6)：<br><strong>考虑我们改正协议rdt2.1的动机。试说明如图3-57所示的接收方与如 图3-11 所示的发送方运行时，接收方可能会引起发送方和接收方进人死锁状态，即双方都在等待不可能发生的事件。</strong></p>
<blockquote>
<p>P6. Consider our motivation for correcting protocol rdt2.1 . Show that the receiver, shown in<br>Figure 3.57 , when operating with the sender shown in Figure 3.11 , can lead the sender and<br>receiver to enter into a deadlock state, where each is waiting for an event that will never occur.<br>![Figure 3.11](<a href="https://img-blog.csdnimg.cn/f48e7b617d0d442dac3605e877090c57.png">https://img-blog.csdnimg.cn/f48e7b617d0d442dac3605e877090c57.png</a> &#x3D;600x)<br>![Figure 3.57](<a href="https://img-blog.csdnimg.cn/1396c7f1a8ac4937a1719666015fc363.png">https://img-blog.csdnimg.cn/1396c7f1a8ac4937a1719666015fc363.png</a> &#x3D;600x)</p>
</blockquote>
<p>  参考答案：<!-- Edge_Explorer PDF Page: Page of Recver-208; Sender-157 --></p>
</li>
</ul>
<p>假设发送方(图3-11)处于“等待来自上层的调用1”状态时，而接收方(图3-57)处于“等待来自下层的1”，<br>发送方发送1号数据包，并转换到“等待ACK或NAK 1”状态，等待ACK或NAK。<br>现在假设接收方正确地接受了1号数据包，发送了ACK，然后转换到“等待来自下层的0”状态，等待0号数据包。<br>但是，<strong>若ACK消息损坏</strong>，rdt2.1发送方接收到损坏的ACK，条件rdt_rcv(rcvpkt)&amp;&amp;(corrupt(rcvpkt)为 True，<br>发送方会执行udt_send(sndpkt)，重新发送1号数据包，而接收方在等待0号，has_seq1(rcvpkt)为 True,<br>在没接收到0号数据包时会始终返回NAK消息，而发送方处于当前状态时接收到NAK会始终发送1号数据包。<br>因此，发送方处于“等待ACK或NAK 1”状态，始终接收NAK并发送1号数据包，<br>接收方处于“等待来自下层的0”状态，始终接受1号数据包并丢弃，返回NAK，从而陷入死锁状态。</p>
<ul>
<li><p>Go-Back-N 理解练习<br><strong>Go-back-N 接收方收到了packets 1,2,3,5，下面说法正确的是：</strong><br>A) 回复 ACKs 1,2,3,5<br>B) 发送 packets 1,2,3,5 给应用层<br>C) 不应该向应用层发送包，因为缺失了部分数据(4)<br>D) 应该丢弃 packet 5 √</p>
</li>
<li><p>TCP快速重传练习<br>  <strong>TCP sender 窗格大小为5，待发送包共10个，sender发送pkt(1,2,3,4,5)。当sender收到下列情况的ACKs时会执行什么操作？<br>  ① 收到 ACK(1,2,3,4,5)<br>  ② 收到 ACK(1,3)<br>  ③ <font style="background:yellow">收到 4次 ACK1</font></strong><br>  答：① 正常发 pkt(6,7,8,9,10)；② <u>发 pkt(6,7,8)，等待pkt(4)是否超时</u>（收到ACK3说明pkt2肯定收到，发送方窗格移动到[45678]，pkt45已发，只需要发送pkt678即可）；③ <u>重发pkt(2)，正常发pkt(6)</u>（本题ACK n的序号与现实传输不同，表示对n号包的确认，而不是需要sender的pkt-n；第一次ACK1表示收到了pkt-1，pkt-2传输时丢失，后三次ACK1分别来自receiver接收到pkt-3,4,5时的反馈，因为没收到pkt-2，只能回复确认pkt-1收到了；收到ACK1，sender窗格移动到[23456]，可以正常发pkt-6）</p>
</li>
</ul>
<hr>
<ul>
<li><strong>参考资料</strong>：<ol>
<li><a href="https://juejin.cn/user/2067532033034599/posts">网络协议：传输层概述</a></li>
<li><a href=""></a></li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Computer Network</tag>
      </tags>
  </entry>
  <entry>
    <title>Dev C++注释中文乱码问题及解决方法</title>
    <url>/2022/07/29/DevC++annotation-zh-CN-garbled-code-problem-and-solution/</url>
    <content><![CDATA[<h2 id="问题：打开文件时注释的中文部分为乱码"><a href="#问题：打开文件时注释的中文部分为乱码" class="headerlink" title="问题：打开文件时注释的中文部分为乱码"></a>问题：打开文件时注释的中文部分为乱码</h2><img src="https://img-blog.csdnimg.cn/94d35cf5abd3497db97067f79fcd61c8.png" style="zoom:67%;" />

<hr>
<h2 id="原因：Dev-C-的默认字符编码为ANSI，而打开的文件的编码不是ANSI"><a href="#原因：Dev-C-的默认字符编码为ANSI，而打开的文件的编码不是ANSI" class="headerlink" title="原因：Dev C++的默认字符编码为ANSI，而打开的文件的编码不是ANSI"></a>原因：Dev C++的默认字符编码为ANSI，而打开的文件的编码不是ANSI</h2><hr>
<h2 id="解决方法1：利用记事本修改文件编码"><a href="#解决方法1：利用记事本修改文件编码" class="headerlink" title="解决方法1：利用记事本修改文件编码"></a>解决方法1：利用记事本修改文件编码</h2><ol>
<li><p><b>右键点击需要打开的文件，点击 打开方式 -&gt; 记事本</b><br>如果<u> 打开方式 里没有 记事本，要在 <strong>选择其他应用</strong> 里找</u></p>
<img src="https://img-blog.csdnimg.cn/4778ad5ec22b40109547333eadc71abc.png" style="zoom:80%;" />
</li>
<li><p><b>点击菜单栏 文件 -&gt; 另存为</b></p>
<img src="https://img-blog.csdnimg.cn/c72c2db3974a4b59a935574e2de945a4.png" style="zoom: 80%;" />
</li>
<li><p><b>将编码修改为 ANSI，点击保存，覆盖原先的文件 或 另存为一个文件</b></p>
<img src="https://img-blog.csdnimg.cn/87c35da868794fab811d08cad882aaf4.png" style="zoom:80%;" /></li>
<li><p>用DevC++打开即可</p>
</li>
</ol>
<hr>
<h2 id="解决方法2：利用Notepad-修改文件编码"><a href="#解决方法2：利用Notepad-修改文件编码" class="headerlink" title="解决方法2：利用Notepad++修改文件编码"></a>解决方法2：利用Notepad++修改文件编码</h2><p><b>（需要先安装 <font color="red">Notepad++</font>）用Notepad++打开文件，点击 菜单栏 -&gt; Encoding -&gt; “Convert to ANSI”，保存文件，再次用Dev C++打开即可</b><br><img src="https://img-blog.csdnimg.cn/e48c9c2c119e4e15a8ef6ec7d56e9697.png" style="zoom: 80%;" /></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dev C++</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络4 网络层</title>
    <url>/2022/11/16/Computer-Network-4-Network-Layer/</url>
    <content><![CDATA[<h1 id="第4章-网络层：数据层面-Network-Layer-Data-Plane"><a href="#第4章-网络层：数据层面-Network-Layer-Data-Plane" class="headerlink" title="第4章 网络层：数据层面(Network Layer: Data Plane)"></a>第4章 网络层：数据层面(Network Layer: Data Plane)</h1><h2 id="4-1-网络层概述"><a href="#4-1-网络层概述" class="headerlink" title="4.1 网络层概述"></a>4.1 网络层概述</h2><ul>
<li>网络层核心功能：<ul>
<li><strong>转发</strong>：将 分组 从路由器的输入端口 转移到 合适的输出端口</li>
<li><strong>路由</strong>：确定 分组 从源 到 目的 经过的路径</li>
</ul>
</li>
<li>网络层连接 和 传输层连接 对比：<ul>
<li><strong>网络层</strong>连接：两个主机之间（路径上的路由器等网络设备参与其中）</li>
<li><strong>传输层</strong>连接：两个应用进程之间（对中间网络设备透明）</li>
</ul>
</li>
<li>网络服务模型：<ul>
<li><strong>无连接服务</strong>：<br>  **数据包网络(datagram network)**提供无连接服务<br>  不事先为分组的传输确定传输路径，每个分组独立确定路径，不同分组可能传输路径不同</li>
<li><strong>连接服务</strong>：<br>  <strong>虚电路网络(virtual-circuit network)</strong> 提供连接服务<br>  首先为分组传输确定 从源主机到目的主机的路径(建立连接)<br>  然后 沿该路径传输 系列分组<br>  系列分组传输路径相同<br>  传输结束后拆除连接</li>
</ul>
</li>
<li>网络层的设计思路<br>① 网络层向上只提供<strong>简单</strong>灵活的，<strong>无连接的</strong>、尽最大努力交付的<strong>数据报服务</strong><br>② 网络在发送分组时不需要先建立连接<br>③ 每一个分组独立发送，与其前后的分组无关<br>④ 网络层不保证分组传送服务的质量，由主机中的传输层负责可靠的通信</li>
<li>在查找转发表时，采用<strong>最长前缀匹配</strong>原则 （与分组目的地址匹配前缀最长的输出端口）</li>
</ul>
<p><strong>路由(router)</strong></p>
<ul>
<li><strong>路由器 主要工作：转发分组</strong><br>把从某个输入端口收到的分组，按照分组要去的目的地，从当前路由器的某个合适的输出端口转发给下一跳路由器</li>
<li><strong>转发</strong> 和 <strong>路由选择</strong> 区别<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/9e3cdc668ec349d382acb1508d6a6e15.png">https://img-blog.csdnimg.cn/9e3cdc668ec349d382acb1508d6a6e15.png</a> &#x3D;450x)</li>
<li>路由器 输入端口<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/98bb98b5fdca4aad84ac9979b81e764f.png">https://img-blog.csdnimg.cn/98bb98b5fdca4aad84ac9979b81e764f.png</a> &#x3D;600x)</li>
<li>路由器 输出端口<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/2619555df2814e33b78e7f2d70a40ffd.png">https://img-blog.csdnimg.cn/2619555df2814e33b78e7f2d70a40ffd.png</a> &#x3D;600x)</li>
<li>常用的三种交换结构：<ul>
<li><strong>通过存储器</strong><br>  ![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/5f2873fd53f24e27b56c741fae89f178.png">https://img-blog.csdnimg.cn/5f2873fd53f24e27b56c741fae89f178.png</a> &#x3D;500x)</li>
<li><strong>通过总线</strong><br>  ![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/62e68003bda140618715356fede6700b.png">https://img-blog.csdnimg.cn/62e68003bda140618715356fede6700b.png</a> &#x3D;500x)</li>
<li><strong>通过互联网络 &#x2F; 纵横交换结构</strong><br>  ![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/5b4eeca4d2424886b4da1dcea85f97be.png">https://img-blog.csdnimg.cn/5b4eeca4d2424886b4da1dcea85f97be.png</a> &#x3D;500x)</li>
</ul>
</li>
<li><strong>输出端口队列</strong><br>排队时延 和 丢失 的原因：输出端口缓冲区溢出</li>
<li><strong>输入端口队列</strong><br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/2cf30112690145329fdb0381b93774cd.png">https://img-blog.csdnimg.cn/2cf30112690145329fdb0381b93774cd.png</a> &#x3D;400x)</li>
</ul>
<h2 id="4-2-IP-Internet-Protocol"><a href="#4-2-IP-Internet-Protocol" class="headerlink" title="4.2 IP: Internet Protocol"></a>4.2 IP: Internet Protocol</h2><ul>
<li>网络层功能<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/142d30ec84f04e3681d0a837a56bf423.png">https://img-blog.csdnimg.cn/142d30ec84f04e3681d0a837a56bf423.png</a> &#x3D;500x)</li>
<li><strong>与 IP 协议配套使⽤</strong>的还有三个协议<ol>
<li><strong>地址解析协议 ARP</strong> (Address Resolution Protocol)</li>
<li><strong>网际控制报⽂协议 ICMP</strong> (Internet Control Message Protocol)</li>
<li><strong>网际组管理协议 IGMP</strong> (Internet Group Management Protocol)</li>
</ol>
</li>
</ul>
<h3 id="分类-IP-地址"><a href="#分类-IP-地址" class="headerlink" title="分类 IP 地址"></a>分类 IP 地址</h3><ul>
<li>分类<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/162f173cb3dc442e8f403d22cf962760.png">https://img-blog.csdnimg.cn/162f173cb3dc442e8f403d22cf962760.png</a> &#x3D;700x)<ul>
<li>各类IP地址的 指派范围<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/69c1d9c831854612ab9a73de3df14acd.png">https://img-blog.csdnimg.cn/69c1d9c831854612ab9a73de3df14acd.png</a> &#x3D;600x)</li>
<li>一般不使用的特殊IP地址<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/3ac5eef7986f4d689c66851c8d24674a.png">https://img-blog.csdnimg.cn/3ac5eef7986f4d689c66851c8d24674a.png</a> &#x3D;500x)</li>
<li>私有 IP 地址<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/d74c9214f2c0482eb1c287a3504e3fd5.png">https://img-blog.csdnimg.cn/d74c9214f2c0482eb1c287a3504e3fd5.png</a> &#x3D;300x)</li>
<li>分类的 IP地址 的优缺点<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/d040e261b8304731aa9e50fc6f7f1159.png">https://img-blog.csdnimg.cn/d040e261b8304731aa9e50fc6f7f1159.png</a> &#x3D;300x)</li>
</ul>
</li>
</ul>
<h3 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h3><p>参考资料：<a href="https://www.cnblogs.com/ricklz/p/16519710.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91">划分子网</a></p>
<ul>
<li>为什么要划分子网<br>  ① 节省IP资源，提高IP地址利用率<br>  ② 给每一个物理网络分配一个网络号会导致路由表变大，网络性能变差<br>  ③ 减少广播的负面影响</li>
<li>划分思路：从主机号借⽤n位作为⼦⽹号 subnet-id</li>
<li>子网划分方法：<ul>
<li>定长子网：固定长度子网，所划分的所有⼦⽹的⼦⽹掩码都是相同的</li>
<li>变长子网：长度变化的子网</li>
</ul>
</li>
<li>示例<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/95c966c4dc6249d1a84183d0e28f5d78.png">https://img-blog.csdnimg.cn/95c966c4dc6249d1a84183d0e28f5d78.png</a> &#x3D;600x)<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/f2295db6738e418f916f40ce14474d01.png">https://img-blog.csdnimg.cn/f2295db6738e418f916f40ce14474d01.png</a> &#x3D;600x)</li>
<li><strong>子网掩码 (Subnet Mask &#x2F; Netmask)</strong><ul>
<li><strong>32位地址</strong>，与IP地址结合使用的技术<br>  A类地址默认的子网掩码是 <code>255.0.0.0</code><br>  B类地址默认的子网掩码是 <code>255.255.0.0</code><br>  C类地址默认的子网掩码是 <code>255.255.255.0</code></li>
<li>作用：<br>  ① 屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上，还是在远程网上<br>  ② 将一个大的IP网络划分为若干小的子网络</li>
<li>规则：<br>  将 32位的子网掩码 和 IP地址的二进制形式 进行“按位<strong>与</strong>”操作，得到的是 网络地址<br>  ![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/c2752111f2914ef3b722c1cb005b053b.png">https://img-blog.csdnimg.cn/c2752111f2914ef3b722c1cb005b053b.png</a> &#x3D;400x)</li>
<li>具体使用：<br>  ① 路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器<br>  ② 路由器的路由表中的每一个项目，要同时给出 目的网络地址 和 该网络的子网掩码<br>  ③ 一个路由器连接在两个子网上就拥有两个网络地址和两个子网掩码<br>  ④ 不同的子网掩码可能得出相同的网络地址，但其意义不同（子网的划分方式不同）</li>
</ul>
</li>
</ul>
<h3 id="无分类域间路由-CIDR"><a href="#无分类域间路由-CIDR" class="headerlink" title="无分类域间路由 CIDR"></a>无分类域间路由 CIDR</h3><ul>
<li><strong>CIDR</strong> (Classless Inter-Domain Routing)：<strong>无分类域间路由选择</strong>，消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，可以更加有效地分配 IPv4 的地址空间，但是不能解决IP地址枯竭的问题</li>
<li><strong>网络前缀</strong><ul>
<li>示例：<code>128.14.35.7/20</code>中，斜线后的20代表 IP地址的前20位是网络前缀</li>
</ul>
</li>
<li><strong>地址块</strong><ul>
<li><strong>网络前缀都相同的所有连续的 IP 地址</strong>组成一个CIDR地址块</li>
<li>示例：<code>128.14.35.7/20</code> 所在的地址块为 <code>128.14.32.0/20</code>；<br>  <code>128.14.35.7/24</code> 所在的地址块为 <code>128.14.35.0/24</code></li>
</ul>
</li>
<li><strong>地址掩码 &#x2F; 子网掩码</strong><ul>
<li>网络前缀的数值 &#x3D; 子网掩码中前面1的个数</li>
<li>示例：<code>128.14.35.7/20</code>的地址掩码为<code>255.255.240.0</code></li>
</ul>
</li>
<li>构造超网<br>每个CIDR地址块中的地址数一定是2 的整数次幂，此在文献中有时称 CIDR 编址为“构造超网”。</li>
<li>特殊的CIDR地址块<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/a6af542f3855410998791e4e7c1a5df4.png">https://img-blog.csdnimg.cn/a6af542f3855410998791e4e7c1a5df4.png</a> &#x3D;500x)</li>
<li><strong>路由聚合</strong><br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/b02f054c6d9b43c6ad3da3475c512508.png">https://img-blog.csdnimg.cn/b02f054c6d9b43c6ad3da3475c512508.png</a> &#x3D;500x)</li>
</ul>
<h3 id="IP-地址的特点"><a href="#IP-地址的特点" class="headerlink" title="IP 地址的特点"></a>IP 地址的特点</h3><ul>
<li>①  <strong>每个 IP 地址都由网络前缀和主机号两部分组成</strong><br>IP 地址是一种<strong>分等级</strong>的地址结构<br>方便了IP 地址的分配和管理<br>实现路由聚合，减小了转发表所占的存储空间，以及查找转发表的时间</li>
<li>② <strong>IP 地址是标志一台主机（或路由器）和一条链路的接口</strong><br>当<strong>一台主机同时连接到两个网络上</strong>时，该主机就必须同时<strong>具有两个相应的IP地址</strong>，<strong>其网络号必须是不同的</strong>。这种主机称为多归属主机<br>一个<strong>路由器</strong>至少应当连接到两个网络，因此至少应当有<strong>两个不同的 IP 地址</strong></li>
<li>③ <strong>转发器或交换机连接起来的若干个局域网仍为一个网络</strong><br>一个网络（或子网）是指具有<strong>相同网络前缀</strong>的主机的集合<br>转发器或交换机连接起来的若干个局域网都具有同样的网络号，它们仍为一个网络<br><strong>具有不同网络号的局域网必须使用路由器进行互连</strong></li>
<li>④ <strong>在 IP 地址中，所有分配到网络前缀的网络都是平等的</strong><br>互联网同等对待每一个IP地址，不管是范围很小的局域网，还是可能覆盖很大地理范围的广域网</li>
</ul>
<h2 id="4-3-地址解析协议-ARP"><a href="#4-3-地址解析协议-ARP" class="headerlink" title="4.3 地址解析协议 ARP"></a>4.3 地址解析协议 ARP</h2><ul>
<li><p>作用：<strong>从 IP地址 解析出 MAC地址</strong></p>
</li>
<li><p><strong>ARP 工作原理 - 同局域网</strong><br>  ![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/43b38c373b584da5969368a19b79e984.png">https://img-blog.csdnimg.cn/43b38c373b584da5969368a19b79e984.png</a> &#x3D;450x)</p>
<ul>
<li>ARP 查找IP地址对应MAC地址<br>  <strong>在本局域网中广播发送 ARP请求</strong>（路由器不转发ARP请求）<br>  <strong>ARP 请求</strong>：<code>[源MAC | 源IP | 目的MAC或0 | 目的IP]</code> （目的MAC未知时 填0）</li>
</ul>
</li>
<li><p><strong>ARP 缓存</strong><br> 存放 IP地址 到 MAC地址的 映射表，映射表动态更新 (新增或删除)</p>
<ul>
<li>作用：<br> ① 存放最近获得的 IP 地址到 MAC 地址的绑定<br> ② 减少 ARP 广播的通信量<br> ③ 为进一步减少 ARP 通信量，主机A 在发送其ARP请求分组时，就将自己的 IP 地址到 MAC 地址的映射写入ARP请求分组<br> ④ 当主机 B 收到 A 的 ARP 请求分组时，就将主机A的IP地址及其对应的 MAC 地址映射写入主机 B 自己的ARP 高速缓存中。不必在发送 ARP 请求</li>
</ul>
</li>
<li><p><strong>ARP 工作原理 - 跨局域网</strong></p>
<ul>
<li>情景：<br>  ![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/a3e6e6937d434d639b9e4d9c24322c31.png">https://img-blog.csdnimg.cn/a3e6e6937d434d639b9e4d9c24322c31.png</a> &#x3D;500x)</li>
<li>上图数据包传输流程：<br>  ① A主机 向本局域网广播发送 ARP请求，询问路由器 R<del>1</del> 的 MAC地址<br>  ② 路由器 R<del>1</del> 回复 A主机 R<del>1</del>的MAC地址<br>  ③ 主机A把 IP数据包 外层封上MAC(R<del>1</del>)，将该帧发给 路由器R<del>1</del><br>  ④ 路由器 R<del>1</del> 解包MAC帧，根据数据包的头部目的IP，向其他局域网广播发送 ARP请求，询问 B主机 的 MAC地址<br>  ⑤ B主机 回复R<del>1</del> B主机的MAC地址<br>  ⑥ 路由器R<del>1</del> 把 IP数据包 外层封上MAC(B)，将该帧发给 B主机</li>
</ul>
</li>
</ul>
<h2 id="4-4-IP-数据包格式"><a href="#4-4-IP-数据包格式" class="headerlink" title="4.4 IP 数据包格式"></a>4.4 IP 数据包格式</h2><p>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/70484f94ce7048c8afe9059b3bf5a9bd.png">https://img-blog.csdnimg.cn/70484f94ce7048c8afe9059b3bf5a9bd.png</a> &#x3D;500x)</p>
<ul>
<li>IP数据包头部结构<ul>
<li><strong>版本</strong>：4位，IP协议的版本，IPv4 对应 4</li>
<li><strong>首部长度</strong>：4位，首部长度的1表示<strong>1个单位4字节</strong>，即首部4位最大能表示的长度是15单位，<strong>首部最大60字节</strong>。</li>
<li><strong>总长度</strong>：16位，首部和数据的总长度，单位字节</li>
<li><strong>标识</strong> (<a href="https://www.cnblogs.com/lipx9527/p/14260381.html">identification</a>)：16位，通过计数器产生，可以唯一标识一个IP报文，同一IP报文的不同分片中标识相同</li>
<li><strong>标志</strong> (flag)：3位，与分片相关<br>  第1位是 MF，MF&#x3D;1 后面还有分片，MF&#x3D;0 最后一片<br>  第2位是 DF，DF&#x3D;1 不允许分片，DF&#x3D;0 允许分片</li>
<li><strong>片偏移</strong>：13位，当前分组的首单位在原数据包的位置，片偏移以8个字节为偏移单位</li>
<li>**生存时间 (TTL)**：8位，指示数据报在网络中可通过的路由器数的最大值</li>
<li><strong>协议</strong>：8位，表示数据包的数据使用什么协议（TCP &#x2F; UDP &#x2F; ICMP &#x2F; IGMP &#x2F; OSPF）</li>
<li><strong>首部校验和</strong>：16位，<strong>只检验数据包首部</strong>，不校验数据，每经过一个路由器就校验一次，错误则丢弃</li>
<li><strong>源地址 和 目的地址</strong>：32位</li>
</ul>
</li>
</ul>
<h3 id="路由转发示例"><a href="#路由转发示例" class="headerlink" title="路由转发示例"></a>路由转发示例</h3><ul>
<li>主机跨局域网转发<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/06725092f2904afbbbccda423de60dd7.png">https://img-blog.csdnimg.cn/06725092f2904afbbbccda423de60dd7.png</a> &#x3D;500x)</li>
<li>路由器转发<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/d5e6c641281c4b9d80b36d682c04a921.png">https://img-blog.csdnimg.cn/d5e6c641281c4b9d80b36d682c04a921.png</a> &#x3D;500x)</li>
</ul>
<h3 id="路由器转发算法"><a href="#路由器转发算法" class="headerlink" title="路由器转发算法"></a>路由器转发算法</h3><p>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/7568185387db478ab7680f33fc503056.png">https://img-blog.csdnimg.cn/7568185387db478ab7680f33fc503056.png</a> &#x3D;500x)</p>
<h3 id="使用二叉树查找转发表"><a href="#使用二叉树查找转发表" class="headerlink" title="使用二叉树查找转发表"></a>使用二叉树查找转发表</h3><ul>
<li><strong>二叉树构造规则</strong><br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/2e6e4377fb914bee98ca845352c6ba76.png">https://img-blog.csdnimg.cn/2e6e4377fb914bee98ca845352c6ba76.png</a> &#x3D;500x)</li>
<li><strong>二叉树使用规则</strong><br>  ① 使用目的IP的网络地址 在二叉树中匹配<ul>
<li>② if 找到一个叶节点，将目的IP与该叶结点对应的子网掩码 按位AND计算，看网络前缀是否匹配<br>  ③ 若匹配，转发分组到吓一跳路由器；否则丢弃该分组</li>
<li>② if 在二叉树中找不到匹配的叶节点，则 检查是否存在默认路由<br>  ③ 若存在则转发分组到指定默认路由器，否则丢弃分组</li>
</ul>
</li>
</ul>
<h2 id="4-5-IP分配技术"><a href="#4-5-IP分配技术" class="headerlink" title="4.5 IP分配技术"></a>4.5 IP分配技术</h2><h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>参考资料：	<a href="https://blog.csdn.net/nb_zsy/article/details/106616483">DHCP相关报文 - CSDN</a></p>
<ul>
<li>DHCP (Dynamic Host Configuration Protocol) <strong>动态主机配置协议</strong>，基于<strong>UDP</strong>工作，DHCP <strong>Server</strong> Port &#x3D; <strong>67</strong>，DHCP <strong>Client</strong> Port &#x3D; <strong>68</strong></li>
<li>作用：允许主机在加入网络时从网络服务器动态获取自己的IP地址<ul>
<li>可以续租使用的IP地址上</li>
<li>允许重用地址(只有保持地址时连接&#x2F;“on”)</li>
<li>支持移动用户谁想加入网络(更简短)</li>
</ul>
</li>
<li><strong>向DHCP申请IP地址</strong>流程：<br>  〇 Host 广播 - DHCP discover (可选操作)<br>  〇 DHCP服务器 回复 - DHCP offer (可选操作)<br>  ① Host 请求IP地址 - DHCP request<br>  ② DHCP服务器 发送地址 - DHCP ack<br>  其中 DHCP返回 IP地址，第一跳路由器IP地址，DNS服务器名和IP地址，子网掩码<br>  ![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/359db4d1884340bbb4a823f6deebbf68.png">https://img-blog.csdnimg.cn/359db4d1884340bbb4a823f6deebbf68.png</a> &#x3D;450x)</li>
<li>运行示例：<br>① 联网笔记本需要获取自己的IP地址，第一跳路由器地址和DNS服务器：采用DHCP协议<br>② 客户端 DHCP 请求被封装在UDP段中,封装在IP数据报中，封装在以太网的帧中<br>③ 以太网帧在局域网范围内广播 (dest: 255.255.255.255) ，被运行DHCP服务的路由器收<br>到<br>④ 在DHCP路由器处，以太网帧解封装成IP，IP解封装成UDP，解封装成DHCP<br>⑤ DHCP服务器生成DHCP ACK，包含客户端的IP地址，第一跳路由器的IP地址和DNS域名服务器的IP地址<br>⑥ DHCP服务器封装的报文所在的帧转发到客户端，在客户端逐层解封装成DHCP报文<br>⑦ 客户端知道它自己的IP地址，DNS服务器的名字和IP地址，第一跳路由器的IP地址</li>
</ul>
<h3 id="NAT-网络地址转换"><a href="#NAT-网络地址转换" class="headerlink" title="NAT 网络地址转换"></a>NAT 网络地址转换</h3><ul>
<li><strong>NAT (Network Address Translation)</strong> 在专用网连接到互联网的路由器上安装NAT软件，NAT路由器至少有一个有效的外部全球 IP 地址，所有使用本地地址的主机在和外界通信时，都要在NAT路由器上将其本地地址转换成全球 IP 地址，才能和互联网连接</li>
<li>图示：<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/c480fad9b3d548829a9520310a99d11a.png">https://img-blog.csdnimg.cn/c480fad9b3d548829a9520310a99d11a.png</a> &#x3D;450x)</li>
<li>NAT 特点：<ul>
<li>本地网络只有一个有效IP地址，不要从ISP分配一块地址（省钱）</li>
<li>可以在局域网改变设备地址的情况下无需通知外界</li>
<li>改变ISP分配的地址时，不需要改变内部设备地址</li>
<li>局域网内部设备没有明确的地址，对外不可见（安全）</li>
</ul>
</li>
<li><strong>NAT 转换</strong>：<ul>
<li>向外传输数据包时，替换<code>&lt;源IP地址, 端口号&gt;</code> 为 <code>&lt;NAT_IP, 新端口号&gt;</code>，目的IP地址和端口号不变</li>
<li>NAT路由器 在NAT转换表中 记录每个替换对</li>
<li>向内传输数据包时，替换<code>&lt;目的IP, 端口&gt;</code> 采用存储在NAT表中的mapping表项<code>&lt;源IP, 端口&gt;</code><br>  ![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/bd06da8182554eefb8f7f2f443aee4d5.png">https://img-blog.csdnimg.cn/bd06da8182554eefb8f7f2f443aee4d5.png</a> &#x3D;500x)</li>
</ul>
</li>
<li>NAT穿越问题<ul>
<li>问题：客户段需要连接NAT路由器下的服务器，整网对外只要有一个地址</li>
<li>方法1：静态配置NAT：转发进来的分组对服务器特定端口连接请求</li>
<li>方法2：允许NAT下的主机可以获知网络的公共IP，列举存在的端口映射，在租期内增删端口映射</li>
<li>方法3：在NAT外建立中继连接，外部客户端和NAT内部的服务器在中继处桥接</li>
</ul>
</li>
</ul>
<h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><ul>
<li><p><strong>ICMP (Internet Control Message Protocol)</strong> <strong>网际控制报文协议</strong>：允许主机或路由器<strong>报告差错</strong>情况和<strong>提供有关异常情况</strong>的报告</p>
</li>
<li><p>ICMP报文种类（2种）：<strong>差错报告报文，询问报文</strong></p>
</li>
<li><p>ICMP询问报文：<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/3f243a6bee6c4908bded3152e16ada69.png">https://img-blog.csdnimg.cn/3f243a6bee6c4908bded3152e16ada69.png</a> &#x3D;500x)</p>
</li>
<li><p>不应发送ICMP差错报文的情况<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/b930f787f1424d2a934f09b0324b4b7d.png">https://img-blog.csdnimg.cn/b930f787f1424d2a934f09b0324b4b7d.png</a> &#x3D;500x)</p>
</li>
<li><p>应用举例：</p>
<ul>
<li><strong>ping 命令</strong>：用来测试两个主机之间的连通性<br>  使用 <strong>ICMP回送请求和回送回答报文</strong><br>  <strong>应用层直接使用网络层ICMP</strong>，没有通过传输层</li>
</ul>
</li>
</ul>
<h2 id="4-6-IPv6"><a href="#4-6-IPv6" class="headerlink" title="4.6 IPv6"></a>4.6 IPv6</h2><ul>
<li>IPv6：Internet Protocol version 6，用于解决 IPv4 地址枯竭问题</li>
<li>主要变化：<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/9c6720676b0845a9b66d5bab298d0cf9.png">https://img-blog.csdnimg.cn/9c6720676b0845a9b66d5bab298d0cf9.png</a> &#x3D;400x)<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/370562b059b14291a25c19ec25204e68.png">https://img-blog.csdnimg.cn/370562b059b14291a25c19ec25204e68.png</a> &#x3D;400x)</li>
</ul>
<h3 id="IPv6数据报结构"><a href="#IPv6数据报结构" class="headerlink" title="IPv6数据报结构"></a>IPv6数据报结构</h3><ul>
<li><p><strong>基本首部</strong>：固定 40字节</p>
<ul>
<li><strong>版本</strong>：4位，IPv6对应6</li>
<li><strong>流标号</strong>：路由相同的数据报具有相同的流标号</li>
<li><strong>有效载荷长度</strong>：16位，拓展首部+数据部分的长度和，最大值为64KB</li>
<li><strong>跳数限制</strong>：8位，类似IPv4首部的TTL字段</li>
<li><strong>源地址 &#x2F; 目的地址</strong>：128位<br>  ![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/19cead9cb7dd460ba2eeeff9dd10ad4d.png">https://img-blog.csdnimg.cn/19cead9cb7dd460ba2eeeff9dd10ad4d.png</a> &#x3D;350x)</li>
</ul>
</li>
<li><p><strong>有效载荷</strong>：0-n个拓展首部 + 数据部分</p>
<ul>
<li>拓展首部类型：逐跳选项，路由选择，分片，鉴别，封装安全有效载荷，目的站选项</li>
</ul>
</li>
<li><p><strong>IPv6三种基本类型</strong></p>
<ul>
<li><strong>单播</strong>：一对一</li>
<li><strong>多播</strong>：一对多</li>
<li><strong>任播</strong>：交付目标为一组计算机中最近的一个(路由算法计算距离)</li>
</ul>
</li>
<li><p>新概念：<strong>节点、接口</strong><br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/8d1cee2611c141c7bbd986b998d6e6c2.png">https://img-blog.csdnimg.cn/8d1cee2611c141c7bbd986b998d6e6c2.png</a> &#x3D;400x)</p>
</li>
<li><p><strong>IPv6地址写法</strong>：</p>
<ul>
<li><strong>冒号十六进制 记法</strong>：16个十进制数→8个4位十六进制数<br>  ![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/25ae5ea748ab4e85b3ad82b44a50d281.png">https://img-blog.csdnimg.cn/25ae5ea748ab4e85b3ad82b44a50d281.png</a> &#x3D;400x)</li>
<li><strong>零压缩</strong>：一对冒号代表一串0，<code>0:0:0:0...</code> → <code>::</code>，一个地址只能用一次</li>
<li><strong>点分十进制记法的后缀</strong>：斜线表示法<br>  ![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/bb4c161295c448468adbd6685e4ac310.png">https://img-blog.csdnimg.cn/bb4c161295c448468adbd6685e4ac310.png</a> &#x3D;400x)</li>
</ul>
</li>
</ul>
<h3 id="IPv4-向-IPv6-过渡"><a href="#IPv4-向-IPv6-过渡" class="headerlink" title="IPv4 向 IPv6 过渡"></a>IPv4 向 IPv6 过渡</h3><ul>
<li>方法：<strong>逐步演进，向后兼容</strong>（IPv6 系统必须能够接收和转发IPv4分组，并且能够为IPv4 分组选择路由）</li>
<li>两种过渡策略：<ul>
<li><p>① <strong>双协议栈</strong><br>  ![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/4474d5e128de43d196c42a906e5f32c9.png">https://img-blog.csdnimg.cn/4474d5e128de43d196c42a906e5f32c9.png</a> &#x3D;300x)</p>
</li>
<li><p>② <strong>隧道技术</strong><br>  ![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/f7bfb6e926e54ada83e0da861c0d9e8b.png">https://img-blog.csdnimg.cn/f7bfb6e926e54ada83e0da861c0d9e8b.png</a> &#x3D;400x)</p>
</li>
</ul>
</li>
</ul>
<h3 id="ICMPv6"><a href="#ICMPv6" class="headerlink" title="ICMPv6"></a>ICMPv6</h3><p>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/2619db4566aa452dab1953b3ff3c19a2.png">https://img-blog.csdnimg.cn/2619db4566aa452dab1953b3ff3c19a2.png</a> &#x3D;500x)<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/30141f26115348cf9ae862139c72f21e.png">https://img-blog.csdnimg.cn/30141f26115348cf9ae862139c72f21e.png</a> &#x3D;480x)</p>
<h2 id="END-练习"><a href="#END-练习" class="headerlink" title="END 练习"></a>END 练习</h2><ul>
<li>[子网掩码计算练习] 已知 IP 地址是 141.14.72.24，子网掩码是255.255.192.0。试求网络地址。<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/3a5af6cf35f84deab6ecee3bac84cd26.png">https://img-blog.csdnimg.cn/3a5af6cf35f84deab6ecee3bac84cd26.png</a> &#x3D;500x)</li>
</ul>
<h1 id="第5章-网络层：控制层面-Network-Layer-Control-Plane"><a href="#第5章-网络层：控制层面-Network-Layer-Control-Plane" class="headerlink" title="第5章 网络层：控制层面(Network Layer: Control Plane)"></a>第5章 网络层：控制层面(Network Layer: Control Plane)</h1><h2 id="5-1-路由选择算法"><a href="#5-1-路由选择算法" class="headerlink" title="5.1 路由选择算法"></a>5.1 路由选择算法</h2><h3 id="LS-link-state-链路状态算法"><a href="#LS-link-state-链路状态算法" class="headerlink" title="LS: link state 链路状态算法"></a>LS: link state 链路状态算法</h3><ul>
<li>符号标记：<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/9afcbbf1a90244fb8ccdf997bd9d4851.png">https://img-blog.csdnimg.cn/9afcbbf1a90244fb8ccdf997bd9d4851.png</a> &#x3D;400x)</li>
<li>LS算法<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/2d577be58803483aa18ce9f6a7d920af.png">https://img-blog.csdnimg.cn/2d577be58803483aa18ce9f6a7d920af.png</a> &#x3D;450x)<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/5bb9b45ce2a64585a0bcdac07f2c6dae.png">https://img-blog.csdnimg.cn/5bb9b45ce2a64585a0bcdac07f2c6dae.png</a> &#x3D;500x)</li>
</ul>
<h3 id="Flooding-洪泛算法"><a href="#Flooding-洪泛算法" class="headerlink" title="Flooding 洪泛算法"></a>Flooding 洪泛算法</h3><ul>
<li>基本思想：把收到的每一个包，向除了该包到来的线路外的所有输出线路发送</li>
<li>缺点：产生大量重复包</li>
<li>解决方案：每个包头部包含计数器，每经过一站计数器减1，减至0丢弃该包<br>记录包经过的路径</li>
</ul>
<h3 id="DV-distance-vector-算法"><a href="#DV-distance-vector-算法" class="headerlink" title="DV: distance vector 算法"></a>DV: distance vector 算法</h3><ul>
<li>基本思想：与相邻路由器交换路由表，更新自己的路由表</li>
<li>示例：<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/fff070a5e3184499a9e5721ca9d2601d.png">https://img-blog.csdnimg.cn/fff070a5e3184499a9e5721ca9d2601d.png</a> &#x3D;600x)</li>
<li>保证路由表正确性的方法（6种）<ul>
<li><strong>最大度量值</strong>：针对不同协议有不同的最大度量值；当路由表中的度量值达到最大度量值时，认为路由失效，并移除这条路由。</li>
<li><strong>水平分割</strong>：一个方向发来的路由信息，不能再放入该方向的路由更新包中 并且 又发回那个方向</li>
<li><strong>路由中毒</strong>：网络中出现故障时，通知邻居节点该网段不可用</li>
<li><strong>毒性反转 &#x2F; 反向下毒</strong>：被通知该网段不可用的邻居节点也会通知原节点，自己也不能使用该网段</li>
<li><strong>保持时间</strong>：不可用信息还会再保持一定时间才会被删除</li>
<li><strong>触发更新</strong>：当路由器<strong>发现某个网段出现故障</strong>时，<strong>立刻发送路由更新包</strong>来通知邻居，而不用等到下一次发送路由更新包的时间</li>
</ul>
</li>
<li>6种方法联合应用示例：<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/5c1a9ba566484b81a200388bf9281f5a.png">https://img-blog.csdnimg.cn/5c1a9ba566484b81a200388bf9281f5a.png</a> &#x3D;500x)<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/134575accf374597bfa7c4905fc3d6f3.png">https://img-blog.csdnimg.cn/134575accf374597bfa7c4905fc3d6f3.png</a> &#x3D;500x)<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/64659be5a65e43deb1f941ce283bc5a2.png">https://img-blog.csdnimg.cn/64659be5a65e43deb1f941ce283bc5a2.png</a> &#x3D;500x)<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/5c513d2ba552445b8ee931d72b41b988.png">https://img-blog.csdnimg.cn/5c513d2ba552445b8ee931d72b41b988.png</a> &#x3D;500x)<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/805ad863cbd249ee936748604de8c3c5.png">https://img-blog.csdnimg.cn/805ad863cbd249ee936748604de8c3c5.png</a> &#x3D;500x)</li>
</ul>
<h3 id="层次路由算法"><a href="#层次路由算法" class="headerlink" title="层次路由算法"></a>层次路由算法</h3><h2 id="5-2-内部网关协议-RIP"><a href="#5-2-内部网关协议-RIP" class="headerlink" title="5.2 内部网关协议 RIP"></a>5.2 内部网关协议 RIP</h2><p>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/4e8f4167099d4bb3842fa9a1745d299a.png">https://img-blog.csdnimg.cn/4e8f4167099d4bb3842fa9a1745d299a.png</a> &#x3D;400x)</p>
<h3 id="RIP-路由信息协议"><a href="#RIP-路由信息协议" class="headerlink" title="RIP 路由信息协议"></a>RIP 路由信息协议</h3><h3 id="OSPF-开放最短路径协议"><a href="#OSPF-开放最短路径协议" class="headerlink" title="OSPF 开放最短路径协议"></a>OSPF 开放最短路径协议</h3><ul>
<li>使用<strong>Dijkstra的最短路径算法</strong>，采用<strong>分布式的LS协议</strong></li>
<li><strong>主要特点</strong>：<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/ebbbaf4a41224935892486666ca64a55.png">https://img-blog.csdnimg.cn/ebbbaf4a41224935892486666ca64a55.png</a> &#x3D;450x)</li>
<li>高级特性：<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/09ade092c74c498582c6c9458d60bc06.png">https://img-blog.csdnimg.cn/09ade092c74c498582c6c9458d60bc06.png</a> &#x3D;450x)</li>
</ul>
<h3 id="BGP-协议"><a href="#BGP-协议" class="headerlink" title="BGP 协议"></a>BGP 协议</h3><ul>
<li><strong>主要特点</strong><br><img src="https://img-blog.csdnimg.cn/cb140a091a1243189dfd0e21d0468759.png" alt="在这里插入图片描述"></li>
<li>eBSP 和 iBGP连接<br><img src="https://img-blog.csdnimg.cn/b4df4d111b0548dda179483bd43289f1.png" alt="在这里插入图片描述"></li>
</ul>
<h2 id="END-练习-1"><a href="#END-练习-1" class="headerlink" title="END 练习"></a>END 练习</h2><ul>
<li>考虑图中所示的网络。使用Dijkstra算法(LS Route)和一个类似于表5-1的表来说明你做的工作:<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/97475d2d5a214f3e96467d9df0dfe07c.png">https://img-blog.csdnimg.cn/97475d2d5a214f3e96467d9df0dfe07c.png</a> &#x3D;600x)![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/d90a63d4285646cd8766735149344bf7.png">https://img-blog.csdnimg.cn/d90a63d4285646cd8766735149344bf7.png</a> &#x3D;250x)<br>a. 计算出从 t 到所有网络节点的最短路径<br>b. 计算出从 u 到所有网络节点的最短路径<br>c. 计算出从 v 到所有网络节点的最短路径<br>d. 计算出从 w 到所有网络节点的最短路径<br>e. 计算出从 y 到所有网络节点的最短路径<br>f. 计算出从 z 到所有网络节点的最短路径</li>
</ul>
<p>答：解a，N&#x3D;tuvwxyz</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>N’</th>
<th>D(t),p(t)</th>
<th>D(u),p(u)</th>
<th>D(v),p(v)</th>
<th>D(w),p(w)</th>
<th>D(x),p(x)</th>
<th>D(y),p(y)</th>
<th>D(z),p(z)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>t</td>
<td></td>
<td>2, t</td>
<td>4, t</td>
<td>∞</td>
<td>∞</td>
<td>7, t</td>
<td>∞</td>
</tr>
<tr>
<td>2</td>
<td>tu</td>
<td></td>
<td></td>
<td>4, t</td>
<td>5, u</td>
<td>∞</td>
<td>7, t</td>
<td>∞</td>
</tr>
<tr>
<td>3</td>
<td>tuv</td>
<td></td>
<td></td>
<td></td>
<td>5, u</td>
<td>7, v</td>
<td>7, t</td>
<td>∞</td>
</tr>
<tr>
<td>4</td>
<td>tuvw</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>7, v</td>
<td>7, t</td>
<td>∞</td>
</tr>
<tr>
<td>5</td>
<td>tuvwy</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>7, v</td>
<td></td>
<td>19, y</td>
</tr>
<tr>
<td>6</td>
<td>tuvwyx</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>15, y</td>
</tr>
<tr>
<td>7</td>
<td>tuvwyxz</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/c639f8b594b04a3e8df3c515dee9301d.png">https://img-blog.csdnimg.cn/c639f8b594b04a3e8df3c515dee9301d.png</a> &#x3D;400x)</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Computer Network</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络5 链路层</title>
    <url>/2022/11/16/Computer-Network-5-Link-Layer-and-LANs/</url>
    <content><![CDATA[<h2 id="第6章-链路层和局域网-Link-Layer-and-LANs"><a href="#第6章-链路层和局域网-Link-Layer-and-LANs" class="headerlink" title="第6章 链路层和局域网(Link Layer and LANs)"></a>第6章 链路层和局域网(Link Layer and LANs)</h2><h3 id="6-2-差错检测-和-纠正"><a href="#6-2-差错检测-和-纠正" class="headerlink" title="6.2 差错检测 和 纠正"></a>6.2 差错检测 和 纠正</h3><ul>
<li>误码率 BER：在一段时间内，传输错误的比特占所传输比特总数的比率</li>
</ul>
<h4 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h4><h4 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h4><p><a href="https://blog.csdn.net/qq_37174526/article/details/88407884">检验和（checksum）</a></p>
<ul>
<li>计算步骤：将数据中所有的字的二进制加在一起，高位移出要回卷(变成低位的1)，再进行反码运算(0, 1互换)。</li>
</ul>
<h4 id="CRC-循环冗余校验"><a href="#CRC-循环冗余校验" class="headerlink" title="CRC 循环冗余校验"></a>CRC 循环冗余校验</h4><p>计算过程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">题目：收到的以太网帧为<span class="number">110101011011</span>，生成多项式为P(X)=X^<span class="number">4</span>+X^<span class="number">3</span>+<span class="number">1</span>，请检验该帧并给出检验过程。</span><br><span class="line">解答：</span><br><span class="line">根据多项式，CRC除数 = <span class="number">11001</span>，阶数 n=<span class="number">4</span></span><br><span class="line">后面 加 <span class="number">4</span>个</span><br><span class="line">			<span class="number">10010111</span> -&gt; 商</span><br><span class="line"><span class="number">11001</span> | <span class="number">110101011011</span></span><br><span class="line">		<span class="number">11001</span>  | | |</span><br><span class="line">----------<span class="number">-11101</span> | |</span><br><span class="line">		   <span class="number">11001</span> | |</span><br><span class="line">------------<span class="number">-10010</span> |</span><br><span class="line">		     <span class="number">11001</span> |</span><br><span class="line">-------------<span class="number">-10111</span>|</span><br><span class="line">		      <span class="number">11001</span>|</span><br><span class="line">--------------<span class="number">-11101</span></span><br><span class="line">		       <span class="number">11001</span></span><br><span class="line">		         <span class="number">100</span> -&gt; R</span><br><span class="line"></span><br><span class="line">经计算，余数R不为<span class="number">0</span>，说明接收到的数据是错误</span><br></pre></td></tr></table></figure>
<h3 id="6-3-多路访问协议"><a href="#6-3-多路访问协议" class="headerlink" title="6.3 多路访问协议"></a>6.3 多路访问协议</h3><ul>
<li>MAC协议的分类<ul>
<li>① 信道划分：<br>  把信道划分成片（依据时间、频率、编码）<br>  把片分配给每个节点专用</li>
<li>② 随机存取<br>  信道不划分，允许冲突，冲突后恢复</li>
<li>③ 依次轮流<br>  节点依次轮流<br>  很多数据传输节点可以获得较长的信道使用权</li>
</ul>
</li>
</ul>
<h4 id="信道划分-MAC协议"><a href="#信道划分-MAC协议" class="headerlink" title="信道划分 MAC协议"></a>信道划分 MAC协议</h4><ul>
<li><strong>TDMA 时分多路访问</strong><br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/8e7d3a3413a24d0ca701fa9f759ce100.png">https://img-blog.csdnimg.cn/8e7d3a3413a24d0ca701fa9f759ce100.png</a> &#x3D;400x)</li>
<li><strong>FDMA 频分多路访问</strong><br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/66e3e4e7a92241d994d7f49fb002a002.png">https://img-blog.csdnimg.cn/66e3e4e7a92241d994d7f49fb002a002.png</a> &#x3D;400x)</li>
<li><strong>CDMA 码分多路访问</strong><br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/e3dd5637ec9b4ed8a759dc85f1e39eec.png">https://img-blog.csdnimg.cn/e3dd5637ec9b4ed8a759dc85f1e39eec.png</a> &#x3D;400x)</li>
</ul>
<h4 id="随机存取MAC协议"><a href="#随机存取MAC协议" class="headerlink" title="随机存取MAC协议"></a>随机存取MAC协议</h4><ul>
<li><p><strong>CSMA 载波侦听多路访问</strong></p>
<ul>
<li>工作方式<br>  传输前监听信道<br>  if 信道空闲 then 传送整个帧<br>  if 信道忙 then 推迟传送帧</li>
<li>缺点<br>  冲突仍可能发生，冲突帧时间浪费</li>
</ul>
</li>
<li><p><strong>CSMA&#x2F;CD 冲突检测</strong>（&#x3D;&#x3D;重点&#x3D;&#x3D;）</p>
<ul>
<li>算法：<br>  ① 适配器获取数据包，创建帧<br>  ② 发送前 监听信道CS，忙等，闲送<br>  ③ 发送过程中，进行冲突检测(CD)，没冲突则成功，有冲突则放弃，之后尝试重发<br>  ④ 发送方检测到冲突时，还要发送一个冲突信号，所有听到冲突的信号都发，让所有站点都知道冲突 <strong>(强化冲突)</strong><br>  ⑤ 放弃发送后，适配器进入指数退避状态，择机重发（等待2^n^ * 512位时间，n为[0~失败次数]）</li>
</ul>
</li>
</ul>
<h3 id="6-4-LAN-局域网"><a href="#6-4-LAN-局域网" class="headerlink" title="6.4 LAN 局域网"></a>6.4 LAN 局域网</h3><h4 id="MAC地址-和-ARP"><a href="#MAC地址-和-ARP" class="headerlink" title="MAC地址 和 ARP"></a>MAC地址 和 ARP</h4><ul>
<li>MAC地址：48位，固化在适配器的ROM中<ul>
<li>示例： 1A-2F-BB-76-09-AD 十六进制</li>
</ul>
</li>
</ul>
<h4 id="无效的MAC帧格式"><a href="#无效的MAC帧格式" class="headerlink" title="无效的MAC帧格式"></a>无效的MAC帧格式</h4><p>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/b7d91ebbfb964f28a82f5378b3616544.png">https://img-blog.csdnimg.cn/b7d91ebbfb964f28a82f5378b3616544.png</a> &#x3D;300x)</p>
<h4 id="Ethernet-以太网"><a href="#Ethernet-以太网" class="headerlink" title="Ethernet 以太网"></a>Ethernet 以太网</h4><ul>
<li>每个节点都与中心的交换机端口相连</li>
<li>以太网使用CMDA&#x2F;CD<ul>
<li>网卡如果侦听到其他网卡在发送，则不发送（<strong>载波监听</strong>）</li>
<li>发送时，适配器侦听到其他适配器在发送就放弃对当前帧的发送（<strong>冲突检测</strong>）</li>
<li>冲突后，适配器等待随机时间，尝试重传（<strong>随机访问</strong>）</li>
</ul>
</li>
</ul>
<h4 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h4><ul>
<li><strong>交换机</strong>：能够实现将数据发送到指定的设备而不会转发到所有出口（广播）的情况<ul>
<li>定位为<strong>数据链路层设备</strong></li>
<li>存储和转发 帧、</li>
<li>对于到来的帧，检查帧头，根据目标MAC地址选择性转发</li>
<li>当帧需要发向某个网段时，需要使用CSMA&#x2F;CD进行接入控制</li>
<li>通常一个交换机端口在一个独立网段</li>
<li>交换机有MAC地址，没有IP地址</li>
<li>交换机是二层设备，即 有数据链路层和物理层，没有网络层</li>
</ul>
</li>
<li>每一台交换机内部维护一张 MAC 地址表，记录着每一个设备的 MAC 地址，连接在其哪一个端口上</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Computer Network</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习实验</title>
    <url>/2023/05/24/Experiment-on-Machine-Learning/</url>
    <content><![CDATA[<h3 id="实验1-决策树算法分析泰坦尼克号乘客存活情况"><a href="#实验1-决策树算法分析泰坦尼克号乘客存活情况" class="headerlink" title="实验1 决策树算法分析泰坦尼克号乘客存活情况"></a>实验1 决策树算法分析泰坦尼克号乘客存活情况</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">&#x27;PATH&#x27;</span>] = os.pathsep + <span class="string">r&#x27;E:\Tools\Graphviz\bin&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> pandas.core.common <span class="keyword">import</span> SettingWithCopyWarning</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> graphviz</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 数据读取</span></span><br><span class="line">data_train = pd.read_csv(<span class="string">&quot;train.csv&quot;</span>)  <span class="comment"># (891, 12)</span></span><br><span class="line">data_X_test = pd.read_csv(<span class="string">&quot;test.csv&quot;</span>)</span><br><span class="line">data_y_test = pd.read_csv(<span class="string">&quot;gender_submission.csv&quot;</span>)</span><br><span class="line">data_y_test = data_y_test.iloc[:, data_y_test.columns == <span class="string">&quot;Survived&quot;</span>]</span><br><span class="line">data_test = pd.concat([data_X_test, data_y_test], axis=<span class="number">1</span>)  <span class="comment"># 横向合并 (418, 12)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 数据清洗</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">data_clean</span>(<span class="params">data, test=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="comment"># 关闭 SettingWithCopyWarning</span></span><br><span class="line">    warnings.simplefilter(action=<span class="string">&quot;ignore&quot;</span>, category=SettingWithCopyWarning)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 删除 缺失值过多的列、观察发现与标签没有关系的列</span></span><br><span class="line">    data.drop([<span class="string">&quot;PassengerId&quot;</span>, <span class="string">&quot;Cabin&quot;</span>, <span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Ticket&quot;</span>], inplace=<span class="literal">True</span>, axis=<span class="number">1</span>)  <span class="comment"># (891, 9)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 删除 训练集中含缺失值的行</span></span><br><span class="line">    data = data.dropna()  <span class="comment"># train(712, 9), test(331, 9)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 二分类变量数值化：性别Sex</span></span><br><span class="line">    data[<span class="string">&quot;Sex&quot;</span>] = (data[<span class="string">&quot;Sex&quot;</span>] == <span class="string">&quot;male&quot;</span>).astype(<span class="string">&quot;int&quot;</span>)  <span class="comment"># male=1,female=0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 三分类变量数值化：登陆港口Embarked</span></span><br><span class="line">    labels = data[<span class="string">&quot;Embarked&quot;</span>].unique().tolist()</span><br><span class="line">    data[<span class="string">&quot;Embarked&quot;</span>] = data[<span class="string">&quot;Embarked&quot;</span>].apply(<span class="keyword">lambda</span> x: labels.index(x))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提取 特征矩阵 和 标签</span></span><br><span class="line">    data_X = data.iloc[:, data.columns != <span class="string">&quot;Survived&quot;</span>]</span><br><span class="line">    data_y = data.iloc[:, data.columns == <span class="string">&quot;Survived&quot;</span>]</span><br><span class="line">    <span class="keyword">return</span> data_X, data_y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 提取 特征矩阵 和 标签</span></span><br><span class="line">X_train, y_train = data_clean(data_train)</span><br><span class="line">X_test, y_test = data_clean(data_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修正测试集和训练集的索引</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [X_train, y_train, X_test, y_test]:</span><br><span class="line">    i.index = <span class="built_in">range</span>(i.shape[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看一部分训练集</span></span><br><span class="line"><span class="comment"># print(X_train.head(16))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 建立决策树模型</span></span><br><span class="line">clf = DecisionTreeClassifier(random_state=<span class="number">25</span>,</span><br><span class="line">                             criterion=<span class="string">&quot;entropy&quot;</span>,</span><br><span class="line">                             max_depth=<span class="number">7</span>,</span><br><span class="line">                             min_samples_leaf=<span class="number">1</span>,</span><br><span class="line">                             splitter=<span class="string">&quot;best&quot;</span>)</span><br><span class="line">clf = clf.fit(X_train, y_train)</span><br><span class="line"><span class="comment"># 模型对于给定测试数据和标签的平均预测准确度</span></span><br><span class="line">score = clf.score(X_test, y_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;模型预测得分:&quot;</span>, score)</span><br><span class="line"></span><br><span class="line">X = pd.concat([X_train, X_test], axis=<span class="number">0</span>)  <span class="comment"># 纵向合并</span></span><br><span class="line">y = pd.concat([y_train, y_test], axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 交叉验证(训练集与测试集混合抽样预测)</span></span><br><span class="line">cross_score = cross_val_score(clf, X, y, cv=<span class="number">10</span>).mean()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;交叉验证得分:&quot;</span>, cross_score)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 决策树可视化</span></span><br><span class="line">feature_name = [<span class="string">&quot;Pclass&quot;</span>, <span class="string">&quot;Sex&quot;</span>, <span class="string">&quot;Age&quot;</span>, <span class="string">&quot;Parch&quot;</span>, <span class="string">&quot;SibSp&quot;</span>, <span class="string">&quot;Fare&quot;</span>, <span class="string">&quot;Embarked&quot;</span>]</span><br><span class="line">dot_data = tree.export_graphviz(clf,</span><br><span class="line">                                feature_names=feature_name,</span><br><span class="line">                                class_names=[<span class="string">&quot;alive&quot;</span>, <span class="string">&quot;dead&quot;</span>],</span><br><span class="line">                                filled=<span class="literal">True</span>,</span><br><span class="line">                                rounded=<span class="literal">True</span>)</span><br><span class="line">graph = graphviz.Source(dot_data)</span><br><span class="line">graph.render(<span class="string">&quot;决策树分类可视化&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 参数优化</span></span><br><span class="line"><span class="comment"># gini_thresholds = np.linspace(0, 0.5, 20)  # 生成0-0.5 50个有顺序的随机数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一串参数和这些参数对应的,我们希望网格搜索 总搜索的参数的取值范围</span></span><br><span class="line"><span class="comment"># parameters = &#123;&#x27;splitter&#x27;: (&#x27;best&#x27;, &#x27;random&#x27;),</span></span><br><span class="line"><span class="comment">#               &#x27;criterion&#x27;: (&quot;gini&quot;, &quot;entropy&quot;),</span></span><br><span class="line"><span class="comment">#               &quot;max_depth&quot;: [*range(1, 25)],</span></span><br><span class="line"><span class="comment">#               &#x27;min_samples_leaf&#x27;: [*range(1, 100, 5)],</span></span><br><span class="line"><span class="comment">#               &#x27;min_impurity_decrease&#x27;: [*np.linspace(0, 0.5, 20)]&#125;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># clf = DecisionTreeClassifier(random_state=25)</span></span><br><span class="line"><span class="comment"># GS = GridSearchCV(clf, parameters, cv=10)</span></span><br><span class="line"><span class="comment"># GS.fit(X_train, y_train)</span></span><br><span class="line"><span class="comment"># print(&quot;最佳参数:\n&quot;, GS.best_params_)</span></span><br><span class="line"><span class="comment"># print(&quot;最佳得分:&quot;, GS.best_score_)</span></span><br><span class="line"><span class="comment">#  &#123;&#x27;criterion&#x27;: &#x27;entropy&#x27;, &#x27;max_depth&#x27;: 7, &#x27;min_impurity_decrease&#x27;: 0.0, &#x27;min_samples_leaf&#x27;: 1, &#x27;splitter&#x27;: &#x27;best&#x27;&#125;</span></span><br><span class="line"><span class="comment"># 最佳得分: 0.8105438184663537</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ol>
<li><a href="https://blog.csdn.net/weixin_72505469/article/details/126860358">决策树 参考代码：泰坦尼克号幸存者的预测</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/268532582">决策树可视化 - Graphviz安装及使用</a></li>
</ol>
<hr>
<h3 id="实验2-聚类算法实现图像分割"><a href="#实验2-聚类算法实现图像分割" class="headerlink" title="实验2 聚类算法实现图像分割"></a>实验2 聚类算法实现图像分割</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> PIL.Image <span class="keyword">as</span> image</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图像信息</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">readImage</span>(<span class="params">filePath</span>):</span><br><span class="line">    f = <span class="built_in">open</span>(filePath, <span class="string">&#x27;rb&#x27;</span>)  <span class="comment"># 以二进制打开文件</span></span><br><span class="line">    data = []</span><br><span class="line">    img = image.<span class="built_in">open</span>(f)  <span class="comment"># 以列表形式储存图片像素值</span></span><br><span class="line">    m, n = img.size  <span class="comment"># 获得图片大小，为便利每个像素准备</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            x, y, z = img.getpixel((i, j))</span><br><span class="line">            <span class="comment"># getpixel返回指定位置的像素，如果所打开的图像是多层次的图片，那这个方法就返回一个元组</span></span><br><span class="line">            data.append([x / <span class="number">256.0</span>, y / <span class="number">256.0</span>, z / <span class="number">256.0</span>])  <span class="comment"># 将每个像素归一化成0-1</span></span><br><span class="line">    f.close()</span><br><span class="line">    <span class="keyword">return</span> np.array(data), m, n  <span class="comment"># 返回矩阵形式的data，以及图片的大小</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择聚类算法，确定模型</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clustering</span>(<span class="params">file, kmean=<span class="literal">False</span>, gaus=<span class="literal">False</span>, mshift=<span class="literal">False</span></span>):</span><br><span class="line">    seg_filename = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> kmean == <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line">        label = KMeans(n_clusters=<span class="number">2</span>).fit_predict(imgData)</span><br><span class="line">        seg_filename = <span class="string">&quot;\KMean_&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> gaus == <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 高斯混合聚类</span></span><br><span class="line">        <span class="keyword">from</span> sklearn <span class="keyword">import</span> mixture</span><br><span class="line">        label = mixture.GaussianMixture(n_components=<span class="number">2</span>, covariance_type=<span class="string">&#x27;full&#x27;</span>).fit_predict(imgData)</span><br><span class="line">        seg_filename = <span class="string">&quot;\Gaussian_&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> mshift == <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 均值漂移</span></span><br><span class="line">        <span class="keyword">import</span> sklearn.cluster <span class="keyword">as</span> sc</span><br><span class="line">        bw = sc.estimate_bandwidth(imgData, n_samples=<span class="number">500</span>, quantile=<span class="number">0.2</span>)</span><br><span class="line">        model = sc.MeanShift(bandwidth=<span class="number">0.067</span>, bin_seeding=<span class="literal">True</span>)</span><br><span class="line">        label = model.fit_predict(imgData)</span><br><span class="line">        seg_filename = <span class="string">&quot;\MeanShift_&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span>  <span class="comment"># 异常情况</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存图像</span></span><br><span class="line">    label = label.reshape([row, col])</span><br><span class="line">    pic_new = image.new(<span class="string">&#x27;L&#x27;</span>, (row, col))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(col):</span><br><span class="line">            pic_new.putpixel((i, j), <span class="built_in">int</span>(<span class="number">255</span> * label[i][j]))  <span class="comment"># 二值化像素值0/255</span></span><br><span class="line">            <span class="comment"># 灰度图的像素值为 int(256 / (label[i][j] + 1))</span></span><br><span class="line">	</span><br><span class="line">    pic_new.save(path + <span class="string">r&#x27;\segmented_cloud&#x27;</span> + seg_filename + <span class="string">&#x27;segmented_&#x27;</span> + file, <span class="string">&#x27;JPEG&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">path = <span class="string">r&#x27;D:\机器学习实验\实验二-聚类算法分割蓝天白云&#x27;</span></span><br><span class="line">filepath = <span class="string">r&#x27;\cloud&#x27;</span></span><br><span class="line"><span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(path + filepath):</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:  <span class="comment"># 遍历文件夹下的所有图片</span></span><br><span class="line">        imgData, row, col = readImage(os.path.join(root, file))</span><br><span class="line">        clustering(file, kmean=<span class="literal">True</span>)</span><br><span class="line">        clustering(file, gaus=<span class="literal">True</span>)</span><br><span class="line">        clustering(file, mshift=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="参考文章-1"><a href="#参考文章-1" class="headerlink" title="参考文章"></a>参考文章</h4><ol>
<li><a href="https://blog.csdn.net/qq_41905413/article/details/124427692">基于聚类的图像分割 - Python实现</a></li>
<li><a href="https://blog.csdn.net/sinat_29957455/article/details/82778306">python遍历目录下的所有文件和目录</a></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>学习</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能导论实验</title>
    <url>/2023/03/15/Experiment-on-Introduction-of-AI/</url>
    <content><![CDATA[<h3 id="实验1-基于A-算法的8数码问题求解"><a href="#实验1-基于A-算法的8数码问题求解" class="headerlink" title="实验1 基于A*算法的8数码问题求解"></a>实验1 基于A*算法的8数码问题求解</h3><p>问题描述：在3*3的棋盘中有8个数码（数字块）和一个空格，只有与空格相邻的数码能移动到空格位置。从初始状态以最小的步长移动到目标状态。</p>
<p>实验要求：参考A*算法核心代码，以8数码问题为例实现A*算法的求解程序。</p>
<p>实验内容：</p>
<p>1、基于参考代码，运行程序，并画出程序的总体流程图。自动统计并输出到达目标的总步数，自动记录并输出每次移动后open表与closed表的变化。<br>要求初始状态与目标状态分别为：</p>
<p><strong>流程图</strong>：<br><img src="C:\Users\18049\AppData\Roaming\Typora\typora-user-images\image-20230315092602103.png"></p>
<p><strong>Code（Python）</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">State</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, state, directionFlag=<span class="literal">None</span>, parent=<span class="literal">None</span>, f=<span class="number">0</span></span>):</span><br><span class="line">        self.state = state</span><br><span class="line">        self.direction = [<span class="string">&#x27;up&#x27;</span>, <span class="string">&#x27;down&#x27;</span>, <span class="string">&#x27;right&#x27;</span>, <span class="string">&#x27;left&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> directionFlag:</span><br><span class="line">            self.direction.remove(directionFlag)</span><br><span class="line">        self.parent = parent</span><br><span class="line">        self.f = f</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getDirection</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.direction</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setF</span>(<span class="params">self, f</span>):</span><br><span class="line">        self.f = f</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取0点</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getZeroPos</span>(<span class="params">self</span>):</span><br><span class="line">        postion = np.where(self.state == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> postion</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 曼哈顿距离  f = g + h，g=1，如果用宽度优先的评估函数可以不调用该函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getFunctionValue</span>(<span class="params">self</span>):</span><br><span class="line">        cur_node = self.state.copy()</span><br><span class="line">        fin_node = self.answer.copy()</span><br><span class="line">        dist = <span class="number">0</span></span><br><span class="line">        N = <span class="built_in">len</span>(cur_node)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                <span class="keyword">if</span> cur_node[i][j] != fin_node[i][j]:</span><br><span class="line">                    <span class="comment"># 启发函数1: 取当前状态位置与目标状态不符的数码数目</span></span><br><span class="line">                    <span class="comment"># dist = dist + 1</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 计算距离综合(启发函数 2, 3)</span></span><br><span class="line">                    index = np.argwhere(fin_node == cur_node[i][j])</span><br><span class="line">                    x = index[<span class="number">0</span>][<span class="number">0</span>]  <span class="comment"># 最终x距离</span></span><br><span class="line">                    y = index[<span class="number">0</span>][<span class="number">1</span>]  <span class="comment"># 最终y距离</span></span><br><span class="line">                    <span class="comment"># 启发函数2: 计算距离总和，使用曼哈顿算法</span></span><br><span class="line">                    dist += (<span class="built_in">abs</span>(x - i) + <span class="built_in">abs</span>(y - j))</span><br><span class="line">                    <span class="comment"># 启发函数3: 计算距离总和，使用欧几里得算法</span></span><br><span class="line">                    <span class="comment"># dist += ((x - i) ** 2 + (y - j) ** 2) ** 0.5</span></span><br><span class="line">        <span class="keyword">return</span> dist + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextStep</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.direction:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        subStates = []</span><br><span class="line">        boarder = <span class="built_in">len</span>(self.state) - <span class="number">1</span></span><br><span class="line">        x, y = self.getZeroPos()  <span class="comment"># 获取0点位置</span></span><br><span class="line">        <span class="comment"># 向左</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;left&#x27;</span> <span class="keyword">in</span> self.direction <span class="keyword">and</span> y &gt; <span class="number">0</span>:</span><br><span class="line">            s = self.state.copy()</span><br><span class="line">            tmp = s[x, y - <span class="number">1</span>]</span><br><span class="line">            s[x, y - <span class="number">1</span>] = s[x, y]</span><br><span class="line">            s[x, y] = tmp</span><br><span class="line">            news = State(s, directionFlag=<span class="string">&#x27;right&#x27;</span>, parent=self)</span><br><span class="line">            news.setF(news.getFunctionValue())</span><br><span class="line">            subStates.append(news)</span><br><span class="line">        <span class="comment"># 向上</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;up&#x27;</span> <span class="keyword">in</span> self.direction <span class="keyword">and</span> x &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># it can move to upper place</span></span><br><span class="line">            s = self.state.copy()</span><br><span class="line">            tmp = s[x - <span class="number">1</span>, y]</span><br><span class="line">            s[x - <span class="number">1</span>, y] = s[x, y]</span><br><span class="line">            s[x, y] = tmp</span><br><span class="line">            news = State(s, directionFlag=<span class="string">&#x27;down&#x27;</span>, parent=self)</span><br><span class="line">            news.setF(news.getFunctionValue())</span><br><span class="line">            subStates.append(news)</span><br><span class="line">        <span class="comment"># 向下</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;down&#x27;</span> <span class="keyword">in</span> self.direction <span class="keyword">and</span> x &lt; boarder:</span><br><span class="line">            <span class="comment"># it can move to down place</span></span><br><span class="line">            s = self.state.copy()</span><br><span class="line">            tmp = s[x + <span class="number">1</span>, y]</span><br><span class="line">            s[x + <span class="number">1</span>, y] = s[x, y]</span><br><span class="line">            s[x, y] = tmp</span><br><span class="line">            news = State(s, directionFlag=<span class="string">&#x27;up&#x27;</span>, parent=self)</span><br><span class="line">            news.setF(news.getFunctionValue())</span><br><span class="line">            subStates.append(news)</span><br><span class="line">        <span class="comment"># 向右</span></span><br><span class="line">        <span class="keyword">if</span> self.direction.count(<span class="string">&#x27;right&#x27;</span>) <span class="keyword">and</span> y &lt; boarder:</span><br><span class="line">            <span class="comment"># it can move to right place</span></span><br><span class="line">            s = self.state.copy()</span><br><span class="line">            tmp = s[x, y + <span class="number">1</span>]</span><br><span class="line">            s[x, y + <span class="number">1</span>] = s[x, y]</span><br><span class="line">            s[x, y] = tmp</span><br><span class="line">            news = State(s, directionFlag=<span class="string">&#x27;left&#x27;</span>, parent=self)</span><br><span class="line">            news.setF(news.getFunctionValue())</span><br><span class="line">            subStates.append(news)</span><br><span class="line">        <span class="comment"># 返回F值最小的下一个点</span></span><br><span class="line">        subStates.sort(key=compareNum)</span><br><span class="line">        <span class="keyword">return</span> subStates</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 横向打印结果</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">showInfoHorizontally</span>(<span class="params">self, table, sep=<span class="string">&quot;  &quot;</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :param table: 需要显示的open|close表或者状态转移路径</span></span><br><span class="line"><span class="string">        :param sep: 显示的状态之间的间隔符号, 默认值为两个空格符</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> table:</span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> table:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(item.state)):</span><br><span class="line">                    <span class="built_in">print</span>(item.state[<span class="number">0</span>, j], end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;  &quot;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> table:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(item.state)):</span><br><span class="line">                    <span class="built_in">print</span>(item.state[<span class="number">1</span>, j], end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                <span class="built_in">print</span>(sep, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> table:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(item.state)):</span><br><span class="line">                    <span class="built_in">print</span>(item.state[<span class="number">2</span>, j], end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;  &quot;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># A* 迭代</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># openList</span></span><br><span class="line">        openTable = []</span><br><span class="line">        <span class="comment"># closeList</span></span><br><span class="line">        closeTable = []</span><br><span class="line">        openTable.append(self)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;_______初始状态______\nopenTable:&quot;</span>)</span><br><span class="line">        self.showInfoHorizontally(openTable)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;closeTable: len =&quot;</span>, <span class="built_in">len</span>(closeTable), <span class="string">&quot;\n&quot;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        self.showInfoHorizontally(closeTable)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(openTable) &gt; <span class="number">0</span>:</span><br><span class="line">            n = openTable.pop(<span class="number">0</span>)  <span class="comment"># 下一步的点移除open</span></span><br><span class="line">            closeTable.append(n)  <span class="comment"># 加入close</span></span><br><span class="line">            subStates = n.nextStep()  <span class="comment"># 确定下一步点</span></span><br><span class="line">            path = []</span><br><span class="line">            optimal_state = subStates[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> (optimal_state.state == optimal_state.answer).<span class="built_in">all</span>():</span><br><span class="line">                <span class="keyword">while</span> optimal_state.parent <span class="keyword">and</span> optimal_state.parent != originState:</span><br><span class="line">                    path.append(optimal_state.parent)  <span class="comment"># 寻找父节点,回溯路径</span></span><br><span class="line">                    optimal_state = optimal_state.parent</span><br><span class="line">                path.reverse()  <span class="comment"># 将路径链表翻转即为来时的路径</span></span><br><span class="line">                <span class="keyword">return</span> path</span><br><span class="line">            openTable = openTable + subStates  <span class="comment"># 合并原open表和拓展节点列表</span></span><br><span class="line">            openTable.sort(key=compareNum)  <span class="comment"># 重新排序</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 输出显示open表</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;--------------------\nopenTable:&quot;</span>)</span><br><span class="line">            self.showInfoHorizontally(openTable)</span><br><span class="line">            <span class="comment"># 输出显示close表</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;closeTable: len =&quot;</span>, <span class="built_in">len</span>(closeTable), <span class="string">&quot;\n&quot;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            self.showInfoHorizontally(closeTable)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compareNum</span>(<span class="params">state</span>):</span><br><span class="line">    <span class="keyword">return</span> state.f</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    originState = State(np.array([[<span class="number">2</span>, <span class="number">8</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">6</span>, <span class="number">4</span>], [<span class="number">7</span>, <span class="number">0</span>, <span class="number">5</span>]]))  <span class="comment"># 初始状态</span></span><br><span class="line">    State.answer = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">8</span>, <span class="number">0</span>, <span class="number">4</span>], [<span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>]])  <span class="comment"># 目标状态</span></span><br><span class="line">    s1 = State(state=originState.state)</span><br><span class="line">    path = s1.solve()</span><br><span class="line">    <span class="keyword">if</span> path:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n\nPath:&quot;</span>)  <span class="comment"># 显示路径</span></span><br><span class="line">        State.showInfoHorizontally(<span class="literal">None</span>, path, <span class="string">&quot;-&gt;&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(State.answer)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Total steps is %d&quot;</span> % <span class="built_in">len</span>(path))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>open表、close表、path输出截图：</strong></p>
<p>略</p>
<p>2、设计两种新的启发式函数，并运行程序。对包含示例在内的3种启发式函数的特点与结果进行对比分析。</p>
<p><strong>启发函数1</strong>：采用曼哈顿算法计算距离总和，dist +&#x3D;|x-i|+|y-j|，结果参见实验内容1。</p>
<p><strong>启发函数2</strong>：采用欧式算法计算距离总和，即dist +&#x3D;√((x-i)^2+(y-j)^2)。</p>
<p><strong>启发函数3</strong>：取当前状态位置与目标状态不符的数码数目。</p>
<p>综上，对于实验一中的初始状态和目标状态，三种启发函数路径相同，过程（每次循环的open表和close表）不完全相同。</p>
<p>另外，当初始状态为[[1, 5, 3], [2, 4, 6], [7, 0, 8]]，目标状态为[[1, 2, 3], [4, 5, 6], [7, 8, 0]]时，</p>
<p><strong>启发函数1</strong>（曼哈顿算法计算距离）：</p>
<p><strong>启发函数2</strong>（欧式算法计算距离）：循环3000多次未果，程序被手动终止。</p>
<p><strong>启发函数3</strong>（取当前状态位置与目标状态不符的数码数目）：</p>
<p><strong>特点：</strong></p>
<p>启发函数1的曼哈顿距离比较适合四方向（上下左右）网格地图。</p>
<p>启发函数2的欧式距离比较适合可以任意方向移动的地图。</p>
<p>启发函数3的取当前状态位置与目标状态不符的数码数目比较简单。</p>
<hr>
<h4 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h4><ol>
<li><a href="https://blog.csdn.net/Pericles_HAT/article/details/115516204">八数码难题(下): 启发式搜索(Python实现)</a>  有形象的图示</li>
<li><a href="https://blog.csdn.net/bob595078694/article/details/123362253">启发函数 (Heuristic Function)</a> 几种启发函数和搜索算法的理论对比</li>
<li><a href="https://blog.csdn.net/qq_63708623/article/details/129480238">python八数码问题 启发式搜索(Python实现)</a>包含三种启发函数（字符串距离、曼式距离、欧式距离）</li>
<li><a href="https://blog.csdn.net/SZU_Kwong/article/details/105897291">用两种启发函数的A*算法解决八数码问题(C++实现)</a> 两种启发函数（移位计数、欧氏距离）</li>
<li><a href="https://blog.csdn.net/Big_xbc/article/details/116206930">人工智能-八数码问题-启发式搜索(C++实现)</a> 某校实验报告？？有流程图</li>
</ol>
<hr>
<h3 id="实验2-基于遗传算法的TSP问题求解"><a href="#实验2-基于遗传算法的TSP问题求解" class="headerlink" title="实验2 基于遗传算法的TSP问题求解"></a>实验2 基于遗传算法的TSP问题求解</h3><p>问题描述：假设有一个旅行商人要拜访N个城市，他必须选择所要走的路径，路径的限制是每个城市只能拜访一次，而且最后要回到原来出发的城市。路径的选择目标是要求得的路径路程为所有路径之中的最小值。</p>
<p>实验要求：参考遗传算法核心代码，以TSP问题为例实现遗传算法的求解程序。</p>
<p>实验内容：<br>1、基于参考代码，运行程序，并画出程序的总体流程图。给出适应度函数的定义。城市数量设定为10个。</p>
<p><strong>适应性函数的定义</strong>：<br>遗传算法中，一个个体(解)的好坏用适应度函数值来评价；<br>适应度函数值越大，解的质量越高；<br>适应度函数是进行自然选择的唯一标准，设计应结合求解问题本身的要求而定。</p>
<p>2、基于某一个固定数量(10个)与位置的城市集合，修改种群数量、交叉概率、变异概率、迭代次数等参数，对比分析算法的特性与结果。</p>
<p><strong>种群数量对结果的影响：</strong>种群数越多，效果越好(随机性较大，会出现种群数小但距离更短)<br>种群数200，最小距离133  种群数500，最小距离119  种群数1000，最小距离119</p>
<p><strong>交叉率对结果的影响：</strong>交叉率不是越高越好（与变异率类似）<br>交叉率0.8，最小距离126  交叉率0.6，最小距离118  交叉率0.2，最小距离131 </p>
<p><strong>变异率对结果的影响：</strong>变异率不是越高越好<br>迭代5000次, 变异率0.8,最优122；变异率0.5,最优118；变异率0.2, 最优122</p>
<p><strong>迭代次数对结果的影响：</strong>迭代次数越多，效果越好<br>迭代1000次, 最小距离133  迭代2500次，最小距离123  迭代5000次，最小距离119</p>
<hr>
<h4 id="相关文章-1"><a href="#相关文章-1" class="headerlink" title="相关文章"></a>相关文章</h4><ol>
<li><a href="https://zhuanlan.zhihu.com/p/136393730">通俗易懂地解释遗传算法 - 知乎</a></li>
<li></li>
</ol>
<hr>
<h3 id="实验3-基于神经网络的图像分类"><a href="#实验3-基于神经网络的图像分类" class="headerlink" title="实验3 基于神经网络的图像分类"></a>实验3 基于神经网络的图像分类</h3><p>问题描述：基于特定图像数据集，研究人工神经网络分类器的设计与实现方法。</p>
<p>实验要求：基于MNIST手写数字图像数据集，完成神经网络模型的网络设计及参数选择，并在训练集上进行训练，在测试集上进行性能评估。了解Pytorch或TensorFlow等深度学习框架，基于上述算法库完成实验内容。</p>
<p>实验内容：</p>
<p>1、 训练集分组：从原始训练集中分别抽取10%，30%，50%，70%，100%的样本构成新的训练集，每个类别样本数量相同。可根据需要选择是否从新的训练集中抽取一定比例样本作为验证集。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加载数据集压缩文件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_data_gz</span>(<span class="params">data_folder</span>):</span><br><span class="line">    files = [<span class="string">&#x27;train-labels-idx1-ubyte.gz&#x27;</span>, <span class="string">&#x27;train-images-idx3-ubyte.gz&#x27;</span>,</span><br><span class="line">             <span class="string">&#x27;t10k-labels-idx1-ubyte.gz&#x27;</span>, <span class="string">&#x27;t10k-images-idx3-ubyte.gz&#x27;</span>]</span><br><span class="line">    paths = []</span><br><span class="line">    <span class="keyword">for</span> fname <span class="keyword">in</span> files:</span><br><span class="line">        paths.append(os.path.join(data_folder, fname))</span><br><span class="line">    <span class="comment"># 读取每个文件夹的数据</span></span><br><span class="line">    <span class="keyword">with</span> gzip.<span class="built_in">open</span>(paths[<span class="number">0</span>], <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> lbpath:</span><br><span class="line">        y_train = np.frombuffer(lbpath.read(), np.uint8, offset=<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">with</span> gzip.<span class="built_in">open</span>(paths[<span class="number">1</span>], <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> imgpath:</span><br><span class="line">        x_train = np.frombuffer(imgpath.read(), np.uint8, offset=<span class="number">16</span>).reshape(<span class="built_in">len</span>(y_train), <span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line">    <span class="keyword">with</span> gzip.<span class="built_in">open</span>(paths[<span class="number">2</span>], <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> lbpath:</span><br><span class="line">        y_test = np.frombuffer(lbpath.read(), np.uint8, offset=<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">with</span> gzip.<span class="built_in">open</span>(paths[<span class="number">3</span>], <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> imgpath:</span><br><span class="line">        x_test = np.frombuffer(imgpath.read(), np.uint8, offset=<span class="number">16</span>).reshape(<span class="built_in">len</span>(y_test), <span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line">    <span class="keyword">return</span> x_train, y_train, x_test, y_test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 加载数据</span></span><br><span class="line">data_folder = <span class="string">&#x27;./MNIST&#x27;</span></span><br><span class="line">x_train_src, y_train_src, x_test_src, y_test_src \</span><br><span class="line">    = load_data_gz(data_folder)  <span class="comment"># 调用load_data_gz函数加载数据集</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 抽取指定ratio比例的训练集(从原始训练集的前部开始统计数量)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">extract_train_set</span>(<span class="params">ratio</span>):</span><br><span class="line">    x_train_per, y_train_per = [], []</span><br><span class="line">    count = [<span class="number">0</span>] * <span class="number">10</span>  <span class="comment"># 统计各数字类别的图像个数</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(y_train_src)):</span><br><span class="line">        label = y_train_src[index]  <span class="comment"># 图像标签值</span></span><br><span class="line">        <span class="keyword">if</span> count[label] &gt;= <span class="built_in">int</span>(<span class="number">6000</span> * ratio):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        x_train_per.append(x_train_src[index])</span><br><span class="line">        y_train_per.append(label)</span><br><span class="line">        count[label] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x_train_per, y_train_per</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 测试集预处理</span></span><br><span class="line">x_test = tf.cast(x_test_src / <span class="number">255.0</span>, tf.float32)</span><br><span class="line">y_test = tf.cast(y_test_src, tf.int16)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">preprocess</span>(<span class="params">ratio</span>):</span><br><span class="line">    <span class="keyword">if</span> ratio == <span class="number">1</span>:  <span class="comment"># 取全部的原始训练集</span></span><br><span class="line">        x_train, y_train = x_train_src, y_train_src</span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># 根据ratio比例确定本次训练集</span></span><br><span class="line">        x_train, y_train = extract_train_set(ratio)</span><br><span class="line">    <span class="comment"># 训练集预处理</span></span><br><span class="line">    x_train = tf.cast(np.array(x_train) / <span class="number">255.0</span>, tf.float32)</span><br><span class="line">    y_train = tf.cast(np.array(y_train), tf.int16)</span><br></pre></td></tr></table></figure>

<p>2、 建立全连接神经网络模型，隐含层数量不超过2层。给出网络结构的所有参数设置情况，包括网络层数、每层神经元数量、活化函数的选择、学习率的设定、损失函数的定义等。对网络的输入进行描述，即原始特征或其他特征的表示方式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 超参数说明</span></span><br><span class="line">batch_size = <span class="number">64</span>  <span class="comment"># 批处理大小。一次训练所选取的样本数。 它的大小影响模型的优化程度和速度</span></span><br><span class="line">epochs = <span class="number">5</span>  <span class="comment"># 迭代次数。所有数据集跑的遍数(每一遍都是所有训练数据前向传播和反向传播后更新参数的过程)</span></span><br><span class="line">v_split = <span class="number">0.2</span>  <span class="comment"># 训练集中验证集的比例</span></span><br><span class="line">lr = <span class="number">0.001</span>  <span class="comment"># 学习率</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">x_train, y_train, ratio</span>):</span><br><span class="line">    <span class="comment"># 3. 建立模型</span></span><br><span class="line">    model = tf.keras.Sequential()</span><br><span class="line">    model.add(tf.keras.layers.Flatten(input_shape=(<span class="number">28</span>, <span class="number">28</span>)))  <span class="comment"># 添加Flatten数据压平层，说明输入数据的形状</span></span><br><span class="line">    model.add(tf.keras.layers.Dense(<span class="number">128</span>, activation=<span class="string">&#x27;relu&#x27;</span>))  <span class="comment"># 添加隐含层，为全连接层，128个节点，relu激活函数</span></span><br><span class="line">    model.add(tf.keras.layers.Dense(<span class="number">64</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    model.add(tf.keras.layers.Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>))  <span class="comment"># 添加输出层，为全连接层，10个节点，softmax激活函数</span></span><br><span class="line">    model.summary()  <span class="comment"># 查看网络结构和参数信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 配置模型训练方法</span></span><br><span class="line">    <span class="comment"># adam算法参数采用keras默认参数，仅手动修改学习率，损失函数采用稀疏交叉熵损失函数，准确率采用稀疏分类准确率函数</span></span><br><span class="line">    opt = tf.keras.optimizers.Adam(learning_rate=lr)</span><br><span class="line">    model.<span class="built_in">compile</span>(optimizer=opt, </span><br><span class="line">                  loss=<span class="string">&#x27;sparse_categorical_crossentropy&#x27;</span>, </span><br><span class="line">                  metrics=[<span class="string">&#x27;sparse_categorical_accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 训练模型</span></span><br><span class="line">    <span class="comment"># 批量训练大小batch_size，迭代次数epochs，验证集比例validation_split（验证集数据量=60000*v_split）</span></span><br><span class="line">    history = model.fit(x_train, y_train,</span><br><span class="line">                        batch_size=batch_size, </span><br><span class="line">                        epochs=epochs, </span><br><span class="line">                        validation_split=v_split, verbose=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5. 保存模型</span></span><br><span class="line">    model.save(<span class="string">&#x27;mnist_model_&#x27;</span> + <span class="built_in">str</span>(<span class="built_in">int</span>(ratio * <span class="number">100</span>)) + <span class="string">&#x27;per.h5&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>3、 基于每个训练集，训练模型，记录训练集的准确率，以图表等方式进行呈现。进一步，在完整的测试集上进行性能评测，结果以图表等方式进行呈现。对实验结果进行一定的描述与分析。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">plot</span>(<span class="params">ratio</span>):</span><br><span class="line">    <span class="comment"># 6. 评估模型, 参数verbose:日志打印的格式 -&gt; 0:不输出日志信息；1:显示进度条；2:每迭代一次输出一行记录</span></span><br><span class="line">    model.evaluate(x_test, y_test, verbose=<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 7. 结果可视化</span></span><br><span class="line">    loss = history.history[<span class="string">&#x27;loss&#x27;</span>]  <span class="comment"># 训练集损失</span></span><br><span class="line">    val_loss = history.history[<span class="string">&#x27;val_loss&#x27;</span>]  <span class="comment"># 测试集损失</span></span><br><span class="line">    acc = history.history[<span class="string">&#x27;sparse_categorical_accuracy&#x27;</span>]  <span class="comment"># 训练集准确率</span></span><br><span class="line">    val_acc = history.history[<span class="string">&#x27;val_sparse_categorical_accuracy&#x27;</span>]  <span class="comment"># 测试集准确率</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; 训练集损失 :&quot;</span>, loss, <span class="string">&quot;\n 测试集损失 :&quot;</span>, val_loss)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;训练集准确率:&quot;</span>, accuracy, <span class="string">&quot;\n测试集准确率:&quot;</span>, val_acc)</span><br><span class="line"></span><br><span class="line">    plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]  <span class="comment"># 初始化plt图像可识别中文</span></span><br><span class="line">    plt.figure(figsize=(<span class="number">5</span>, <span class="number">10</span>))  <span class="comment"># 创建宽5x高10的图像</span></span><br><span class="line">    plt.title(<span class="string">&#x27;训练集占原始比:&#x27;</span> + <span class="built_in">str</span>(<span class="built_in">int</span>(ratio * <span class="number">100</span>)))</span><br><span class="line">    x_ticks = np.arange(epochs)  <span class="comment"># 自定义横坐标</span></span><br><span class="line">    plt.xticks(x_ticks)  <span class="comment"># 设置横坐标</span></span><br><span class="line">    plt.xlabel(<span class="string">&#x27;迭代次数&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">211</span>)  <span class="comment"># 子图位置在2行1列的画布的位置1处</span></span><br><span class="line">    plt.plot(loss, color=<span class="string">&#x27;b&#x27;</span>, label=<span class="string">&#x27;train&#x27;</span>)</span><br><span class="line">    plt.plot(val_loss, color=<span class="string">&#x27;r&#x27;</span>, label=<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;损失&#x27;</span>)</span><br><span class="line">    plt.legend()  <span class="comment"># 创建图例</span></span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">212</span>)</span><br><span class="line">    plt.plot(acc, color=<span class="string">&#x27;b&#x27;</span>, label=<span class="string">&#x27;train&#x27;</span>)</span><br><span class="line">    plt.plot(val_acc, color=<span class="string">&#x27;r&#x27;</span>, label=<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;准确率&#x27;</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">predict</span>():</span><br><span class="line">    <span class="comment"># 8. 使用模型进行预测，并显示图像及其对应预测情况</span></span><br><span class="line">    plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">    plt.figure()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">25</span>):</span><br><span class="line">        num = np.random.randint(<span class="number">1</span>, <span class="built_in">len</span>(y_test_src))  <span class="comment"># 从测试集中随机选择一张图像</span></span><br><span class="line">        plt.subplot(<span class="number">5</span>, <span class="number">5</span>, i + <span class="number">1</span>)  <span class="comment"># 将图像放置在5*5的画布的第i+1个位置</span></span><br><span class="line">        plt.axis(<span class="string">&#x27;off&#x27;</span>)  <span class="comment"># 关闭坐标轴</span></span><br><span class="line">        plt.imshow(x_test_src[num], cmap=<span class="string">&#x27;gray&#x27;</span>)  <span class="comment"># 显示图像</span></span><br><span class="line">        temp = tf.reshape(x_test[num], (<span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>))  <span class="comment"># 增加数组维度，每次只取出一个样本</span></span><br><span class="line">        y_pred = np.argmax(model.predict(temp,verbose=<span class="number">0</span>))  <span class="comment"># 预测</span></span><br><span class="line">        plt.title(<span class="string">&#x27;标签值：&#x27;</span> + <span class="built_in">str</span>(y_test_src[num]) + <span class="string">&#x27;\n预测值：&#x27;</span> + <span class="built_in">str</span>(y_pred))</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>

<p>4、 实验总结。基于整个实验过程与结果，对实验进行总结。</p>
<p>5、 小样本分类创新实验。以10%抽样的训练集数据为训练样本，剩余的训练样本可根据需要作为无标签数据进行利用。请查阅有关课外文献，探索新的特征表示或分类模型，要求是深度神经网络类型的学习方法。包括有监督、半监督或无监督等模式均可，代表性的方法如深度卷积网络、生成式对抗网络、强化学习、Transformer、自监督学习、去噪&#x2F;变分自编码器等。在完整的测试集上进行性能的评估。本部分的撰写内容自行安排，将样本的选择、模型的构建、参数的设定、训练过程及结果进行清晰的描述与展示即可。要注重实验结果的对比，结合实验结果的分析得出模型的优点与缺点，以及可能改进的方向。</p>
<ul>
<li>5.1 去噪自编码器(DVE)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow <span class="keyword">import</span> keras</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; 构造 添加噪声的MNIST数字图像&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 数据加载</span></span><br><span class="line">(x_train, _), (x_test, _) = keras.datasets.mnist.load_data()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据预处理</span></span><br><span class="line">image_size = x_train.shape[<span class="number">1</span>]</span><br><span class="line">x_train = np.reshape(x_train, [-<span class="number">1</span>, image_size, image_size, <span class="number">1</span>])</span><br><span class="line">x_test = np.reshape(x_test, [-<span class="number">1</span>, image_size, image_size, <span class="number">1</span>])</span><br><span class="line">x_train = x_train.astype(<span class="string">&#x27;float32&#x27;</span>) / <span class="number">255.</span></span><br><span class="line">x_test = x_test.astype(<span class="string">&#x27;float32&#x27;</span>) / <span class="number">255.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 产生高斯分布的噪声(均值μ=0.5, 方差σ=0.5)</span></span><br><span class="line">noise = np.random.normal(loc=<span class="number">0.5</span>, scale=<span class="number">0.5</span>, size=x_train.shape)</span><br><span class="line">x_train_noisy = x_train + noise</span><br><span class="line">noise = np.random.normal(loc=<span class="number">0.5</span>, scale=<span class="number">0.5</span>, size=x_test.shape)</span><br><span class="line">x_test_noisy = x_test + noise</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将像素值裁剪为[0.0，1.0]范围内</span></span><br><span class="line">x_train_noisy = np.clip(x_train_noisy, <span class="number">0.0</span>, <span class="number">1.0</span>)</span><br><span class="line">x_test_noisy = np.clip(x_test_noisy, <span class="number">0.0</span>, <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; 2. 模型构建与模型训练 &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 超参数</span></span><br><span class="line">input_shape = (image_size, image_size, <span class="number">1</span>)</span><br><span class="line">batch_size = <span class="number">32</span></span><br><span class="line">kernel_size = <span class="number">3</span></span><br><span class="line">epochs = <span class="number">3</span></span><br><span class="line">latent_dim = <span class="number">16</span></span><br><span class="line">layer_filters = [<span class="number">32</span>, <span class="number">64</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编码器</span></span><br><span class="line">inputs = keras.layers.Input(shape=input_shape, name=<span class="string">&#x27;encoder_input&#x27;</span>)</span><br><span class="line">x = inputs</span><br><span class="line"><span class="keyword">for</span> filters <span class="keyword">in</span> layer_filters:</span><br><span class="line">    x = keras.layers.Conv2D(filters=filters,</span><br><span class="line">                            kernel_size=kernel_size,</span><br><span class="line">                            strides=<span class="number">2</span>,</span><br><span class="line">                            activation=<span class="string">&#x27;relu&#x27;</span>,</span><br><span class="line">                            padding=<span class="string">&#x27;same&#x27;</span>)(x)</span><br><span class="line">shape = keras.backend.int_shape(x)</span><br><span class="line"></span><br><span class="line">x = keras.layers.Flatten()(x)</span><br><span class="line">latent = keras.layers.Dense(latent_dim, name=<span class="string">&#x27;latent_vector&#x27;</span>)(x)</span><br><span class="line">encoder = keras.Model(inputs, latent, name=<span class="string">&#x27;encoder&#x27;</span>)</span><br><span class="line">encoder.summary()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解码器</span></span><br><span class="line">latent_inputs = keras.layers.Input(shape=(latent_dim,), name=<span class="string">&#x27;decoder_input&#x27;</span>)</span><br><span class="line">x = keras.layers.Dense(shape[<span class="number">1</span>] * shape[<span class="number">2</span>] * shape[<span class="number">3</span>])(latent_inputs)</span><br><span class="line">x = keras.layers.Reshape((shape[<span class="number">1</span>], shape[<span class="number">2</span>], shape[<span class="number">3</span>]))(x)</span><br><span class="line"><span class="keyword">for</span> filters <span class="keyword">in</span> layer_filters[::-<span class="number">1</span>]:</span><br><span class="line">    x = keras.layers.Conv2DTranspose(filters=filters,</span><br><span class="line">                                     kernel_size=kernel_size,</span><br><span class="line">                                     strides=<span class="number">2</span>,</span><br><span class="line">                                     padding=<span class="string">&#x27;same&#x27;</span>,</span><br><span class="line">                                     activation=<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line">outputs = keras.layers.Conv2DTranspose(filters=<span class="number">1</span>,</span><br><span class="line">                                       kernel_size=kernel_size,</span><br><span class="line">                                       padding=<span class="string">&#x27;same&#x27;</span>,</span><br><span class="line">                                       activation=<span class="string">&#x27;sigmoid&#x27;</span>,</span><br><span class="line">                                       name=<span class="string">&#x27;decoder_output&#x27;</span>)(x)</span><br><span class="line">decoder = keras.Model(latent_inputs, outputs, name=<span class="string">&#x27;decoder&#x27;</span>)</span><br><span class="line">decoder.summary()</span><br><span class="line"></span><br><span class="line">autoencoder = keras.Model(inputs, decoder(encoder(inputs)), name=<span class="string">&#x27;autoencoder&#x27;</span>)</span><br><span class="line">autoencoder.summary()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型编译与训练</span></span><br><span class="line">autoencoder.<span class="built_in">compile</span>(loss=<span class="string">&#x27;mse&#x27;</span>, optimizer=<span class="string">&#x27;adam&#x27;</span>)</span><br><span class="line">autoencoder.fit(x_train_noisy,</span><br><span class="line">                x_train, validation_data=(x_test_noisy, x_test),</span><br><span class="line">                epochs=epochs,</span><br><span class="line">                batch_size=batch_size)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型测试</span></span><br><span class="line">x_decoded = autoencoder.predict(x_test_noisy)</span><br><span class="line"><span class="comment"># 绘制图(三组,每组三行,分别为原始图像，噪声图像，去噪图像)</span></span><br><span class="line">rows, cols = <span class="number">3</span>, <span class="number">9</span></span><br><span class="line">num = rows * cols</span><br><span class="line">imgs = np.concatenate([x_test_noisy[:num], x_decoded[:num], x_test[:num]])</span><br><span class="line">imgs = imgs.reshape((rows * <span class="number">3</span>, cols, image_size, image_size))</span><br><span class="line">imgs = np.vstack(np.split(imgs, rows, axis=<span class="number">1</span>))</span><br><span class="line">imgs = imgs.reshape((rows * <span class="number">3</span>, -<span class="number">1</span>, image_size, image_size))</span><br><span class="line">imgs = np.vstack([np.hstack(i) <span class="keyword">for</span> i <span class="keyword">in</span> imgs])</span><br><span class="line">imgs = (imgs * <span class="number">255</span>).astype(np.uint8)</span><br><span class="line">plt.figure()</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">plt.imshow(imgs, interpolation=<span class="string">&#x27;none&#x27;</span>, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h4><p>典型的卷积神经网络通常由以下三种层结构共同组成：卷积层(Convolution)、下采样池化层(Pooling)、全连接层(Fully connected)</p>
<ul>
<li><strong>卷积层</strong>(Convolution)：通过卷积操作对输入图像进行降维和特征抽取<br>​        卷积运算是线性操作，而神经网络要拟合的是非线性的函数，因此和前全连接网络类似，我们需要加上激活函数，常用的有 ReLU 函数，sigmoid 函数，tanh 函数等。</li>
</ul>
<p>​        神经网络前部卷积层有小的感受视野，可以捕捉图像局部、细节信息，即输出图像的每个像素（Activation激活值）只是感受到输入图像很小范围数值进行计算的结果。<br>​        后面的卷积层感受视野逐层加大，用于捕获图像更复杂，更抽象的信息。经过多个卷积层的运算，最后得到图像在各个 不同尺度的抽象表示。<br>​        无论输入图片多大，卷积层的参数规模都是固定的</p>
<ul>
<li><p><strong>池化层</strong>(Pooling)<br>​        通过卷积操作，我们完成了对输入图像的降维和特征抽取，但特征图像的维数还是很高。维数高不仅计算耗时，而且容易导致过拟合。为此引入了下采样技术，也称为 pooling即池化操作。<br>​        池化的做法是对图像的某一个区域用一个值代替，如最大值或平均值。如果采用最大值，叫做 max 池化；如果采用均值，叫做均值池化。除了降低图像尺寸之外，下采样带来的另外一个好处是平移、旋转不变性，因为输出值由图像的一片区域计算得到，对于平移和旋转并不敏感。<br>​        总结池化层作用：(1) 降维，缩减模型大小，提高计算速度；(2) 降低过拟合概率，提升特征提取鲁棒性；(3) 对平移和旋转不敏<br>​        池化层的具体实现是在进行卷积操作之后对得到的特征图像进行分块，图像被划分成的不相交块，计算这些块内的最大值或平均值，得到池化后的图像。<br>​        均值池化和 max 池化都可以完成下采样操作，前者是线性函数，而后者是非线性函数，一般情况下 max 池化有更好的效果。<br>​        但近期一些性能优异的网络模型如ResNet和GoogLeNet等是采用全局均值池化（global average pooling，GAP）取代FC来融合学到的深度特征。</p>
</li>
<li><p><strong>全连接层</strong>(Fully connected)<br>首先说明：可以不用全连接层的。</p>
</li>
</ul>
<p>全连接层到底什么用？<br>全连接层（fully connected layers，FC）在整个卷积神经网络中起到“分类器”的作用。如果说卷积层、池化层和激活函数层等操作是将原始数据映射到隐层特征空间的话，全连接层则起到将学到的“分布式特征表示”映射到样本标记空间的作用。在实际使用中，全连接层可由卷积操作实现：对前层是全连接的全连接层可以转化为卷积核为1x1的卷积；而前层是卷积层的全连接层可以转化为卷积核为hxw的全局卷积，h和w分别为前层卷积结果的高和宽。</p>
<p>目前由于全连接层参数冗余（仅全连接层参数就可占整个网络参数80%左右），近期一些性能优异的网络模型如ResNet和GoogLeNet等均用全局平均池化（global average pooling，GAP）取代FC来融合学到的深度特征，最后仍用softmax等损失函数作为网络目标函数来指导学习过程。需要指出的是，用GAP替代FC的网络通常有较好的预测性能。</p>
<p>在FC越来越不被看好的当下，近期的研究发现，FC可在模型表示能力迁移过程中充当“防火墙”的作用。具体来讲，假设在ImageNet上预训练得到的模型为\mathcal{M} ，则ImageNet可视为源域（迁移学习中的source domain）。微调（fine tuning）是深度学习领域最常用的迁移学习技术。针对微调，若目标域（target domain）中的图像与源域中图像差异巨大（如相比ImageNet，目标域图像不是物体为中心的图像，而是风景照，见下图），不含FC的网络微调后的结果要差于含FC的网络。因此FC可视作模型表示能力的“防火墙”，特别是在源域与目标域差异较大的情况下，FC可保持较大的模型capacity从而保证模型表示能力的迁移。（冗余的参数并不一无是处。）</p>
<p>全连接就是个矩阵乘法，相当于一个特征空间变换，可以把前面所有有用的信息提取整合。再加上激活函数的非线性映射，多层全连接层理论上可以模拟任何非线性变换。但缺点也很明显: 无法保持空间结构。</p>
<p>全连接的一个作用是维度变换，尤其是可以把高维变到低维，同时把有用的信息保留下来。全连接另一个作用是隐含语义的表达(embedding)，把原始特征映射到各个隐语义节点(hidden node)。对于最后一层全连接而言，就是分类的显示表达。不同channel同一位置上的全连接等价与1x1的卷积。N个节点的全连接可近似为N个模板卷积后的均值池化(GAP)。</p>
<p>最近的论文，你会发现，FC可以用GAP（Global Average Pooling）的方法代替。后者的思想就是：用 feature map 直接表示属于某个类的 confidence map，比如有10个类，就在最后输出10个 feature map，每个feature map中的值加起来求平均值，然后把得到的这些平均值直接作为属于某个类别的 confidence value，再输入softmax中分类， 更重要的是实验效果并不比用 FC 差。</p>
<p>后者的优势是：1.因为FC的参数众多，这么做就减少了参数的数量（在最近比较火的模型压缩中，这个优势可以很好的压缩模型的大小）。2.因为减少了参数的数量，可以很好的减轻过拟合的发生。</p>
<p>另外，这种直接用 feature map 表示属于某个类的 confidence map 的做法很符合CNN的思想。</p>
<p>关于这点我的理解是这样的：比如最后要分10个类，假设在有 FC 的 network 中，FC 前面一层的feature map 用 A 表示，A 经过 FC 的作用得到了一个 10 维的向量（假设用 C 表示），然后输入softmax 等分类器中分类。既然CNN的学习能力很强，那为什么不直接让 CNN 学习输出 C（而不是 A）呢？可以看到这种思想和CNN结合的很好（FCN 也是用了类似的思想，以前的segmentation需要做很多的pre-processing&#x2F;post-processing，比如region proposal等，然后用CNN提取特征，虽然比较繁琐但效果还是很好的。于是就有人想到，既然CNN那么牛，干脆什么都让CNN做，这样就可以省去繁琐的processing了，于是就出现了 pixel-to-pixel 的 segmentation）。</p>
<p>理解1：</p>
<p>卷积取的是局部特征，全连接就是把以前的局部特征重新通过权值矩阵组装成完整的图。<br>因为用到了所有的局部特征，所以叫全连接。</p>
<p>理解2：</p>
<p>从卷积网络谈起，卷积网络在形式上有一点点像咱们正在召开的“人民代表大会制度”。卷积核的个数相当于候选人，图像中不同的特征会激活不同的“候选人”（卷积核）。</p>
<p>池化层（仅指最大池化）起着类似于“合票”的作用，不同特征在对不同的“候选人”有着各自的喜好。</p>
<p>全连接相当于是“代表普选”。所有被各个区域选出的代表，对最终结果进行“投票”，全连接保证了receiptive field 是整个图像，既图像中各个部分（所谓所有代表），都有对最终结果影响的权利。</p>
<p>理解3：</p>
<p>假设你是一只小蚂蚁，你的任务是找小面包。你的视野还比较窄，只能看到很小一片区域。当你找到一片小面包之后，你不知道你找到的是不是全部的小面包，所以你们全部的蚂蚁开了个会，把所有的小面包都拿出来分享了。全连接层就是这个蚂蚁大会~</p>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 超参数说明</span></span><br><span class="line">batch_size = <span class="number">64</span>  <span class="comment"># 批处理大小。一次训练所选取的样本数。 它的大小影响模型的优化程度和速度</span></span><br><span class="line">epochs = <span class="number">5</span>  <span class="comment"># 迭代次数。所有数据集跑的遍数(每一遍都是所有训练数据前向传播和反向传播后更新参数的过程)</span></span><br><span class="line">v_split = <span class="number">0.2</span>  <span class="comment"># 训练集中验证集的比例</span></span><br><span class="line">lr = <span class="number">0.001</span>  <span class="comment"># 学习率</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据集压缩文件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_data_gz</span>(<span class="params">data_folder</span>):</span><br><span class="line">    files = [<span class="string">&#x27;train-labels-idx1-ubyte.gz&#x27;</span>, <span class="string">&#x27;train-images-idx3-ubyte.gz&#x27;</span>,</span><br><span class="line">             <span class="string">&#x27;t10k-labels-idx1-ubyte.gz&#x27;</span>, <span class="string">&#x27;t10k-images-idx3-ubyte.gz&#x27;</span>]</span><br><span class="line">    paths = []</span><br><span class="line">    <span class="keyword">for</span> fname <span class="keyword">in</span> files:</span><br><span class="line">        paths.append(os.path.join(data_folder, fname))</span><br><span class="line">    <span class="comment"># 读取每个文件夹的数据</span></span><br><span class="line">    <span class="keyword">with</span> gzip.<span class="built_in">open</span>(paths[<span class="number">0</span>], <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> lbpath:</span><br><span class="line">        y_train = np.frombuffer(lbpath.read(), np.uint8, offset=<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">with</span> gzip.<span class="built_in">open</span>(paths[<span class="number">1</span>], <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> imgpath:</span><br><span class="line">        x_train = np.frombuffer(imgpath.read(), np.uint8, offset=<span class="number">16</span>).reshape(<span class="built_in">len</span>(y_train), <span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line">    <span class="keyword">with</span> gzip.<span class="built_in">open</span>(paths[<span class="number">2</span>], <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> lbpath:</span><br><span class="line">        y_test = np.frombuffer(lbpath.read(), np.uint8, offset=<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">with</span> gzip.<span class="built_in">open</span>(paths[<span class="number">3</span>], <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> imgpath:</span><br><span class="line">        x_test = np.frombuffer(imgpath.read(), np.uint8, offset=<span class="number">16</span>).reshape(<span class="built_in">len</span>(y_test), <span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line">    <span class="keyword">return</span> x_train, y_train, x_test, y_test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 加载数据</span></span><br><span class="line">data_folder = <span class="string">&#x27;./MNIST&#x27;</span></span><br><span class="line">x_train_src, y_train_src, x_test_src, y_test_src \</span><br><span class="line">    = load_data_gz(data_folder)  <span class="comment"># 调用load_data_gz函数加载数据集</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 抽取指定ratio比例的训练集(从原始训练集的前部开始统计数量)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">extract_train_set</span>(<span class="params">ratio</span>):</span><br><span class="line">    x_train_per, y_train_per = [], []</span><br><span class="line">    count = [<span class="number">0</span>] * <span class="number">10</span>  <span class="comment"># 统计各数字类别的图像个数</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(y_train_src)):</span><br><span class="line">        label = y_train_src[index]  <span class="comment"># 图像标签值</span></span><br><span class="line">        <span class="keyword">if</span> count[label] &gt;= <span class="built_in">int</span>(<span class="number">6000</span> * ratio):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        x_train_per.append(x_train_src[index])</span><br><span class="line">        y_train_per.append(label)</span><br><span class="line">        count[label] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x_train_per, y_train_per</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 测试集预处理</span></span><br><span class="line">x_test = tf.cast(x_test_src / <span class="number">255.0</span>, tf.float32)</span><br><span class="line">y_test = tf.cast(y_test_src, tf.int16)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">preprocess_and_train</span>(<span class="params">ratio</span>):</span><br><span class="line">    <span class="keyword">if</span> ratio == <span class="number">1</span>:  <span class="comment"># 根据ratio比例确定本次训练集</span></span><br><span class="line">        x_train, y_train = x_train_src, y_train_src</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x_train, y_train = extract_train_set(ratio)</span><br><span class="line">    <span class="comment"># 训练集预处理</span></span><br><span class="line">    x_train = tf.cast(np.array(x_train) / <span class="number">255.0</span>, tf.float32)</span><br><span class="line">    y_train = tf.cast(np.array(y_train), tf.int16)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 建立模型</span></span><br><span class="line">    <span class="keyword">global</span> model</span><br><span class="line">    model = tf.keras.Sequential()</span><br><span class="line">    model.add(tf.keras.layers.Flatten(input_shape=(<span class="number">28</span>, <span class="number">28</span>)))  <span class="comment"># 添加Flatten数据压平层，说明输入数据的形状</span></span><br><span class="line">    model.add(tf.keras.layers.Dense(<span class="number">128</span>, activation=<span class="string">&#x27;relu&#x27;</span>))  <span class="comment"># 添加隐含层，为全连接层，128个节点，relu激活函数</span></span><br><span class="line">    model.add(tf.keras.layers.Dense(<span class="number">64</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    model.add(tf.keras.layers.Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>))  <span class="comment"># 添加输出层，为全连接层，10个节点，softmax激活函数</span></span><br><span class="line">    model.summary()  <span class="comment"># 查看网络结构和参数信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 配置模型训练方法</span></span><br><span class="line">    <span class="comment"># adam算法参数采用keras默认的公开参数，损失函数采用稀疏交叉熵损失函数，准确率采用稀疏分类准确率函数</span></span><br><span class="line">    opt = tf.keras.optimizers.Adam(learning_rate=lr)</span><br><span class="line">    model.<span class="built_in">compile</span>(optimizer=opt, loss=<span class="string">&#x27;sparse_categorical_crossentropy&#x27;</span>, metrics=[<span class="string">&#x27;sparse_categorical_accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 训练模型</span></span><br><span class="line">    <span class="comment"># 批量训练大小batch_size，迭代次数epochs，验证集比例validation_split（验证集数据量=60000*v_split）</span></span><br><span class="line">    <span class="keyword">global</span> history</span><br><span class="line">    history = model.fit(x_train, y_train,</span><br><span class="line">                        batch_size=batch_size, epochs=epochs, validation_split=v_split, verbose=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5. 评估模型, 参数verbose:日志打印的格式 -&gt; 0:不输出日志信息；1:显示进度条；2:每迭代一次输出一行记录</span></span><br><span class="line">    model.evaluate(x_test, y_test, verbose=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 6. 保存模型</span></span><br><span class="line">    model.save(<span class="string">&#x27;mnist_model_&#x27;</span> + <span class="built_in">str</span>(<span class="built_in">int</span>(ratio * <span class="number">100</span>)) + <span class="string">&#x27;per.h5&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot</span>(<span class="params">ratio</span>):</span><br><span class="line">    <span class="comment"># 7. 结果可视化</span></span><br><span class="line">    loss = history.history[<span class="string">&#x27;loss&#x27;</span>]  <span class="comment"># 训练集损失</span></span><br><span class="line">    val_loss = history.history[<span class="string">&#x27;val_loss&#x27;</span>]  <span class="comment"># 测试集损失</span></span><br><span class="line">    acc = history.history[<span class="string">&#x27;sparse_categorical_accuracy&#x27;</span>]  <span class="comment"># 训练集准确率</span></span><br><span class="line">    val_acc = history.history[<span class="string">&#x27;val_sparse_categorical_accuracy&#x27;</span>]  <span class="comment"># 测试集准确率</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;  训练集损失:&quot;</span>, loss)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;  测试集损失:&quot;</span>, val_loss)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;训练集准确率:&quot;</span>, accuracy)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;测试集准确率:&quot;</span>, val_acc)</span><br><span class="line"></span><br><span class="line">    plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]  <span class="comment"># 初始化plt图像可识别中文</span></span><br><span class="line">    plt.figure(figsize=(<span class="number">5</span>, <span class="number">10</span>))  <span class="comment"># 创建宽5x高10的图像</span></span><br><span class="line">    plt.title(<span class="string">&#x27;训练集占原始比:&#x27;</span> + <span class="built_in">str</span>(<span class="built_in">int</span>(ratio * <span class="number">100</span>)))</span><br><span class="line">    x_ticks = np.arange(epochs)  <span class="comment"># 自定义横坐标</span></span><br><span class="line">    plt.xticks(x_ticks)  <span class="comment"># 设置横坐标</span></span><br><span class="line">    plt.xlabel(<span class="string">&#x27;迭代次数&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">211</span>)  <span class="comment"># 子图位置在2行1列的画布的位置1处</span></span><br><span class="line">    plt.plot(loss, color=<span class="string">&#x27;b&#x27;</span>, label=<span class="string">&#x27;train&#x27;</span>)</span><br><span class="line">    plt.plot(val_loss, color=<span class="string">&#x27;r&#x27;</span>, label=<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;损失&#x27;</span>)</span><br><span class="line">    plt.legend()  <span class="comment"># 创建图例</span></span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">212</span>)</span><br><span class="line">    plt.plot(acc, color=<span class="string">&#x27;b&#x27;</span>, label=<span class="string">&#x27;train&#x27;</span>)</span><br><span class="line">    plt.plot(val_acc, color=<span class="string">&#x27;r&#x27;</span>, label=<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;准确率&#x27;</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">predict</span>():</span><br><span class="line">    <span class="comment"># 8. 使用模型进行预测，并显示图像及其对应预测情况</span></span><br><span class="line">    <span class="comment"># path = &#x27;mnist_model_&#x27; + str(int(ratio * 100)) + &#x27;per.h5&#x27;  # 需要ratio参数</span></span><br><span class="line">    <span class="comment"># model = tf.keras.models.load_model(path)  # 加载本地模型</span></span><br><span class="line">    plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">    plt.figure()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">25</span>):</span><br><span class="line">        num = np.random.randint(<span class="number">1</span>, <span class="built_in">len</span>(y_test_src))  <span class="comment"># 从测试集中随机选择一张图像</span></span><br><span class="line">        plt.subplot(<span class="number">5</span>, <span class="number">5</span>, i + <span class="number">1</span>)  <span class="comment"># 将图像放置在5*5的画布的第i+1个位置</span></span><br><span class="line">        plt.axis(<span class="string">&#x27;off&#x27;</span>)  <span class="comment"># 关闭坐标轴</span></span><br><span class="line">        plt.imshow(x_test_src[num], cmap=<span class="string">&#x27;gray&#x27;</span>)  <span class="comment"># 显示图像</span></span><br><span class="line">        temp = tf.reshape(x_test[num], (<span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>))  <span class="comment"># 增加数组维度，每次只取出一个样本</span></span><br><span class="line">        y_pred = np.argmax(model.predict(temp,verbose=<span class="number">0</span>))  <span class="comment"># 预测</span></span><br><span class="line">        plt.title(<span class="string">&#x27;标签值：&#x27;</span> + <span class="built_in">str</span>(y_test_src[num]) + <span class="string">&#x27;\n预测值：&#x27;</span> + <span class="built_in">str</span>(y_pred))</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">train_set_ratio</span>):</span><br><span class="line">    preprocess_and_train(train_set_ratio)</span><br><span class="line">    plot(train_set_ratio)</span><br><span class="line">    predict()</span><br><span class="line">    <span class="keyword">return</span> (history.history[<span class="string">&#x27;val_sparse_categorical_accuracy&#x27;</span>])[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_accuracy</span>():</span><br><span class="line">    ratio_arr = [<span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1</span>]</span><br><span class="line">    accu_arr = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ratio_arr)):</span><br><span class="line">        accu_arr.append(main(ratio_arr[i]))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;取原始训练集&quot;</span> + <span class="built_in">str</span>(<span class="built_in">int</span>(ratio_arr[i] * <span class="number">100</span>)) + <span class="string">&quot;%进行训练，在测试集的准确率为: &quot;</span>, accu_arr[i], <span class="string">&quot;\n\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    print_accuracy()</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ol>
<li><a href="https://blog.csdn.net/zfjBIT/article/details/88075569">CNN卷积层、池化层、全连接层 简述</a></li>
<li><a href="https://blog.csdn.net/rdd1117/article/details/82883522">卷积神经网络的训练过程</a></li>
<li><a href="https://www.cnblogs.com/skyfsm/p/6790245.html">卷积神经网络CNN的层级结构-博客园</a></li>
<li><a href="https://blog.csdn.net/LOVEmy134611/article/details/118991354">去噪自编码器(Denoising Autoencoder)的TensorFlow实现</a></li>
<li><a href="https://blog.csdn.net/weixin_45288820/article/details/104479682">变分自编码器(VAE)的TensorFlow实现</a></li>
<li><a href="https://blog.csdn.net/weixin_45954454/article/details/114455209">使用MNIST数据集训练手写数字识别模型附完整训练代码-路遥博客</a></li>
<li><a href="https://blog.csdn.net/qq_51235856/article/details/130043631">基于TensorFlow分析MNIST数据集-THE WHY的CSDN博客（一个同学写的博客?）</a></li>
<li><a href="https://blog.csdn.net/m0_56942491/article/details/129999988">Pytorch搭建卷积神经网络实现MNIST手写数字识别-LotusCL博客（注释很详细的同学博客）</a></li>
<li><a href="https://blog.csdn.net/qq_44009891/article/details/111185000">TensorFlow 初步实现 CNN 卷积神经网络</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/100419971">如何确定神经网络的层数和隐藏层神经元数量 - 知乎</a></li>
<li><a href="https://blog.csdn.net/weixin_51128278/article/details/125377203">机器学习深度神经网络实验报告</a></li>
<li><a href="https://www.jianshu.com/p/a95af284012d">keras建立多层神经网络</a></li>
<li><a href="https://www.cnblogs.com/moonspace/p/13005435.html">TensorFlow2.1入门学习笔记(10)——使用keras搭建神经网络(Mnist,Fashion) </a></li>
</ol>
<hr>
<p><strong>遇到的问题及解决方案</strong></p>
<ol>
<li><a href="https://blog.csdn.net/qq_33343450/article/details/120646268">pytorch训练模型遇到问题：ValueError: Sum of input lengths does not equal the length of the input dataset!</a></li>
<li><a href="https://blog.csdn.net/wuyanne/article/details/115033677">已解决-No module named ‘tensorflow.examples‘_</a></li>
<li><a href="https://blog.csdn.net/sinat_26811377/article/details/100774586">Python 报错 AttributeError: module ‘tensorflow‘ has no attribute ‘placeholder‘_</a></li>
</ol>
<hr>
<p><strong>相关文章</strong></p>
<ol>
<li><a href="https://blog.csdn.net/QLeelq/article/details/121069095">pytorch学习实战4：MNIST数据集的读取、显示以及全连接实现数字识别</a></li>
<li><a href="https://blog.csdn.net/chd_lcj/article/details/114382666">mnist数据集预处理：根据数据种类和带标签信息的name，实现文件按label分类存放到子文件夹</a></li>
<li><a href="https://blog.csdn.net/myCSDN3657/article/details/113097408">MNIST数据集转为图片形式输出（按标签分别存储，统一存储）</a></li>
<li><a href="https://blog.csdn.net/qq_40367479/article/details/82530324">深度学习—学习率衰减(learning rate decay)_</a></li>
<li><a href="https://blog.csdn.net/program_developer/article/details/80853425">深度学习中Flatten层的作用</a></li>
<li><a href="https://www.cnblogs.com/Anita9002/p/9296014.html">深度学习基础（CNN详解以及训练过程1）- 博客园</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/392854482">神经网络入门及改进优化-CNN识别 Fashion-MNIST 数据集</a></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>学习</category>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>A-Star</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理实验</title>
    <url>/2022/01/07/Experiment-on-Principles-of-Computer-Composition/</url>
    <content><![CDATA[<h3 id="实验一-静态随机存储器实验"><a href="#实验一-静态随机存储器实验" class="headerlink" title="实验一 静态随机存储器实验"></a>实验一 静态随机存储器实验</h3><h4 id="1-1-实验目的及内容"><a href="#1-1-实验目的及内容" class="headerlink" title="1.1 实验目的及内容"></a>1.1 实验目的及内容</h4><p><strong>实验目的</strong>：掌握静态随机存储器RAM工作特性及数据的读写方法</p>
<p><strong>仪器设备</strong>：PC机一台，TD-CMA实验系统一套</p>
<p><strong>实验内容</strong>：</p>
<img src="https://s1.ax1x.com/2023/03/17/ppGSz8A.jpg" style="zoom:25%;" />

<h4 id="1-2-实验步骤"><a href="#1-2-实验步骤" class="headerlink" title="1.2 实验步骤"></a>1.2 实验步骤</h4><blockquote>
<p>(1) 关闭实验系统电源，连接实验电路，并检查无误<br>(2) 将时序与操作台单元的开关KK1，KK3置为运行档，开关KK2置为”单步”档，开关KK4置为”主存”档<br>(3) 将CON单元的IOR开关置1，打开电源开关（如果听到“嘀”的报警声，应立即关闭电源，重新检查接线直到错误排除）<br>(4) 给存储器的00H,01H,02H,03H,04H地址单元中分别写入数据11H,12H,13H,14H,15H。<br>(5) 依次读出第00,01,02,03,04号单元中的内容，观察上述单元中内容是否与前面输入的一致</p>
</blockquote>
<p>上述 (4) 具体操作：</p>
<blockquote>
<p>① 写地址：在IN单元处输入地址，IOR置“0”，LDAR置“1”，按一下“ST”，将地址传至地址总线处，LDAR置“0”恢复至初态<br>② 写数据：IOR置“1”，在IN单元处输入数据，后IOR置“0”<br>WR置“1”，按下“ST”，写入数据，WR置“0”，IOR置“1”释放总线<br>重复上述步骤，依次在5个地质单元中写入对应数据即可。</p>
</blockquote>
<p>上述 (5) 具体操作：</p>
<blockquote>
<p>① 写地址：IOR置“1”，在IN单元处输入待读取的地址，IOR置“0”，LDAR置“1”，按下“ST”，然后LDAR置“0”恢复初态，IOR置“1”<br>② 读数据：RD置“1”（此时IOR应为“1”，LDAR置”0“）观察总线显示数，观察后RD置“0”释放总线</p>
</blockquote>
<h4 id="1-3-实验结果分析"><a href="#1-3-实验结果分析" class="headerlink" title="1.3 实验结果分析"></a>1.3 实验结果分析</h4><p>实验结果：</p>
<blockquote>
<p>在存储器的00H,01H,02H,03H,04H地址单元中分别读取出的数据为11H,12H,13H,14H,15H。</p>
</blockquote>
<p>结果分析：</p>
<blockquote>
<p>以01H地址单元写入数据12H并读出的过程为例<br>(1) 首先地址和数据是由同一个数据开关给出的（实验箱IN单元）因此地址和数据要分别写入。先关掉存储器的读写，数据开关给出地址01H，将地址01H打入AR中，再关闭地址寄存器，数据开关给出数据12H，打开输入三态门(写状态)，即把12H传至存储器。<br>读数据也应该先给出地址，在进行读操作，地址01H的写入方式相同，关闭IN单元输出，使存储器处于读状态，此时CPU总线上显示12H。<br>(2) 存储器存储数据原理：<br>存储器中最小单元为一个双稳态半导体电路或CMOS晶体管，磁性材料的存储单元，它可以存储一个二进制数序列，若干存储元构成一个存储单元，若干存储单元构成存储器，可用于存放数据。</p>
</blockquote>
<h4 id="1-4-思考题"><a href="#1-4-思考题" class="headerlink" title="1.4 思考题"></a>1.4 思考题</h4><ul>
<li>思考题1：存储器实验各个控制信号的初始状态如何设置？<br><strong>IOR 置 “1”，其他控制信号置 “0”</strong></li>
<li>思考题2：所有的写操作要配合脉冲（边沿触发），为什么？<br><strong>为了防止误操作</strong></li>
</ul>
<h3 id="实验三-基本运算器实验"><a href="#实验三-基本运算器实验" class="headerlink" title="实验三 基本运算器实验"></a>实验三 基本运算器实验</h3><h4 id="3-1-实验目的及内容"><a href="#3-1-实验目的及内容" class="headerlink" title="3.1 实验目的及内容"></a>3.1 实验目的及内容</h4><img src="https://s1.ax1x.com/2023/03/17/ppGpSgI.jpg" style="zoom:25%;" />

<h4 id="3-2-实验步骤"><a href="#3-2-实验步骤" class="headerlink" title="3.2 实验步骤"></a>3.2 实验步骤</h4><blockquote>
<p>（1）关闭电源开关，连接实验电路，并检查无误<br>（2）将时序与操作台单元的开关KK2 置为“单步”档，开关KK1, KK3置为“运行”档<br>（3）打开电源开关，按动 CON单元 的 CLR按钮，将运算器的 A,B,FC,FZ 清零<br>（4）用输入开关向暂存器A 置数<br>（5）用输入开关向暂存器B 置数<br>（6）改变运算器的功能设置，观察运算器的输出</p>
</blockquote>
<h4 id="3-3-实验结果分析"><a href="#3-3-实验结果分析" class="headerlink" title="3.3 实验结果分析"></a>3.3 实验结果分析</h4><blockquote>
<p>（1）运算器能实现二进制算术和移位，逻辑运算<br>设置运算器的控制信号S_3, S_2, S_1, S_0, C_n 来选择运算器的不同功能<br>（2）数据的输入，输出以及 FC、FZ 标志状态要通过 LED观察灯 观察时<br>都需要按下脉冲单元的 ST按钮<br>（3）数据进入哪一寄存器就必须开启哪一个寄存器<br>如数据只进入暂存器A，必须设置LDA &#x3D; 1， LDB &#x3D; 0且获得脉冲信号</p>
</blockquote>
<h4 id="3-4-思考题"><a href="#3-4-思考题" class="headerlink" title="3.4 思考题"></a>3.4 思考题</h4><ul>
<li>思考题3：采用单步模式时，实验箱是如何产生时序信号的？例如要产生T3需要按几次ST?<br><strong>按ST产生时序信号；单步模式下要产生T3需要按1次ST</strong></li>
<li>思考题4：运算器实验中的FZ代表什么含义？FZ什么时候取值为1？<br><strong>FZ为零标志位（Flag Zero），表示运算是否为0，当运算结果为0时，FZ为1</strong></li>
</ul>
<h3 id="Acknowledgement"><a href="#Acknowledgement" class="headerlink" title="Acknowledgement"></a>Acknowledgement</h3><blockquote>
<p>感谢一只路过的喵喵提供了相关照片、思考题的参考答案以及改正建议</p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>学习</category>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title>前端工具(框架)</title>
    <url>/2023/03/07/Front-end-tools/</url>
    <content><![CDATA[<p><a href="https://element.eleme.cn/#/zh-CN">Element - 网站快速成型工具</a></p>
<p><a href="http://www.quasarchs.com/">Quasar Framework</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/142346630">UI框架 Quasar Framework 简评 - 知乎</a></p>
<hr>
<h3 id="html操作"><a href="#html操作" class="headerlink" title="html操作"></a>html操作</h3><p><a href="https://www.php.cn/div-tutorial-410402.html">html字体颜色设置的三种方法(font标签, 内置css-style, 引入外部css)</a></p>
<h3 id="CSS操作"><a href="#CSS操作" class="headerlink" title="CSS操作"></a>CSS操作</h3><p><a href="https://tool.lu/css/">CSS在线工具(格式化, 去注释, 整理, 压缩)</a></p>
<p><a href="https://blog.csdn.net/mygoes/article/details/116238484">VSCode插件实现 CSS自动梳理</a></p>
<h3 id="调色"><a href="#调色" class="headerlink" title="调色"></a>调色</h3><p><a href="https://www.sojson.com/web/online.html">在线调色板</a></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>front-end</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub入门</title>
    <url>/2023/03/07/GitHub-Introduction/</url>
    <content><![CDATA[<p><a href="https://bbs.huaweicloud.com/blogs/336763">开发中时常提到的提交pr的意思: pull request</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>Github</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>华为机考真题</title>
    <url>/2023/03/23/Huawei-Computer-Test/</url>
    <content><![CDATA[<h3 id="栈数据合并-2023-5-10"><a href="#栈数据合并-2023-5-10" class="headerlink" title="栈数据合并(2023.5.10)"></a>栈数据合并(2023.5.10)</h3><h3 id="破译密码-2023-5-10"><a href="#破译密码-2023-5-10" class="headerlink" title="破译密码(2023.5.10)"></a>破译密码(2023.5.10)</h3><h3 id="通信染色最短用时-2023-5-10"><a href="#通信染色最短用时-2023-5-10" class="headerlink" title="通信染色最短用时(2023.5.10)"></a>通信染色最短用时(2023.5.10)</h3><hr>
<h3 id="查找众数和中位数"><a href="#查找众数和中位数" class="headerlink" title="查找众数和中位数"></a>查找众数和中位数</h3><ol>
<li>题目描述:<br> (1)众数是指一组数据中出现次数量多的那个数，众数可以是多个。<br> (2)中位数是指把一组数据从小到大排列，最中间的那个数，<br> 如果这组数据的个数是奇数，那最中间那个就是中位数，<br> 如果这组数据的个数为偶数，那就把中间的两个数之和除以2，所得的结果就是中位数。<br> (3)查找整型数组中元素的众数并组成一个新的数组，求新数组的中位数。</li>
<li>输入描述:<br> 输入一个一维整型数组，数组大小取值范围 0&lt;N&lt;1000，数组中每个元素取值范围 0&lt;E&lt;1000</li>
<li>输出描述:<br> 输出众数组成的新数组的中位数</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1. 题目描述:</span></span><br><span class="line"><span class="string">(1)众数是指一组数据中出现次数量多的那个数，众数可以是多个。</span></span><br><span class="line"><span class="string">(2)中位数是指把一组数据从小到大排列，最中间的那个数，</span></span><br><span class="line"><span class="string">如果这组数据的个数是奇数，那最中间那个就是中位数，</span></span><br><span class="line"><span class="string">如果这组数据的个数为偶数，那就把中间的两个数之和除以2，所得的结果就是中位数。</span></span><br><span class="line"><span class="string">(3)查找整型数组中元素的众数并组成一个新的数组，求新数组的中位数。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2. 输入描述:</span></span><br><span class="line"><span class="string">输入一个一维整型数组，数组大小取值范围 0&lt;N&lt;1000，数组中每个元素取值范围 0&lt;E&lt;1000</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3. 输出描述:</span></span><br><span class="line"><span class="string">输出众数组成的新数组的中位数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 输入</span></span><br><span class="line">N = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">arr = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, (<span class="built_in">input</span>()).split()))</span><br><span class="line"><span class="comment"># N = 16  # 自测用输入</span></span><br><span class="line"><span class="comment"># arr = [4, 1, 5, 2, 3, 3, 9, 2, 7, 4, 6, 2, 15, 4, 2, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计</span></span><br><span class="line">mp = <span class="built_in">dict</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">    <span class="keyword">if</span> arr[i] <span class="keyword">in</span> mp:</span><br><span class="line">        mp[arr[i]] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mp[arr[i]] = <span class="number">1</span></span><br><span class="line"><span class="comment"># for item in arr:  # 哈希表初始化 另一种写法</span></span><br><span class="line"><span class="comment">#     mp[item] = mp.setdefault(item, 0) + 1</span></span><br><span class="line"></span><br><span class="line">zhongshu = []  <span class="comment"># 众数列表</span></span><br><span class="line">max_num = <span class="built_in">max</span>(mp.values())  <span class="comment"># 最大频次</span></span><br><span class="line"><span class="keyword">for</span> key, num <span class="keyword">in</span> mp.items():</span><br><span class="line">    <span class="keyword">if</span> num == max_num:</span><br><span class="line">        zhongshu.append(key)</span><br><span class="line">zhongshu.sort()  <span class="comment"># 众数排序</span></span><br><span class="line">length_zs = <span class="built_in">len</span>(zhongshu)</span><br><span class="line"><span class="keyword">if</span> length_zs % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(zhongshu[length_zs//<span class="number">2</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>((zhongshu[length_zs//<span class="number">2</span>-<span class="number">1</span>] + zhongshu[length_zs//<span class="number">2</span>])/<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="简易内存池分配"><a href="#简易内存池分配" class="headerlink" title="简易内存池分配"></a>简易内存池分配</h3><ol>
<li><p>题目描述：<br>有一个简易内存池，内存按照大小粒度分类，每个粒度有若干个可用内存资源，用户会进行一系列内存申请，需要按需分配内存池中的资源，返回申请结果成功失败列表。<br>分配规则如下：<br>分配的内存要大于等于内存申请量，存在满足需求的内存就必须分配，优先分配粒度小的，但内存不能拆分使用。<br>需要按申请顺序分配，先申请的先分配。<br>有可用内存分配则申请结果为true，没有可用内存分配则返回false。<br>注：不考虑内存释放。</p>
</li>
<li><p>输入描述：<br>第一行为内存池资源列表，包含内存粒度数据信息，粒度数据间用逗号分割，一个粒度信息内部用冒号分割，冒号前为内存粒度大小，冒号后为数量。<br>资源列表不大于1024，每个粒度的数量不大于4096。<br>第二行为申请列表，申请的内存大小间用逗号分隔。申请列表不大于100000。<br>如：<br>64:2,128:1,32:4,1:128<br>50,36,64,128,127</p>
</li>
<li><p>输出描述：<br>输出为内存池分配结果。如：<br>64:2,128:1,32:4,1:128<br>50,36,64,128,127<br>true,true,true,false,false<br>说明：<br>内存池资源包含：64K共2个、128K共1个、32K共4个、1K共128个的内存资源；<br>针对50,36,64,128,127的内存申请序列，分配的内存依次是：64,64,128,NULL,NULL,<br>第三次申请内存时已经将128分配出去，因此输出结果是：true,true,true,false,false</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 内存池初始化</span></span><br><span class="line">memory = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> res <span class="keyword">in</span> <span class="built_in">input</span>().split(<span class="string">&#x27;,&#x27;</span>):</span><br><span class="line">    size, num = <span class="built_in">map</span>(<span class="built_in">int</span>, res.split(<span class="string">&#x27;:&#x27;</span>))</span><br><span class="line">    memory[size] = num</span><br><span class="line"><span class="comment"># 按照资源内存大小进行排序</span></span><br><span class="line">memory = <span class="built_in">dict</span>(<span class="built_in">sorted</span>(memory.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 申请列表</span></span><br><span class="line">appl = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split(<span class="string">&#x27;,&#x27;</span>)))</span><br><span class="line">reply = []  <span class="comment"># Output</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> app_size <span class="keyword">in</span> appl:</span><br><span class="line">    flag = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> size <span class="keyword">in</span> memory.keys():</span><br><span class="line">        <span class="keyword">if</span> size &gt; app_size <span class="keyword">and</span> memory[size] != <span class="number">0</span>:  <span class="comment"># 可分配</span></span><br><span class="line">            flag = <span class="literal">True</span></span><br><span class="line">            memory[size] = memory[size] - <span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span>  <span class="comment"># 本次分配完成</span></span><br><span class="line">    reply.append(flag)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;,&quot;</span>.join(<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> reply).lower())</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="通信网络广播与响应"><a href="#通信网络广播与响应" class="headerlink" title="通信网络广播与响应"></a>通信网络广播与响应</h3><ol>
<li>题目描述：<br> 某通信网络中有N个网络结点，用1到N进行标识。<br> 网络中的结点互联互通，且结点之间的消息传递有时延，相连结点的时延均为一个时间单位。<br> 现给定网络结点的连接关系link[i]&#x3D;{u，v}，其中u和v表示网络结点。<br> 当指定一个结点向其他结点进行广播，所有被广播结点收到消息后都会在原路径上回复一条响应消息，请计算发送结点至少需要等待几个时间单位才能收到所有被广播结点的响应消息。<br> 注：<br> N的取值范围为[1，100];<br> 连接关系link的长度不超过3000，且1 &lt;&#x3D; u,v &lt;&#x3D; N;<br> 网络中任意结点间均是可达的;</li>
<li>输入描述：<br> 输入的第一行为两个正整数，分别表示网络结点的个数N，以及时延列表的长度T；<br> 接下来的T行输入，表示结点间的连接关系列表；<br> 最后一行的输入为一个正整数，表示指定的广播结点序号；</li>
<li>输出描述：<br> 输出一个整数，表示发送结点接收到所有响应消息至少需要等待的时长。<br> 示例1（输入输出示例仅供调试，后台判题数据一般不包含示例）<br> 输入：<br> 5 7<br> 1 2<br> 1 4<br> 2 3<br> 2 4<br> 3 4<br> 3 5<br> 4 5<br> 2<br> 输出：4<br> 说明：结点2到5的最小时延为2，到剩余结点的最小时延均为1，所以至少要等待2*2&#x3D;4s。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>机试</category>
      </categories>
      <tags>
        <tag>机试</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA生成可执行jar包及常见问题与解决</title>
    <url>/2022/11/27/IDEA-generates-executable-JAR-packages/</url>
    <content><![CDATA[<h3 id="打包过程"><a href="#打包过程" class="headerlink" title="打包过程"></a>打包过程</h3><ol>
<li><p>进入需要打包的项目，选择 <strong>最上方菜单栏的 File → Project Structure</strong></p>
 <img src="https://s1.ax1x.com/2023/03/17/ppGSXUe.png" style="zoom:67%;" />
</li>
<li><p>选择 左侧菜单栏 <strong>Artifacts → + (加号) → JAR → from modules with dependencies</strong></p>
 <img src="https://s1.ax1x.com/2023/03/17/ppGSj4H.png" style="zoom:67%;" />
</li>
<li><p>选择入口类 <strong>Main Class</strong>（点击文件夹图标可以快速选择），点击 <strong>OK</strong></p>
 <img src="https://s1.ax1x.com/2023/03/17/ppGSqHO.png" style="zoom:67%;" />
</li>
<li><p>返回到IDEA主界面，选择 最上方菜单栏 <strong>Build → Build Artifacts</strong>，再选择 <strong>Build 或 Rebuild</strong> 即可</p>
<img src="https://s1.ax1x.com/2023/03/17/ppGSbDK.png" style="zoom:67%;" /></li>
<li><p>生成的Jar包 在 <strong>左侧文件列表 out&#x2F;artifacts&#x2F;xxx_jar</strong>文件夹下</p>
<img src="https://s1.ax1x.com/2023/03/17/ppGSHu6.png" style="zoom:67%;" /></li>
<li><p>在控制台执行下面命令 运行jar包进行测试</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar C:/xxx/xxx.jar</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h3><ul>
<li>问题1：<strong>运行jar包时，报错 Error: A JNI error has occurred, please check your installation and try again</strong><br>  解决：在控制台运行 java -version 和 javac -version 命令查看两个java版本是否一样，<del>如果一样我就不知道了欸嘿</del>，如果不一样，则需要在系统环境变量里修改（具体参照问题2），修改后重启控制台，运行上述命令检查<br>  （<strong>重要</strong>）检查无误后，进入IDEA界面，在 <strong>File → Project Structure</strong> 中，选择<strong>环境变量对应版本</strong>的<strong>Project SDK 和 language level</strong>，<strong>重新build程序（上面步骤4）</strong> 即可</li>
</ul>
<p>​	<img src="https://s1.ax1x.com/2023/03/17/ppGSOED.png" style="zoom:67%;" /></p>
<ul>
<li>问题2：<b>‘javac’不是内部或外部命令，也不是可运行的程序</b><br>解决：系统环境变量配置错误，检查环境变量中JAVA_HOME（应为 jdk安装的路径，如 D:\Java\jdk1.8.0_261） 和 Path（应为 %JAVA_HOME%\bin ）的内容，之后重启控制台运行 java -version 和 javac -version 检查，再执行问题一的最后一步更改IDEA的项目配置</li>
<li>问题3：<strong>打完jar包后，不能正常读取原路径存在的文件</strong><br>解决：将 <code>原路径</code> 修改为 <code>System.getProperty(&quot;user.dir&quot;) +  jar包到文件的路径</code>，其中 <code>System.getProperty(&quot;user.dir&quot;)</code>为运行jar文件时jar包的位置，也是程序源位置，根据jar的存放位置修改路径即可</li>
</ul>
<hr>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.cnblogs.com/HighnessDragonfly/p/13924869.html">1. idea如何生成jar包 - 博客园</a><br><a href="https://blog.csdn.net/Yimu_Wang/article/details/113666518">2. 使用java命令出现“Error: A JNI error…的一种解决方案</a><br><a href="https://www.php.cn/java/guide/474272.html">3. 如何解决javac不是内部或外部命令，也不是可运行程序的问题</a><br><a href="https://www.cnblogs.com/dbei/articles/13355962.html">4. 打jar包之后读不到properties文件</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IntelliJ IDEA</tag>
        <tag>Jar</tag>
      </tags>
  </entry>
  <entry>
    <title>面试相关总结</title>
    <url>/2023/03/07/Interview-related-content/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/adminpd/article/details/122934938">Redis面试题总结（2022最新版）</a></p>
<p><a href="https://www.cnblogs.com/chumochen/p/17134303.html">NET面试总结</a></p>
<p><a href="https://blog.csdn.net/sihai12345/article/details/120387150">Java 资料汇总</a></p>
<hr>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>基于神经网络的图像分类</title>
    <url>/2023/04/03/Image-Classification-Based-on-Neural-Network/</url>
    <content><![CDATA[<h3 id="XXX"><a href="#XXX" class="headerlink" title="XXX"></a>XXX</h3><h3 id="相关基础知识"><a href="#相关基础知识" class="headerlink" title="相关基础知识"></a>相关基础知识</h3><p><a href="https://zhuanlan.zhihu.com/p/377396096">机器学习为什么要划分训练集、测试集和验证集？- 知乎</a></p>
<h3 id="画图相关-pyplot-plt"><a href="#画图相关-pyplot-plt" class="headerlink" title="画图相关 pyplot (plt)"></a>画图相关 pyplot (plt)</h3><p><a href="https://blog.csdn.net/mighty13/article/details/113820798">pyplot.legend() 详解</a></p>
<p><a href="https://blog.csdn.net/TeFuirnever/article/details/89842795">plt.subplot() 详解</a></p>
<p><a href="https://blog.csdn.net/stefanjoe/article/details/112095856">plt.figure()详解</a></p>
<h3 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h3><p><a href="https://blog.csdn.net/weixin_45954454/article/details/114455209">使用MNIST数据集训练手写数字识别模型-CSDN 路遥</a></p>
<p><a href="https://blog.csdn.net/weixin_45954454/article/details/114437165">ValueError: Input 0 of layer dense is incompatible with the layer: expected axis -1 of input shape_-CSDN 路遥</a></p>
<p><a href="https://blog.csdn.net/yunfeather/article/details/106461754">tensorflow中model.compile()用法-CSDN yunfeather</a></p>
<p><a href="https://blog.csdn.net/qq_40367479/article/details/82530324">深度学习—学习率衰减(learning rate decay)_TianHongZXY的博客-CSDN博客</a></p>
<p><a href="https://www.cnblogs.com/bjxqmy/p/13521516.html">tf.keras.models.Sequential-博客园</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/163254171">从零开始实现神经网络–基于MINIST手写数字数据集 - 知乎 (zhihu.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/137571225">用PyTorch实现MNIST手写数字识别(非常详细) - 知乎 (zhihu.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/112829371">使用Pytorch框架的CNN网络实现手写数字（MNIST）识别 - 知乎 (zhihu.com)</a></p>
<h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><p><a href="https://blog.csdn.net/Gekkoou/article/details/50821519">python格式化输出dict等集合对象-CSDN博客</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-2048小游戏</title>
    <url>/2021/06/26/Java-2048-game/</url>
    <content><![CDATA[<h1 id="游戏规则"><a href="#游戏规则" class="headerlink" title="游戏规则"></a>游戏规则</h1><ol>
<li>通过上、下、左、右移动，使相邻的相同数值的数字块进行合并。</li>
<li>每次生成得到的数字块是 2 或 4 ，生成的位置是在空白位置随机出现。</li>
<li>游戏最开始随机出现两个数字块</li>
<li>每次按下一个移动方向（上下左右），所有数字块都向该方向移动直到边界，相同两个数字块合并成两数之和变成一个数字块。</li>
<li>若移动后没有一个数字块发生位移，则移动无效，也不会产生新的数字块。</li>
<li>当游戏界面没有空位而且无法移动时，游戏失败。</li>
<li>游戏分数为界面内最大的数字，当数字为2048时游戏结束。</li>
</ol>
<h1 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* JPanel是swing包下的一个模板 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">game2048</span> <span class="keyword">extends</span> <span class="title class_">JPanel</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">targetNum</span> <span class="operator">=</span> <span class="number">2048</span>; <span class="comment">//目标数字：2048</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> currentNum; <span class="comment">//当前最高数字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">side</span> <span class="operator">=</span> <span class="number">4</span>; <span class="comment">//2048游戏界面方格阵的方块数为 4 * 4</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">moveCheck</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//声明的一个bool数，检查有效移动的状态，全局move开关</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Tile[][] tile; <span class="comment">//声明一个待定二维数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();   <span class="comment">//定义随机类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//游戏的运行状态分为以下四种: 开始，胜利，正在运行，失败</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">GameState</span> &#123; start, run, win, fail &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">GameState</span> <span class="variable">gameState</span> <span class="operator">=</span> GameState.start;  <span class="comment">//初始化游戏状态为start开始状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义包含两个颜色的数字颜色板colorTilePanel用来存储 数字块的颜色</span></span><br><span class="line">    <span class="keyword">final</span> Color[] colorTilePanel = &#123;    <span class="comment">//final关键字 表示 不可变，只能赋值一次</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">0xFF6D6D</span>), <span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">0xFF8C00</span>), <span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">0xFFDB63</span>), <span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">0xBBEC6D</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">0x04BD0C</span>), <span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">0x0CF6D4</span>), <span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">0x1278FF</span>), <span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">0x6D18F6</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">0xF65EFF</span>), <span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">0xFF0000</span>)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//game2048类的构造方法(构造函数)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">game2048</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        setPreferredSize(<span class="keyword">new</span> <span class="title class_">Dimension</span>(<span class="number">500</span>, <span class="number">500</span>));  <span class="comment">//设定组件尺寸大小</span></span><br><span class="line">        setFont(<span class="keyword">new</span> <span class="title class_">Font</span>(<span class="string">&quot;宋体&quot;</span>, Font.BOLD, <span class="number">50</span>));  <span class="comment">//设置文字属性(宋体,加粗,字号50)</span></span><br><span class="line">        setFocusable(<span class="literal">true</span>); <span class="comment">//控制键盘是否可以获得按钮的焦点:是</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//addMouseListener 添加 用于接收&quot;鼠标事件&quot;的侦听器接口 OK</span></span><br><span class="line">        addMouseListener(<span class="keyword">new</span> <span class="title class_">MouseAdapter</span>() &#123;   <span class="comment">//MouseAdapter 适配器可以替代接口来处理事件</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mousePressed</span><span class="params">(MouseEvent event)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mouseCode</span> <span class="operator">=</span> event.getButton();</span><br><span class="line">                <span class="keyword">if</span>(mouseCode == MouseEvent.BUTTON1) &#123;</span><br><span class="line">                    startGame();    <span class="comment">//鼠标左键点击,开始游戏</span></span><br><span class="line">                    repaint();  <span class="comment">//刷新页面,利于页面重画</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//addKeyListener 添加 用于接收&quot;键盘事件&quot;的侦听器接口</span></span><br><span class="line">        addKeyListener(<span class="keyword">new</span> <span class="title class_">KeyAdapter</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keyPressed</span><span class="params">(KeyEvent event)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">keyCode</span> <span class="operator">=</span> event.getKeyCode();</span><br><span class="line">                <span class="keyword">if</span>(keyCode == KeyEvent.VK_UP) &#123;</span><br><span class="line">                    move(<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(keyCode == KeyEvent.VK_DOWN) &#123;</span><br><span class="line">                    move(<span class="number">15</span>, <span class="number">1</span>, <span class="number">0</span>); <span class="comment">//15=4*4-1,即二维4*4数组最后一个的下标</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(keyCode == KeyEvent.VK_LEFT) &#123;</span><br><span class="line">                    move(<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(keyCode == KeyEvent.VK_RIGHT) &#123;</span><br><span class="line">                    move(<span class="number">15</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                repaint();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* startGame方法功能: 如果游戏不是在running(正在运行)状态 则将游戏调整至start(开始)状态</span></span><br><span class="line"><span class="comment">    *  start状态: 游戏得分归0; 清空游戏界面；在界面中随机出现两个数字块</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">startGame</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (gameState != GameState.run) &#123;</span><br><span class="line">            currentNum = <span class="number">0</span>;</span><br><span class="line">            gameState = GameState.run;</span><br><span class="line">            tile = <span class="keyword">new</span> <span class="title class_">Tile</span>[side][side];</span><br><span class="line">            addTile(); addTile(); <span class="comment">//随机添加2个数字块</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//随机添加数字块</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addTile</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> rand.nextInt(side * side);    <span class="comment">//随机生成一个 0~15 之间的数，代表下一个出现数字块的位置</span></span><br><span class="line">        <span class="type">int</span> row, col;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            position = (position + <span class="number">1</span>) % (side * side);</span><br><span class="line">            <span class="comment">//当第一个随机数为15,将在(4,4)产生块,但是如果原先那有块,则pos再+1=17,超出了1-16的范围，所以需要求模运算</span></span><br><span class="line">            row = position / side;</span><br><span class="line">            col = position % side;</span><br><span class="line">        &#125; <span class="keyword">while</span> (tile[row][col] != <span class="literal">null</span>);  <span class="comment">//当(row,col)位置是空的</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> rand.nextInt(<span class="number">10</span>) == <span class="number">0</span> ? <span class="number">4</span> : <span class="number">2</span>;  <span class="comment">//生成的数字块有10%的概率为4；90%的概率为2</span></span><br><span class="line">        tile[row][col] = <span class="keyword">new</span> <span class="title class_">Tile</span>(value);    <span class="comment">//在(row,col)空位置上放置值为val的数字块</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制组件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paintComponent</span><span class="params">(Graphics g)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>.paintComponent(g);   <span class="comment">//调用super.paintComponent(gg),保留容器中的原本组件</span></span><br><span class="line">        <span class="type">Graphics2D</span> <span class="variable">gg</span> <span class="operator">=</span> (Graphics2D) g; <span class="comment">//将gg强转成Graphics2D类型,然后传给g</span></span><br><span class="line">        gg.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON); <span class="comment">//抗锯齿</span></span><br><span class="line">        drawGrid(gg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制网格</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drawGrid</span><span class="params">(Graphics2D g)</span> &#123;</span><br><span class="line">        g.setColor(<span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">0xC3F8F0</span>));  <span class="comment">//设定游戏网格为“浅蓝色”</span></span><br><span class="line">        g.fillRoundRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">500</span>, <span class="number">500</span>,<span class="number">15</span>, <span class="number">15</span>);    <span class="comment">//设置网格背景的圆角矩形</span></span><br><span class="line">        <span class="keyword">if</span> (gameState == GameState.run)    <span class="comment">//running状态下，要绘制16个小的圆角矩形</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>; r &lt; side; r++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; side; c++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tile[r][c] == <span class="literal">null</span>) &#123;</span><br><span class="line">                        g.setColor(<span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">0xFFF9FF</span>)); <span class="comment">//如果(r,c)是空位,则将空位的背景颜色设置为“淡灰色”</span></span><br><span class="line">                        g.fillRoundRect(<span class="number">15</span> + c * <span class="number">121</span>, <span class="number">15</span> + r * <span class="number">121</span>,</span><br><span class="line">                                <span class="number">106</span>, <span class="number">106</span>, <span class="number">7</span>, <span class="number">7</span>);  <span class="comment">//填充空位的圆角矩形</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        drawTile(g, r, c);  <span class="comment">//如果(r,c)是空位,则在(r,c)处绘制数字块</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">//若不在running状态下，绘制背景板为startColor的“肤色”</span></span><br><span class="line">        &#123;</span><br><span class="line">            g.setColor(<span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">0x2EE4F5</span>));</span><br><span class="line">            g.fillRoundRect(<span class="number">15</span>, <span class="number">15</span>, <span class="number">469</span>, <span class="number">469</span>, <span class="number">7</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置后续字体颜色；.darker()使“2048等提示信息”的颜色变暗,反复使用效果增强</span></span><br><span class="line">            g.setColor((<span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">0x044DBB</span>)).darker());</span><br><span class="line">            g.setFont(<span class="keyword">new</span> <span class="title class_">Font</span>(<span class="string">&quot;宋体&quot;</span>, Font.BOLD, <span class="number">70</span>));</span><br><span class="line">            g.drawString(<span class="string">&quot;2048小游戏&quot;</span>, <span class="number">70</span>, <span class="number">170</span>);</span><br><span class="line"></span><br><span class="line">            g.setFont(<span class="keyword">new</span> <span class="title class_">Font</span>(<span class="string">&quot;宋体&quot;</span>, Font.BOLD, <span class="number">30</span>));    <span class="comment">//设置结束提示信息的字体属性</span></span><br><span class="line">            <span class="keyword">if</span> (gameState == GameState.win)</span><br><span class="line">                g.drawString(<span class="string">&quot;玩家胜利!&quot;</span>, <span class="number">185</span>, <span class="number">250</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (gameState == GameState.fail)</span><br><span class="line">                g.drawString(<span class="string">&quot;游戏失败!&quot;</span>, <span class="number">185</span>, <span class="number">250</span>);</span><br><span class="line"></span><br><span class="line">            g.setColor(<span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">0xA1F6D2</span>));  <span class="comment">//设置下面提示信息的颜色</span></span><br><span class="line">            g.setFont(<span class="keyword">new</span> <span class="title class_">Font</span>(<span class="string">&quot;宋体&quot;</span>, Font.BOLD, <span class="number">20</span>));</span><br><span class="line">            g.drawString(<span class="string">&quot;&gt; 鼠标左键点击开始新游戏 &lt;&quot;</span>, <span class="number">115</span>, <span class="number">370</span>);</span><br><span class="line">            <span class="keyword">if</span>(gameState == GameState.start)</span><br><span class="line">                g.drawString(<span class="string">&quot;使用上下左右方向键控制数字块移动&quot;</span>, <span class="number">90</span>, <span class="number">430</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制数字块</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drawTile</span><span class="params">(Graphics2D g, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> tile[r][c].getValue();</span><br><span class="line">        g.setColor(colorTilePanel[(<span class="type">int</span>) (Math.log(value) / Math.log(<span class="number">2</span>)) - <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">/* setColor( colorTable[ ln(value/2)-1 ] )</span></span><br><span class="line"><span class="comment">        *  当value=2^1=2,取colorTilePanel[0],则数字块2的颜色为颜色板位置0处的</span></span><br><span class="line"><span class="comment">           当value=2^10=1024,取colorPanel[9],则数字块1024的颜色为颜色板最后位置9处的</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">        g.fillRoundRect(<span class="number">15</span> + c * <span class="number">121</span>, <span class="number">15</span> + r * <span class="number">121</span>, <span class="number">106</span>, <span class="number">106</span>, <span class="number">7</span>, <span class="number">7</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.valueOf(value);   <span class="comment">//将int型变量 value 转换成字符串,存放在str中</span></span><br><span class="line">        g.setColor(<span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">0xFFF4D3</span>));</span><br><span class="line">        <span class="type">FontMetrics</span> <span class="variable">fm</span> <span class="operator">=</span> g.getFontMetrics();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ascent</span> <span class="operator">=</span> fm.getAscent();   <span class="comment">//ascent是 基准线 之上至字符最高处的距离</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">descent</span> <span class="operator">=</span> fm.getDescent();  <span class="comment">//descent是 基准线 之下至字符最低处的距离</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">15</span> + c * <span class="number">121</span> + (<span class="number">106</span> - fm.stringWidth(str)) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">15</span> + r * <span class="number">121</span> + (ascent + (<span class="number">106</span> - (ascent + descent)) / <span class="number">2</span>);</span><br><span class="line">        g.drawString(str, x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  move()方法</span></span><br><span class="line"><span class="comment">    *  传入参数：countDownFrom -&gt; 从这开始找需要移动的方块; yIncrease -&gt; y方向增量; xIncrease -&gt; x方向增量;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">move</span><span class="params">(<span class="type">int</span> countDownFrom, <span class="type">int</span> yIncrease, <span class="type">int</span> xIncrease)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag_Move</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//用来标记 是否已经移动</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; side * side; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> Math.abs(countDownFrom - i); <span class="comment">//abs():取绝对值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> j / side;</span><br><span class="line">            <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> j % side;</span><br><span class="line">            <span class="keyword">if</span> (tile[row][col] == <span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextRow</span> <span class="operator">=</span> row + yIncrease;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextCol</span> <span class="operator">=</span> col + xIncrease;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (nextRow &gt;= <span class="number">0</span> &amp;&amp; nextRow &lt; side &amp;&amp; nextCol &gt;= <span class="number">0</span> &amp;&amp; nextCol &lt; side) &#123; <span class="comment">//当数字块不在边界</span></span><br><span class="line">                <span class="type">Tile</span> <span class="variable">next</span> <span class="operator">=</span> tile[nextRow][nextCol];    <span class="comment">//移动后的数字块</span></span><br><span class="line">                <span class="type">Tile</span> <span class="variable">current</span> <span class="operator">=</span> tile[row][col];       <span class="comment">//数字块的目前位置</span></span><br><span class="line">                <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123; <span class="comment">//如果移动后的位置没有数字块</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (moveCheck) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//检查可用的移动,如果可以移动则返回</span></span><br><span class="line"></span><br><span class="line">                    tile[nextRow][nextCol] = current;</span><br><span class="line">                    tile[row][col] = <span class="literal">null</span>;</span><br><span class="line">                    row = nextRow;</span><br><span class="line">                    col = nextCol;</span><br><span class="line">                    nextRow += yIncrease;</span><br><span class="line">                    nextCol += xIncrease;</span><br><span class="line">                    flag_Move = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (next.mergeCheck(current)) &#123; <span class="comment">//如果移动后的位置有能可以与之合并的数字块</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (moveCheck) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> next.merge(current); <span class="comment">//value是合并之后的数字</span></span><br><span class="line">                    <span class="keyword">if</span> (value &gt; currentNum) currentNum = value;</span><br><span class="line">                    tile[row][col] = <span class="literal">null</span>; <span class="comment">//数字块移动离开后，设定原位置为空块</span></span><br><span class="line">                    flag_Move = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;   <span class="comment">// end while</span></span><br><span class="line"></span><br><span class="line">        &#125;   <span class="comment">// end for</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flag_Move) &#123;</span><br><span class="line">            <span class="keyword">if</span> (currentNum &lt; targetNum) &#123; <span class="comment">//移动之后，如果没达到预定分数，清除合并状态，添加随机数字块</span></span><br><span class="line">                clearMerged();</span><br><span class="line">                addTile();</span><br><span class="line">                <span class="comment">//检查“满没满”</span></span><br><span class="line">                moveCheck = <span class="literal">true</span>; <span class="comment">//moveCheck是检查移动功能的开关，true为开</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">canMoves</span> <span class="operator">=</span> move(<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>) || move(<span class="number">15</span>, <span class="number">1</span>, <span class="number">0</span>) ||</span><br><span class="line">                        move(<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>) || move(<span class="number">15</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (!canMoves) &#123;</span><br><span class="line">                    gameState = GameState.fail;</span><br><span class="line">                &#125;</span><br><span class="line">                moveCheck = <span class="literal">false</span>; <span class="comment">//“关闭moveCheck开关”</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (currentNum == targetNum)</span><br><span class="line">                gameState = GameState.win;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag_Move;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清除数字块的合并状态</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">clearMerged</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; side; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; side; j++)</span><br><span class="line">                <span class="keyword">if</span> (tile[i][j] != <span class="literal">null</span>)</span><br><span class="line">                    tile[i][j].setMerge();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>();    <span class="comment">//新建一个窗口对象f</span></span><br><span class="line">        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);   <span class="comment">//在关闭窗体的同时，终止程序的运行</span></span><br><span class="line">        frame.setTitle(<span class="string">&quot;2048小游戏&quot;</span>);    <span class="comment">//设置窗口标题为“2048小游戏”</span></span><br><span class="line">        frame.setResizable(<span class="literal">false</span>);    <span class="comment">//窗口尺寸是否可变：否</span></span><br><span class="line">        frame.add(<span class="keyword">new</span> <span class="title class_">game2048</span>());    <span class="comment">//在窗口上添加“2048游戏”组件</span></span><br><span class="line">        frame.pack();    <span class="comment">//设定窗口的大小恰好能容纳其上添加的组件</span></span><br><span class="line">        frame.setLocationRelativeTo(<span class="literal">null</span>);    <span class="comment">//设置窗口相对于指定组件的位置,若参数为null，则窗口将置于屏幕中央</span></span><br><span class="line">        frame.setVisible(<span class="literal">true</span>);    <span class="comment">//窗口是否可见：是</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tile类: 数字块</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tile</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;  <span class="comment">//数据成员value: 数字块上的数值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> merge; <span class="comment">//数据成员merge: 是否能合并</span></span><br><span class="line"></span><br><span class="line">    Tile(<span class="type">int</span> value) &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;   <span class="comment">//Tile类的构造方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setMerge</span><span class="params">()</span> &#123;</span><br><span class="line">        merge = <span class="literal">false</span>;</span><br><span class="line">    &#125;   <span class="comment">//设置方块的合并状态</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;   <span class="comment">//value的getter方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* mergeCheck方法功能: 判断本方块与另一个方块是否能合并，返回bool值</span></span><br><span class="line"><span class="comment">     *  1. !merged 和 ！other.merged ---&gt; 两个方块的合并状态都是false</span></span><br><span class="line"><span class="comment">     *  2. value == other.getValue() ---&gt; 两个方块的数值相等</span></span><br><span class="line"><span class="comment">     *  若满足以上条件，则两方块可以合并，返回true  */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">mergeCheck</span><span class="params">(Tile t)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !merge &amp;&amp; !t.merge &amp;&amp; value == t.getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法功能: 判断两方块能合并之后，与另一个方块合并(即本方块数值×2)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">merge</span><span class="params">(Tile t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mergeCheck(t)) &#123;</span><br><span class="line">            value *= <span class="number">2</span>;</span><br><span class="line">            merge = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p> 初始界面：<br><img src="https://img-blog.csdnimg.cn/20210626220219297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUwOTE4ODM0,size_16,color_FFFFFF,t_70#pic_center" style="zoom: 67%;" /><br>开始界面：<br><img src="https://img-blog.csdnimg.cn/202106262202567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUwOTE4ODM0,size_16,color_FFFFFF,t_70#pic_center =400x400" style="zoom:67%;" /><br>失败界面：<br><img src="https://img-blog.csdnimg.cn/20210626220334688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUwOTE4ODM0,size_16,color_FFFFFF,t_70#pic_center =400x400" style="zoom:67%;" /><br>胜利界面：<br><img src="https://img-blog.csdnimg.cn/20210626220403350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUwOTE4ODM0,size_16,color_FFFFFF,t_70#pic_center =400x400" style="zoom:67%;" /></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java ArrayList集合</title>
    <url>/2023/03/23/Java-ArrayList/</url>
    <content><![CDATA[<hr>
<p><strong>参考文章</strong>：</p>
<ul>
<li><a href="https://juejin.cn/post/6844903566331609096#heading-4">什么是 ArrayList - 掘金 (juejin.cn)</a></li>
<li></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>Java字符串拼接</title>
    <url>/2023/03/23/Java-Strings-Splicing-Tools-StringBuilder-StringBuffer%20-%20%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[<h3 id="利用-拼接字符串"><a href="#利用-拼接字符串" class="headerlink" title="利用 + 拼接字符串"></a>利用 + 拼接字符串</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringSplicing</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            str += <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - begin);  <span class="comment">// 运行时间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行花费时间：3703 ms</p>
<p>分析：这种字符串拼接方式是创建一个新的字符串，然后将原来的字符串和将要拼接的字面量拼接起来赋给新的字符串。<br>这个过程中会不断创建新的字符串对象，所以会耗费大量时间，同时创建太多的新字符串会占用大量的内存，可能会导致方法区内存溢出。<br>如果是数据量较少的话可以使用该方法，数据量过多不建议使用。</p>
<p>实际上，在代码中IDEA也会给出 <code>warning：String concatenation &#39;+=&#39; in loop</code>，并且推荐我们把字符串变量str改成 <code>StringBuilder</code>类型。</p>
<h3 id="利用-StringBuilder-拼接字符串"><a href="#利用-StringBuilder-拼接字符串" class="headerlink" title="利用 StringBuilder 拼接字符串"></a>利用 StringBuilder 拼接字符串</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringSplicing</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            str.append(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - begin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行花费时间：80 ms</p>
<p>分析：可以看出，在完成第1个示例百倍的字符串拼接任务，StringBuilder类花费的时间仍然大大缩短。<br>原因是，和 String 类不同，StringBuilder 和 StringBuffer类的对象能够被多次的修改，并且不产生新的未使用对象。</p>
<p>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）<br>而且， StringBuilder 相较于 StringBuffer 有速度优势，所以大多数情况下推荐使用 StringBuilder 类</p>
<h3 id="利用-StringBuffer-拼接字符串"><a href="#利用-StringBuffer-拼接字符串" class="headerlink" title="利用 StringBuffer 拼接字符串"></a>利用 StringBuffer 拼接字符串</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringSplicing</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            str.append(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - begin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行花费时间：243 ms</p>
<p>StringBuffer 与 StringBuilder类似，速度稍慢于后者；在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</p>
<hr>
<p><strong>参考文章</strong>：</p>
<ul>
<li><a href="https://www.runoob.com/java/java-stringbuffer.html">Java StringBuffer 和 StringBuilder 类 | 菜鸟教程</a></li>
<li><a href="https://blog.csdn.net/weixin_30807677/article/details/98155146">Java 字符串拼接 StringBuilder 与 StringBuffer | CSDN转载</a></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Pycharm常见报错及解决方案</title>
    <url>/2023/03/15/Pycharm-common-errors-and-solutions/</url>
    <content><![CDATA[<h5 id="No-Python-at-‘D-Python-python-exe’-and-solution"><a href="#No-Python-at-‘D-Python-python-exe’-and-solution" class="headerlink" title="No Python at ‘D:\Python\python.exe’ and solution"></a><a href="https://blog.csdn.net/qq_47733361/article/details/123658062">No Python at ‘D:\Python\python.exe’ and solution</a></h5><p><strong>Solution</strong>：查看<code>File - Settings - Project: xxx - Python Interpreter</code>，点击右侧齿轮图标，选择<code>Add</code>，勾选<code>Existing environment</code>，在<code>Interpreter</code>处选择本地Python路径即可</p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Pycharm</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓开发复习</title>
    <url>/2023/05/04/Review-of-Android-Development/</url>
    <content><![CDATA[<hr>
<h3 id="6、页面跳转——Intent"><a href="#6、页面跳转——Intent" class="headerlink" title="6、页面跳转——Intent"></a>6、页面跳转——Intent</h3><ol>
<li><p>简介<br>Intent 是一种组件之间消息传递机制<br>主要用于：<u>启动Activity</u>、<u>Service</u>，和 <u>在Android系统上发布Broadcast消息</u></p>
</li>
<li><p>用Intent启动Activity</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显式启动：指明要启动的Activity类</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(A_Activity.<span class="built_in">this</span>, B_Activity.class);</span><br><span class="line">startActivity(intent);  <span class="comment">// A启动B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//隐式启动：由Android系统根据Intent的动作和数据来决定启动对象</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_VIEW, </span><br><span class="line">                           Uri.prase(<span class="string">&quot;http://www.163.com&quot;</span>));</span><br><span class="line">startActivity(intent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式启动2(启动浏览器打开一个网址)</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">intent.setAction(Intent.ACTION_VIEW);  <span class="comment">// Intent动作, 由系统提供</span></span><br><span class="line">intent.setData(Uri.parse(<span class="string">&quot;http://www.163.com&quot;</span>));  <span class="comment">// Intent数据</span></span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></li>
<li><p>Activity间传递数据<br>（1）单向传递数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A端 发送端</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(A_Activity.<span class="built_in">this</span>, B_Activity.class);</span><br><span class="line"><span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">bundle.putString(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;wustzz&quot;</span>);</span><br><span class="line">intent.putExtras(bundle);</span><br><span class="line">startActivity(intent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// B端 接收端</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> getIntent();</span><br><span class="line"><span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> intent.getExtras();</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> bundle.getStrint(<span class="string">&quot;name&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>（2）双向传递数据</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A端 发送</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(A_Activity.<span class="built_in">this</span>, B_Activity.class);</span><br><span class="line"><span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">bundle.putString(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;wustzz&quot;</span>);</span><br><span class="line">intent.putExtras(bundle);</span><br><span class="line">startActivityForResult(intent, <span class="number">100</span>);  <span class="comment">// 设置requestCode=100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// B端 接收并发送</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> getIntent();</span><br><span class="line"><span class="comment">// ...处理A传过来的intent和bundle</span></span><br><span class="line"><span class="type">Bundle</span> <span class="variable">bundle2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">bundle2.putString(<span class="string">&quot;sum&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">intent.putExtras(bundle2);</span><br><span class="line">setResult(RESULT_OK, intent);</span><br><span class="line">finish();</span><br><span class="line"></span><br><span class="line"><span class="comment">// A端 接收</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onActivityResult</span><span class="params">(<span class="type">int</span> requestCode, <span class="type">int</span> resultCode, Intent data)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (requestCode == <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (resultCode == RESULT_OK) &#123;</span><br><span class="line">			<span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> data.getExtras();</span><br><span class="line">            <span class="type">String</span> <span class="variable">sum</span> <span class="operator">=</span> bundle.getString(<span class="string">&quot;sum&quot;</span>);</span><br><span class="line">            <span class="type">TextView</span> <span class="variable">tv</span> <span class="operator">=</span> (TextView)findViewById(R.id.textView);</span><br><span class="line">            tv.setText(<span class="string">&quot;sum=&quot;</span>, sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<hr>
<h3 id="7、消息传递——广播-Broadcast"><a href="#7、消息传递——广播-Broadcast" class="headerlink" title="7、消息传递——广播 Broadcast"></a>7、消息传递——广播 Broadcast</h3><ol>
<li><p>BroadcastReceiver简介<br>Android的每个应用程序都可以对自己感兴趣的广播进行注册，只自己所关心的广播内容<br>广播可以来自于系统，也可以来自应用程序</p>
</li>
<li><p>BroadcastReceiver的使用<br>当消息到达时，接收器调用OnReceive()方法,OnReceive()是BroadcastReceiver类中的唯一的抽象方法。在该方法结束后，广播接收器对象失活。</p>
</li>
<li><p>注册广播接收<br>(1) 动态注册：在代码中注册<br>(2) 静态注册：在AndroidManifest.xml文件中注册</p>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="8、数据存储"><a href="#8、数据存储" class="headerlink" title="8、数据存储"></a>8、数据存储</h3><ol>
<li>SharedPreferences存储<br> 使用 key-values键值对 的方式存储数据，key用于寻找该条数据<br> 适用于存储少量数据</li>
</ol>
<hr>
<h3 id="复习课ppt整理"><a href="#复习课ppt整理" class="headerlink" title="复习课ppt整理"></a>复习课ppt整理</h3><ol>
<li><p><strong>下面不是Android四大组件之一的是：（B）</strong><br> A、Activity<br> B、Intent<br> C、Service<br> D、ContentProvider<br> 解释：Android四大组件为Activity、Service、ContentProvider、BroatcastReceiver</p>
</li>
<li><p><strong>Android中下列属于Intent的作用的是：（C）</strong><br>A、实现应用程序间的数据共享<br>B、是一段长的生命周期，没有用户界面的程序，可以保持应用在后台运行，而不会因为切换页面而消失<br>C、可以实现界面间的切换，可以包含动作和动作数据，连接四大组件的纽带<br>D、处理一个应用程序整体性的工作</p>
</li>
<li><p><strong>下面关于BroadcastReceiver错误的是：（B）</strong><br>A、 BroadcastReceiver有两种注册方式，静态注册和动态注册<br>B、BroadcastReceiver必须在AndroidMainfest文件中声明<br>C、BroadcastReceiver的使用，一定有一方发送广播，有一方监听注册广播，onReceive方法才会被调用。<br>D、广播发送的Intent都是隐式启动。<br>解释：注册广播接收的方式一般有两种(1) 动态注册-在代码中注册 和 (2)静态注在AndroidManifest.xml注册</p>
</li>
<li><p><strong>在手机开发中常用的数据库是：（A）</strong><br>A、SQLite3<br>B、Oracle<br>C、Sql Server<br>D、Db23</p>
</li>
<li><p><strong>Service中如何实现更改Activity界面元素：(B）</strong><br>A、通过把当前activity对象传递给service对象<br>B、通过向Activity发送广播<br>C、通过Context对象更改Activity界面元素<br>D、可以在service中，调用Activity的方法实现更改界面元素</p>
</li>
<li><p><strong>下列对SharedPreferences存取文件的说法，不正确是（C）:</strong><br>A、属于移动存储解决方案<br>B、sharePreferences处理的就是key-value对<br>C、读取xml文件的路径是&#x2F;sdcard&#x2F;shared_prefs&#x2F;<br>D、数据的保存格式是xml</p>
</li>
<li><p><strong>关于ISON和XML说法，错误的是：（B）</strong><br>A、JSON的速度要远远快于XML<br>B、JSON对数据的描述性比XML好<br>C、JSON相对于XML来讲，数据的体积小<br>D、JSON和XML同样拥有丰富的解析手段<br>解释：复杂数据情况下，JSON+文档 &#x3D; XML，简单数据情况下，JSON &gt; 1XML</p>
</li>
<li><p><strong>关于Handler的说法不正确的是（A）</strong><br>A、它实现不同进程间通信的一种机制<br>B、它避免了在新线程中刷新UI的操作<br>C、它采用队列的方式来存储Message<br>D、它实现不同线程间通信的一种机制<br>解释：Handler用于Android的线程间通信；而Binder和Socket用于进程间通信</p>
</li>
<li><p><strong>简述Activity生命周期</strong><br>答：Activity生命周期指Activity从启动到销毁的过程<br>onCreate() 创建活动，做一些数据初始化操作。<br>onStart() 由不可见变为可见，显示在屏幕上<br>onResume() 可以与用户进行交互，位于栈顶,<br>onPause() 暂停，启动或恢复另一个活动时调用。<br>onStop() 停止，变为不可见。<br>onDestroy() 销毁<br>onRestart() 由停止状态变为运行状态。</p>
</li>
<li><p><strong>如何设置View的宽度</strong><br>答：采用wrap_content自适应内容，设置View的宽度（Width）<br>解释：android:layout_width可选两种预设属性值：wrap_content（让当前控件刚好包含里面的内容）、和 match_parent（让父布局决定当前控件大小）；或设置为指定dp值</p>
</li>
<li><p>设计三个按钮横向紧密排列，距离上边界20dp，</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;horizontal&quot;</span> &gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">		<span class="attr">android:id</span>=<span class="string">&quot;@+id/button1&quot;</span></span></span><br><span class="line"><span class="tag">        /*<span class="attr">----</span> <span class="attr">在下方加入代码</span> <span class="attr">----</span>*/</span></span><br><span class="line"><span class="tag">    	<span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;按钮1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;20dp&quot;</span></span></span><br><span class="line"><span class="tag">        /*<span class="attr">----</span> <span class="attr">在上方加入代码</span> <span class="attr">----</span>*/</span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">		<span class="attr">android:id</span>=<span class="string">&quot;@+id/button2&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>广播发送端activity部分代码如下，补充代码使之完整。<br>要求：从EditText et1和et2获取输入内容，从RadioButton rb获取内容，采用Bundle和Intent发送数据，广播标识串为”wust.zz.mybroadcast”；广播发送成功后，采用Log类显示发送成功。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RadioGroup rg=(RadioGroup)findViewByld(R.id.operator);</span><br><span class="line">rg.setOncheckedChangeListener(<span class="keyword">new</span> <span class="title class_">RadioGroup</span>.OncheckedChangeListener()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">oncheckedChanged</span><span class="params">(RadioGroup group, <span class="type">int</span> checkedld)</span> &#123;</span><br><span class="line">		EditText et1=(EditText)findViewByld(R.id.editText1);</span><br><span class="line">		EditText et2=(EditText)findViewByld(R.id.editText2);</span><br><span class="line">        RadioButton rb=(RadioButton)findViewByld(checkedld);</span><br><span class="line">        <span class="comment">//---- 在下方加入代码 ----</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读取EditText和RadioButton的内容</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str_et1</span> <span class="operator">=</span> et1.getText().toString();  </span><br><span class="line">        <span class="type">String</span> <span class="variable">str_et2</span> <span class="operator">=</span> et2.getText().toString();  </span><br><span class="line">        <span class="type">String</span> <span class="variable">str_rb</span> <span class="operator">=</span> rb.getText().toString();</span><br><span class="line">        <span class="comment">// 采用bundle和Intent发送数据</span></span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="string">&quot;wust.zz.mybroadcast&quot;</span>);</span><br><span class="line">        <span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">        bundle.putString(<span class="string">&quot;str_et1&quot;</span>, str_et1);</span><br><span class="line">        bundle.putString(<span class="string">&quot;str_et2&quot;</span>, str_et2);</span><br><span class="line">        bundle.putString(<span class="string">&quot;str_rb&quot;</span>, str_rb);</span><br><span class="line">        intent.putExtras(bundle);</span><br><span class="line">        <span class="comment">// 发送广播</span></span><br><span class="line">        sendBroadcast(intent);</span><br><span class="line">        <span class="comment">// 记录日志</span></span><br><span class="line">        Log.d(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;广播发送成功&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//---- 在上方加入代码 ----</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="网上测试题（错题本）"><a href="#网上测试题（错题本）" class="headerlink" title="网上测试题（错题本）"></a>网上测试题（错题本）</h3><ol>
<li><strong>And.roid 工程中存放各种程序资源的目录是（C）</strong><br>A、src  B、gen  C、res  D、bin</li>
<li><strong>在下列选项中,关于Android工程中的assets目录的说法正确的是（B）</strong><br>A、存放使用到的图片资源<br>B、主要存放一些文件资源,这些文件会被原封不动的打包到APK文件中<br>C、存放字符串、颜色、数组等常量数据<br>D、存放与UI相应的布局文件</li>
<li><strong>Android UI开发中，设置Activity的（A）属性可以使Activity显示为对话框样式。</strong><br>A、android:theme&#x3D;”@android:style&#x2F;Theme.Dialog”<br>B、android:style&#x3D;”@android:style&#x2F;Theme.Dialog”<br>C、android:theme&#x3D;”@android:theme&#x2F;Theme.Dialog”<br>D、android:style&#x3D;”@android:theme&#x2F;Theme.Dialog”</li>
<li><strong>在网格布局中，设置列数的属性是（B）</strong><br>A、column<br>B、columnCount<br>C、layout_columnCount<br>D、stretchColumns</li>
<li><strong>Android UI开发中，TableLayout的stretchColumns属性表示（D）</strong><br>A、TableLayout的列数<br>B、TableLayout的行数<br>C、TableLayout最多能加入的列数<br>D、拉伸指定列填充满TableLayout</li>
<li><strong>放入绝对布局中的控件需要通过（D）两个属性指定其准确的坐标值</strong><br>A、android:width和android:height<br>B、android:layout_width和android:layout_height<br>C、android:x和android:y<br>D、android:layout_x和android:layout_y</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
        <category>安卓</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>信息系统安全复习</title>
    <url>/2023/05/04/Review-of-Information-System-Security-Review/</url>
    <content><![CDATA[<hr>
<h3 id="第0章-绪论"><a href="#第0章-绪论" class="headerlink" title="第0章 绪论"></a>第0章 绪论</h3><ul>
<li><p><strong>信息的安全属性</strong><br><strong>机密性</strong>：确保信息不泄漏给未经授权的实体<br><strong>完整性</strong>：确保信息及其处理过程不被未经授权地篡改<br><strong>可用性</strong>：确保信息及信息系统确实为授权使用者所用<br><strong>可控性</strong>：能够控制使用信息资源的人或实体的使用方式<br><strong>可鉴别性</strong>：信息及其操作是可鉴别的，包括真实性和不可抵赖性</p>
</li>
<li><p><strong>硬件结构的安全</strong>和<strong>操作系统的安全</strong>是<strong>信息系统安全的基础</strong></p>
</li>
</ul>
<hr>
<h3 id="第3章-访问控制"><a href="#第3章-访问控制" class="headerlink" title="第3章 访问控制"></a>第3章 访问控制</h3><h4 id="3-2-自主访问控制的实现方式"><a href="#3-2-自主访问控制的实现方式" class="headerlink" title="3.2 自主访问控制的实现方式"></a>3.2 自主访问控制的实现方式</h4><p>① <strong>访问口令</strong>：客体提供口令，并分发给主体；主体访问时需要提供访问口令<br>② <strong>访问控制矩阵</strong>：访问控制的矩阵形式<br>③ <strong>访问能力表</strong>：主体能访问的客体明细表<br>④ <strong>访问控制表</strong>(ACL)：能访问该客体的主体明细表<br>⑤ <strong>授权关系表</strong>：记录所有的主-客体关系<br>⑥ <strong>属主&#x2F;同组用户&#x2F;其他用户</strong>(OGO)：文件属性附加访问控制信息</p>
<h4 id="3-3-强制访问控制-MAC"><a href="#3-3-强制访问控制-MAC" class="headerlink" title="3.3 强制访问控制 MAC"></a>3.3 强制访问控制 MAC</h4><p><strong>特点</strong>：系统对授权<strong>集中</strong>管理；管理部门按照严格的安全规则设置系统中的主体、客体的安全级别、安全范畴等安全属性；系统运行时通过比较主-客体的安全属性，决定是否允许主体以其所请求的方式访问客体。</p>
<h5 id="BLP模型"><a href="#BLP模型" class="headerlink" title="BLP模型"></a>BLP模型</h5><p>安全目标：机密性<br>主体对客体的4种访问权限：只读、添加、执行、读写<br>安全访问规则：<strong>不上读，不下写，自主访问控制</strong>（分别为SS策略、*策略、DS策略）<br>可用性问题：<strong>隐蔽通道违反系统安全策略</strong><br><strong>信息流方向 为从 低机密性级别 到 高密级 的安全域</strong></p>
<h5 id="Biba模型"><a href="#Biba模型" class="headerlink" title="Biba模型"></a>Biba模型</h5><ul>
<li>针对<strong>主体</strong>：<br>  <strong>SIP策略</strong>：<u><strong>不下读，不上写</strong></u>，信息流方向 从 高完整性级别 到 低完整性级别 的安全域<br>  <strong>RP策略</strong>：<u>任何主体都可以对任何客体进行“读”访问</u>，其他一样<br>  <strong>LWMPS策略</strong>：<u>允许主体s对任何客体o进行“读”访问，但访问完成后其完整性级别调整为 $min(i(s) , i(o))$</u></li>
<li>针对<strong>客体</strong>：<br>  <strong>SIP策略</strong>：<u><strong>不下读，不上写</strong></u><br>  <strong>LWMPO策略</strong>：<u>允许主体s对任何客体o进行“写”访问，但访问完成后其完整性级别调整为 $min(i(s) , i(o))$</u><br>  <strong>LWMIAP策略</strong>：<u>允许主体s对任何客体o进行“写”访问，但如果i(s)不支配i(o)，则对该操作进行审计</u></li>
</ul>
<h4 id="3-4-基于角色的访问控制"><a href="#3-4-基于角色的访问控制" class="headerlink" title="3.4 基于角色的访问控制"></a>3.4 基于角色的访问控制</h4><p>特权的作用： ① <strong>便于系统维护</strong>，② <strong>提高系统可用性</strong><br>特权对信息系统安全的危害：<strong>被窃取、被误用、被滥用</strong></p>
<hr>
<h3 id="第4章-安全审计"><a href="#第4章-安全审计" class="headerlink" title="第4章 安全审计"></a>第4章 安全审计</h3><h4 id="4-2-安全审计系统模型"><a href="#4-2-安全审计系统模型" class="headerlink" title="4.2 安全审计系统模型"></a>4.2 安全审计系统模型</h4><p><a href="https://imgse.com/i/p9NFJk8"><img src="https://s1.ax1x.com/2023/05/04/p9NFJk8.jpg" alt="p9NFJk8.jpg" border="0" style="zoom: 67%;" /></a><br>① 事件鉴别器被逻辑地嵌入系统软件中，检测被配置为需要检测的与安全相关的活动<br>② 事件鉴别器对每个检测到的事件，以审计消息的形式传输到审计记录器<br>③ 审计记录器为每个事件消息创建格式化的记录，并将其存储在安全审计踪迹中<br>④ 审计分析器基于活动模式，可以定义新的可审计事件并发送到审计记录器中，也可以产生报警<br>⑤ 报警处理器根据收到的报警信息采取一系列活动，这些活动通常是可审计事件，可以被传输到审计记录器<br>⑥ 审计存档器是一个软件模块，定期从 安全审计踪迹中提取记录，创建可审计事件的一个永久存档。<br>⑦ 审计存档是在此系统上实现安全相关 事件的永久存档。<br>⑧ 审计提供器是一个与应用程序和安全审计踪迹相关的用户接口<br>⑨ 审计检查器是一个应用程序或用户，可以检查审计踪迹和审计存档的历史数据<br>⑩ 审计检查器提供人工可读的安全报告</p>
<h4 id="4-3-安全审计系统的设计与实现"><a href="#4-3-安全审计系统的设计与实现" class="headerlink" title="4.3 安全审计系统的设计与实现"></a>4.3 安全审计系统的设计与实现</h4><ul>
<li>审计踪迹：维护系统活动的记录<br>系统级、应用级、用户级、物理访问级</li>
</ul>
<hr>
<h3 id="第5章-Windows操作系统安全"><a href="#第5章-Windows操作系统安全" class="headerlink" title="第5章 Windows操作系统安全"></a>第5章 Windows操作系统安全</h3><ol>
<li><p><strong>操作系统的安全性方法</strong><br> 物理隔离、时间隔离、逻辑隔离、加密隔离</p>
</li>
<li><p><strong>活动目录</strong> 和 <strong>域</strong><br> <strong>活动目录</strong>是一个包含网络资源（计算机、用户、文件、打印机等）的数据库。<br> 也是一种分布式的目录服务系统。在分布式环境中，允许网络资源被各种授权应用（用户、程序）方便地访问读取。<br> <strong>域</strong>是Windows网络系统的安全性边界。一个域可以分布在多个物理位置上。活动目录可以贯穿一个或多个域。<br> <strong>活动目录的 安全管理单元 是 域</strong>，域中的所有用户和计算机执行相同的域安全策略。</p>
</li>
<li><p><strong>Winlogon进程</strong> 是用户本地登陆程序，负责管理用户登录和注销过程，加载登录界面 并监视安全认证的顺序<br> <strong>NetLogon进程</strong> 处理网络登录，维护计算机到其所在域的域控制器的安全信道</p>
</li>
<li><p><strong>Windows 本地身份认证机制</strong><br> <a href="https://imgse.com/i/p9NPgET"><img src="https://s1.ax1x.com/2023/05/04/p9NPgET.jpg" alt="p9NPgET.jpg" border="0" style="zoom: 33%;" /></a><br> ① 用户按下SAS键引起硬件中断，并被操作系统捕获，激活Winlogon进程。Winlogon进程调用GINA，显示对话框，便于用户输入账号和口令<br> ② GINA将用户输入的账号和口令返回给Winlogon进程<br> ③ Winlogon进程将账号口令信息发送给LSA进行验证<br> ④ LSA调用Msv1_0.dll验证程序包处理用户信息，生成密钥<br> ⑤ Msv1_0.dll验证程序包 将生成的密钥发送给SAM服务器进程<br> ⑥ SAM服务器进程将收到的用户密钥与SAM数据库中存储的密钥进行对比<br> ⑦ 如果用户合法，SAM进程会将用户SID、用户组SID和相关信息发送给Msv1_0.dll<br> ⑧ Msv1_0.dll 验证程序包将 认证结果 返回给LSA<br> ⑨ LSA根据收到的SID信息创建安全访问令牌，将令牌句柄和登录信息发送给Winlogon进程。Winlogon进程处理用户登录，完成本地身份认证过程。</p>
</li>
<li><p><strong>加密文件系统 EFS</strong><br><a href="https://imgse.com/i/p9NiIJg"><img src="https://s1.ax1x.com/2023/05/04/p9NiIJg.jpg" alt="p9NiIJg.jpg" border="0" style="zoom: 67%;" /></a></p>
</li>
<li><p><strong>安全关联 SA</strong><br>从源主机到目的主机建立一条网络层的逻辑连接，即为安全关联 SA<br>安全关联是从源点到终点的<strong>单向</strong>连接，能够提供安全服务<br>例如：公司H1经由公司路由器R1与主机H2进行安全通信，则需要在R1和H2之间建立SA</p>
</li>
</ol>
<hr>
<h3 id="第6章-Linux系统操作系统安全"><a href="#第6章-Linux系统操作系统安全" class="headerlink" title="第6章 Linux系统操作系统安全"></a>第6章 Linux系统操作系统安全</h3><h4 id="6-1-Linux系统安全威胁"><a href="#6-1-Linux系统安全威胁" class="headerlink" title="6.1 Linux系统安全威胁"></a>6.1 Linux系统安全威胁</h4><p>（四点）<strong>特权程序漏洞、恶意代码、网络监听和数据捕获、软件设置和相互作用</strong></p>
<h4 id="6-2-Linux-本地安全机制"><a href="#6-2-Linux-本地安全机制" class="headerlink" title="6.2 Linux 本地安全机制"></a>6.2 Linux 本地安全机制</h4><ol>
<li><p><strong>用户和组安全</strong></p>
</li>
<li><p><strong>文件系统安全</strong><br> 支持 Owner&#x2F;Group&#x2F;Other 访问控制机制（不灵活）：Owner为客体属主的访问权限(r-w-x)，Group为Owner同组用户对该客体的权限，Other为其他用户对该客体的权限</p>
</li>
<li><p><strong>僵尸进程</strong>：<u>一个进程调用了exit后，并非马上消失，而留下一个僵尸进程（Zombie）的数据结构</u>；僵尸进程<u>放弃了几乎所有内存空间，无任何可执行代码，也不能被调度，仅仅在进程表中保留一个位置</u>，记载该进程的退出状态等信息供其他进程收集。<br> Linux系统中进程数目有限制，<u>存在太多的僵尸进程会占用内存资源，影响系统性能和新进程的产生，甚至导致瘫痪</u></p>
</li>
<li><p><strong>日志管理</strong>：主要功能为<strong>检测</strong> 和 <strong>审计</strong>（连接时间日志、进程日志、错误日志、实用程序日志等）</p>
</li>
</ol>
<h4 id="6-3-Linux-网络安全技术"><a href="#6-3-Linux-网络安全技术" class="headerlink" title="6.3 Linux 网络安全技术"></a>6.3 Linux 网络安全技术</h4><ol>
<li><p>Web 服务安全<br>配置特定的用户运行Apache服务器<br>服务器配置隐藏Apache服务器的版本号<br>访问控制（allow、deny、order指令）<br>使用认证和授权保护<br>设置虚拟目录<br>Apache服务器的安全模块<br>应用SSL技术对网络传输数据进行加密</p>
</li>
<li><p>NetFilter&#x2F;Iptables防火墙</p>
<h5 id="四表五链"><a href="#四表五链" class="headerlink" title="四表五链"></a>四表五链</h5><ul>
<li><strong>四表</strong><br> <code>filter表</code>：负责过滤、防火墙<br> <code>nat表</code>：网络地址转换<br> <code>mangle表</code>：拆解报文、进行修改、重新封装<br> <code>raw表</code>：关闭nat表上启用的连接追踪机制</li>
<li><strong>五链</strong><br> <code>PREROUTING</code> | <code>INPUT</code> | <code>OUTPUT</code> | <code>FORWARD</code>| <code>POSTROUTING</code></li>
<li>对应关系图如下<br> <a href="https://imgse.com/i/p9N9XdO"><img src="https://s1.ax1x.com/2023/05/04/p9N9XdO.jpg" alt="p9N9XdO.jpg" border="0" style="zoom: 50%;" /></a></li>
</ul>
</li>
<li><p>入侵检测：Snort → 嗅探器、数据包记录器、网络入侵检测系统</p>
</li>
<li><p>DNS服务安全：BIND软件</p>
</li>
<li><p>DHCP服务安全</p>
</li>
<li><p>xinetd 网络服务管理程序</p>
</li>
</ol>
<hr>
<h3 id="第7章-数据库系统安全"><a href="#第7章-数据库系统安全" class="headerlink" title="第7章 数据库系统安全"></a>第7章 数据库系统安全</h3><h4 id="7-2-数据库系统的安全需求"><a href="#7-2-数据库系统的安全需求" class="headerlink" title="7.2 数据库系统的安全需求"></a>7.2 数据库系统的安全需求</h4><ul>
<li>机密性：数据值、可能的取值、数据值范围、否定的查询结果</li>
<li>完整性<br>防止对DBMS的非法访问和修改，保护存储的数据、文件的安全性</li>
<li>数据完整性<br>① 物理数据库完整性（整个数据库损毁时保证数据能够物理读取）<br>② 逻辑数据库完整性（保护数据库的结构）<br>③ 元素完整性（数据元素只能由授权用户改变）</li>
<li>一致性：表示同一事实的两个数据应相同，否则就不一致</li>
<li>可审计性<br>① 数据库受破坏后可恢复，维护完整性<br>② 防止用户采用累加的方式，访问受保护的数据<br>③ 审计、跟踪用户访问记录，推理用户意图</li>
</ul>
<ol>
<li>数据库系统的安全防护层次：网络环境 - 宿主操作系统 - 数据库管理系统 - 数据库应用系统</li>
<li><strong>库外加密</strong><br>加解密过程在DBMS外，DBMS只管理密文，有客户端实现<br>优点：对DBMS要求少<br>缺点：效率低，数据加解密需要很大代价</li>
<li><strong>库内加密</strong><br>加密的是数据库中的数据(表、记录、字段等)，在DBMS内核层加密，加解密过程对用户和应用透明，发生在物理层存取数据之前<br>优点：加密粒度可细化、效率较高<br>缺点：DBMS性能降低、密钥管理风险较大</li>
<li><strong>数据库加密局限性</strong><br>不宜以整个数据库文件为单位进行加密<br>条件、索引、表间连接码等字段不能加密</li>
</ol>
<hr>
<h3 id="第8章-信息系统安全测评"><a href="#第8章-信息系统安全测评" class="headerlink" title="第8章 信息系统安全测评"></a>第8章 信息系统安全测评</h3><h4 id="8-7-矩阵法"><a href="#8-7-矩阵法" class="headerlink" title="8.7 矩阵法"></a>8.7 矩阵法</h4><ul>
<li><strong>理念</strong>：由两个要素值确定一个要素值，简单直观</li>
<li><strong>计算过程</strong>：借由 <strong>预设关系表</strong> 计算下列值<ul>
<li><u>由<strong>威胁-脆弱性</strong> 确定 安全事件发生<strong>可能性值 和 可能等级</strong></u></li>
<li><u>由<strong>资产价值-脆弱性</strong> 确定 安全事件的<strong>损失值 和 损失等级</strong></u></li>
<li><u>由<strong>可能性值-损失值</strong> 确定 <strong>风险值 和 风险等级</strong></u></li>
</ul>
</li>
</ul>
<h4 id="8-7-相乘法"><a href="#8-7-相乘法" class="headerlink" title="8.7 相乘法"></a>8.7 相乘法</h4><ul>
<li><strong>理念</strong>：由两个要素值 <strong>乘积开根号</strong> 确定结果要素值 $f &#x3D; \sqrt{x\times y}$</li>
<li><strong>计算过程</strong>：<ul>
<li><u>由<strong>威胁-脆弱性</strong> 确定 安全事件发生<strong>可能性值 和 可能等级</strong></u></li>
<li><u>由<strong>资产价值-脆弱性</strong> 确定 安全事件的<strong>损失值 和 损失等级</strong></u></li>
<li><u>由<strong>可能性值-损失值</strong> 确定 <strong>风险值 和 风险等级</strong></u></li>
</ul>
</li>
</ul>
<hr>
<h3 id="第9章-可信计算"><a href="#第9章-可信计算" class="headerlink" title="第9章 可信计算"></a>第9章 可信计算</h3><ul>
<li><strong>定义</strong>：计算机运算的同时进行安全防护，使操作和过程行为在任意条件下的结果总和预期一样，计算全程可测可控，不被干扰</li>
<li>组成：信任根 → 可信硬件平台 → 可信操作系统 → 可信应用系统</li>
<li><strong>过程</strong>：首先构建一个信任根，再建立一条信任链，从信任根开始到硬件平台，到操作<br>系统，再到应用，一级度量认证一级，一级信任一级，把这种信任扩展到整个计算机系统，并采取防护措施，确保计算资源的完整性和行为的预期性，从而提高计算机系统的可信性</li>
</ul>
<hr>
<h2 id="期末试题（19-20）"><a href="#期末试题（19-20）" class="headerlink" title="期末试题（19-20）"></a>期末试题（19-20）</h2><p>一、判断题（每题 1 分，共 10 分）</p>
<ol>
<li><strong>硬件结构的安全是信息系统安全的基础</strong>。（ $\checkmark$ ） </li>
<li><strong>稳定不变是用于身份认证的生理特征的必要条件，但也是用于安全认证的缺点</strong>。（ $\checkmark$ ） </li>
<li><strong>访问控制中，客体是可以导致信息流动，或使系统状态发生变化的主动实体</strong>。 （ $\times$ ） </li>
<li><strong>在强制访问控制策略下，主体可以改变自己、自己所拥有客体的安全属性</strong>。 （$\times$）</li>
<li><strong>BLP 模型的特点是不上读、不下写</strong>。（ $\checkmark$ ） </li>
<li><strong>安全审计是信息系统安全的最后防线，是访问控制的必要补充</strong>。（ $\checkmark$ ） </li>
<li><strong>隐蔽通道的存在违反了信息系统的安全策略</strong>。（ $\checkmark$ ）</li>
<li><strong>Windows 操作系统中，用户通过身份认证后，登录进程会为其创建一个安全描述符，相当于用户访问系统资源的票证</strong>。（ ） </li>
<li><strong>Linux 系统中，特权程序是可以暂时获得管理员权限并执行一些管理员特权功能的程序</strong>。（$\checkmark$） </li>
<li><strong>数据库库外加密只能以整个数据库文件为单位进行加密</strong>。（$\times$）</li>
</ol>
<p>二、简答题（每题 5 分，共 30 分）</p>
<ol>
<li><p><strong>请列举出 5 种自主访问控制的实现方式</strong>。<br> 答：① <strong>访问口令</strong>：客体提供口令，并分发给主体；主体访问时需要提供访问口令<br> ② <strong>访问控制矩阵</strong>：访问控制的矩阵形式<br> ③ <strong>访问能力表</strong>：主体能访问的客体明细表<br> ④ <strong>访问控制表</strong>(ACL)：能访问该客体的主体明细表<br> ⑤ <strong>授权关系表</strong>：记录所有的主-客体关系<br> ⑥ <strong>属主&#x2F;同组用户&#x2F;其他用户</strong>(OGO)：文件属性附加访问控制信息</p>
</li>
<li><p><strong>简述特权对信息系统安全的危害，那为什么还要提供特权</strong>？<br> 答：① <u>特权会<strong>被窃取、被误用、被滥用</strong></u> ；② 便于系统维护，提高系统可用性</p>
</li>
<li><p><strong>信息系统安全审计有何作用</strong>？<br> 答：① 系统安全的最后防线，是访问控制的必要补充；② 重建事件；③ 监测潜在的入侵并提供相关数据；④ 故障检测 (定位安全问题，帮助故障分析)；④ 发现系统不足；⑤ 联动其他安全机制】</p>
</li>
<li><p><strong>说明数据库安全中，数据完整性的含义</strong>。<br> 答：① 物理数据库完整性（整个数据库损毁时保证数据能够物理读取）② 逻辑数据库完整性（保护数据库的结构）③ 元素完整性（数据元素只能由授权用户改变）</p>
</li>
<li><p><strong>什么是 Linux 系统中的僵尸进程？僵尸进程有何危害</strong>？<br> 答：① 一个进程在调用exit后，不会立刻消失，而是留下的一个僵尸进程数据结构；② 太多的僵尸进程会占用较多的内存，进而影响系统性能和新进程创建，甚至导致系统瘫痪</p>
</li>
<li><p><strong>信息安全风险评估中，什么是残余风险？如何对待残余风险？</strong><br> 答：① 残余风险 是指 <u>采取风险控制措施后系统仍然存在的风险</u>；② 应该<u>评估其是否可以接受。如果可以接受，则予以持续关注，防止其导致安全事件的发生，否则进一步采取更为强劲的风险控制措施。</u></p>
</li>
</ol>
<p>三、分析、设计题（每题 15 分，共 30 分） </p>
<ol>
<li><p><strong>设计一种动态口令身份认证机制，说明口令的使用和验证过程，并分析其可以抵御哪些口令攻击</strong>？<br>答：①<br>② 是一次性口令，可以抵御【重放攻击】</p>
</li>
<li><p><strong>叙述 Windows 操作系统中一种加密文件系统（例如 EFS）的工作原理，分析其安全性</strong>。<br>答：</p>
</li>
</ol>
<p>四、计算题（20 分）<br><strong>假设有 3 个重要资产 A1、A2 和 A3，资产所面临的威胁以及威胁可利用的资产的脆弱性见表 1，括号内是其等级值。要求使用矩阵法计算资产的风险值及风险等级。矩阵的构建和等级划分表如表 2 - 表 7 所示，写出详细的风险计算过程。</strong> </p>
<p>五、论述题（10 分）<br><strong>本次在线考试，利用学生的电脑、手机等设备在学生的家里搭建了在线考试环 境（系统），请利用学习的信息系统安全原理分析，这种在线考试环境能否从技 术上保证学生无法作弊？</strong> </p>
]]></content>
      <categories>
        <category>学习</category>
        <category>信息系统安全</category>
      </categories>
      <tags>
        <tag>信息系统安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu问题及解决方案汇总</title>
    <url>/2023/03/07/Ubuntu-problems-and-solutions/</url>
    <content><![CDATA[<hr>
<p><a href="https://www.cnblogs.com/nuochengze/p/12642282.html">解决Ubuntu连不上网络，输入ifconfig只显示本地环回问题</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能概论复习-上半</title>
    <url>/2023/04/20/Review-of-Introduction-to-Artificial-Intelligence-first-half%20-%20%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[<blockquote>
<p>备考核心：重点掌握核心知识点概念，理解意义及过程。考试不会难，不会考太多概念，重在理解运用，用自己的语言描述 (过程, 概念) 即可。实验相关内容要重点看，报告要认真写。</p>
<p>考试题型：单选题，简答题，解答题，综合分析题<br>解答题包括简单的计算和问答，主要是问答。综合分析是基于已学知识的扩展，考察灵活应用与分析的能力，有一定难度。</p>
</blockquote>
<hr>
<h3 id="第0章-课程内容简介"><a href="#第0章-课程内容简介" class="headerlink" title="第0章 课程内容简介"></a>第0章 课程内容简介</h3><p>以下课程中，黑色是了解内容，<font color="blue">蓝色是重点</font>，<font color="red">红色是重难点</font><br>第1章 绪论<br><font color="blue"> 第2章 知识表示与知识图谱（重点）</font><br>第3章 确定性推理方法<br>第4章 不确定性推理方法<br><font color="blue">第5章 搜索求解策略（重点）</font><br><font color="blue">第6章 智能计算及其应用（重点）</font><br>第7章 专家系统<br><font color="red">补充1 模式识别系统（重难点）</font><br><font color="red">补充2 模型评估方法（重难点）</font><br><font color="red">补充3 机器学习模型类型（重难点）</font><br><font color="red">补充4 线性模型与非线性扩展（重难点）</font><br><font color="red">第8章 人工神经网络及其应用(少部分书上+大部分补充)（重难点）</font><br>第10章 自然语言处理及其应用(NLP)</p>
<h3 id="第1章-绪论"><a href="#第1章-绪论" class="headerlink" title="第1章 绪论"></a>第1章 绪论</h3><ol>
<li><p>人工智能研究的基本内容<br>(1) 知识表示：将人类知识形式化或者模型化（符号表示法、连接机制表示法）<br>(2) 机器感知：以 机器视觉 与 机器听觉 为主<br>(3) 机器思维：对通过感知得来的外部信息及机器内部的各种工作信息进行有目的的处理<br>(4) 机器学习：研究如何使计算机具有类似于人的学习能力，使它能通过学习自动地获取知识<br>(5) 机器行为：计算机的表达能力（说，写，画）</p>
</li>
<li><p>人工智能的主要研究领域<br>自动定理证明、博弈(下棋,打牌,战争等)、模式识别(研究对象描述和分类方法的学科)、机器视觉、机器听觉、机器翻译、智慧医疗、自然语言理解、智能信息检索、数据挖掘与知识发现、专家系统</p>
</li>
</ol>
<hr>
<h3 id="第2章-知识表示与知识图谱"><a href="#第2章-知识表示与知识图谱" class="headerlink" title="第2章 知识表示与知识图谱"></a>第2章 知识表示与知识图谱</h3><h4 id="2-1-知识-与-知识表示-的概念"><a href="#2-1-知识-与-知识表示-的概念" class="headerlink" title="2.1 知识 与 知识表示 的概念"></a>2.1 知识 与 知识表示 的概念</h4><ol>
<li><p>知识<br>在长期的生活及社会实践中、在科学研究及实验中积累起来的对客观世界的认识与经验。知识 也是 把有关信息关联在一起所形成的信息结构。</p>
</li>
<li><p>知识的特性<br> (1) 相对正确性：任何知识都是在一定的条件及环境下产生的，在这种条件及环境下才是正确的。<br> (2) 不确定性：随机性、模糊性、经验、不完全性等因素引起的不确定性。<br> (3) 可表示性 与 可利用性</p>
</li>
<li><p>知识的表示<br> 知识表示是对知识的一种描述，或者说是一组约定，一种计算机可以接受的用于描述知识的数据结构，将人类知识形式化或者模型化。</p>
</li>
</ol>
<h4 id="2-2-一阶谓词逻辑表示法"><a href="#2-2-一阶谓词逻辑表示法" class="headerlink" title="2.2 一阶谓词逻辑表示法"></a>2.2 一阶谓词逻辑表示法</h4><ol>
<li><p>命题<br>  命题是一个非真即假的陈述句。一个命题可以在一种条件下为真，在另一种条件下为假。<br>命题逻辑表示法：无法把它所描述的事物的结构及逻辑特征反映出来，也不能把不同事物间的共同特征表述出来。自然语言难以理解。</p>
</li>
<li><p>谓词 $P(x1x2…xn)$<br>  谓词名 P 表示 个体的性质、状态或个体间的关系<br>个体 $x1, x2,…, xn$ ：某个独立存在的事物或者某个抽象的概念<br>注：个体可以是常量、变量、函数、谓词<br>如  老张是一个教师 $\rightarrow Teacher(Zhang)$；x&gt;3 $\rightarrow Greater(x,3)$；小李的父亲是教室 $\rightarrow Teacher(father(Li))$；Smith在IBM作为工程师工作$\rightarrow Works(engineer(Smith), IBM)$</p>
</li>
<li><p>连接词（连词）<br>  (1) <strong><code>﹁</code> ： 非</strong>；如 $\neg Inroom (She, room2)$<br>  (2) <strong><code>∨</code> ：或</strong>；如 $Plays (LiMing, basketball) ∨ Plays (LiMing, football)$<br>  (3) <strong><code>∧</code> ： 与</strong>；如 $Like (I, music) ∧ Like (I, painting)$<br>  (4) <strong>$\rightarrow$ ：蕴含</strong>，条件；如 $RUNS (Liuhua，fastest)→WINS (Liuhua ，champion)$<br>  (5) <strong><code>⟷</code> ：等价</strong>，当且仅当；如 $P \leftrightarrow Q: P当且仅当Q$<br>  (6)  谓词逻辑真值表</p>
</li>
<li><p>量词<br> (1) **全称量词 $\forall x$**：表示 个体域中任意，所有个体 $x$<br> (2) **存在量词 $\exists x$**：表示 个体域中存在个体 $x$<br> 注1：<u>全称量词和存在量词出现的次序将影响命题的含义</u><br> $(\forall x)(\exists y)(Employee(x) \rightarrow Manager(y, x))$：每个雇员都有一个经理<br> $(\exists y)(\forall x)(Employee(x) \rightarrow Manager(y, x))$：有一个人是所有雇员的经理<br> 注2：<u>量词的辖域</u>：位于量词后面的单个谓词 或 用括号括起来的谓词公式<br> 注3：<u>约束变元与自由变元</u>：辖域内与量词中同名的变元为约束变元，不同名的变元为自由变元</p>
</li>
<li><p>谓词公式<br> (1) 单个谓词是谓词公式（原子谓词公式）<br> (2) 若 $A$ 是谓词公式，则 $\neg A$ 也是谓词公式。<br> (3) 若$A$，$B$都是谓词公式，则 $A \wedge B$，$A \vee B$，$A \rightarrow B$，$A \leftrightarrow B$ 也都是谓词公式。<br> (4) 若$A$是谓词公式，则   $(\forall x)A$，$(\exists x)A$也是谓词公式。<br> 有限次使用 (1) - (4) 生成的公式也是谓词公式。<br> 连接词优先级(由高到低)：$ \neg, \wedge, \vee, \rightarrow, \leftrightarrow$</p>
</li>
</ol>
<h4 id="2-3-产生式表示"><a href="#2-3-产生式表示" class="headerlink" title="2.3 产生式表示"></a>2.3 产生式表示</h4><h4 id="2-4-框架表示法"><a href="#2-4-框架表示法" class="headerlink" title="2.4 框架表示法"></a>2.4 框架表示法</h4><h4 id="2-5-知识图谱"><a href="#2-5-知识图谱" class="headerlink" title="2.5 知识图谱"></a>2.5 知识图谱</h4><h3 id="第5章-搜索求解策略"><a href="#第5章-搜索求解策略" class="headerlink" title="第5章 搜索求解策略"></a>第5章 搜索求解策略</h3><h4 id="5-1-搜索的概念"><a href="#5-1-搜索的概念" class="headerlink" title="5.1 搜索的概念"></a>5.1 搜索的概念</h4><ol>
<li><p><strong>搜索中需要解决的基本问题</strong>：<br>（1）是否一定能找到一个解<br>（2）找到的解是否是最佳解<br>（3）时间与空间复杂性<br>（4）是否终止运行 或 是否会陷入一个死循环</p>
</li>
<li><p>搜索方向：<br>（1）数据驱动：从初始状态出发的正向搜索<br>（2）目的驱动：从目的状态出发的逆向搜索<br>（3）双向搜索：两边开始，在两条路径中间会合</p>
</li>
</ol>
<h4 id="5-2-状态空间的搜索策略"><a href="#5-2-状态空间的搜索策略" class="headerlink" title="5.2 状态空间的搜索策略"></a>5.2 状态空间的搜索策略</h4><p>利用状态变量和操作符好 表示系统问题的有关知识体系<br>状态空间是四元组：$(S,O,S_0,G)$<br>$S$：状态集合<br>$O$：操作算子集合<br>$S_0$：问题的初始状态（$S$的非空子集）<br>$G$：若干具体状态 或 满足某些性质的路径信息描述</p>
<h4 id="5-3-盲目的图搜索"><a href="#5-3-盲目的图搜索" class="headerlink" title="5.3 盲目的图搜索"></a>5.3 盲目的图搜索</h4><ol>
<li><p>回溯策略<br>从初始状态出发，直到它到达目的 或 无解点停止。如果遇到无解点，就回溯到路径上最近的父节点，查看该父节点是否有其他子节点没有拓展，有则沿着其他子节点继续搜索。<br>PS 表：保存当前搜索路径上的状态点（走过的点）<br>NPS 表：包含等待被搜索的状态点（可以走的下一步）<br>NSS 表：保存无解点（直接封死走过的无解的路）</p>
</li>
<li><p>广度优先搜索<br>以接近起始节点的深度为依据，进行逐层扩展的节点搜索方法<br>特点：① 每次选择深度最浅的节点首先扩展，搜索是逐层进行的<br>② 一种高价搜索，但若有解存在，则必能找到<br>open表：保存已经生成但其子状态未被搜索的状态点（可以走的下一步），类似于NPS表<br>close表：保存已被生成拓展过的状态点（已经走过的点），类似于PS+NSS</p>
</li>
<li><p>深度优先搜索<br>首先扩展最新产生的节点, 深度相等的节点按生成次序的盲目搜索。<br>特点：① 扩展最深的节点的结果使得搜索沿着状态空间某条单一的路径从起始节点向下进行下去；仅当搜索到达一个没有后裔的状态时，才考虑另一条替代的路径。<br>② 将扩展的后继节点放在OPEN表的前端<br>③ 防止搜索过程沿着无益的路径扩展下去，一般给出节点扩展的最大深度——深度界限；通过不断放宽限制值，反复搜索直到找到解</p>
</li>
</ol>
<h4 id="5-4-启发式图搜索"><a href="#5-4-启发式图搜索" class="headerlink" title="5.4 启发式图搜索"></a>5.4 启发式图搜索</h4><ol>
<li>启法式策略：重排OPEN表，选择最有希望的节点进行拓展</li>
<li>适用情况：① 可能没有确定解；② 状态空间很大，搜索中拓展的状态数增长特别快</li>
<li>估价函数 $f(n) &#x3D; g(n) + h(n)$，$g(n)$ 为初始点到当前点n的实际代价，$h(n)$ 为当前点n到目标点的最优路径的估计代价，$h(n)$也叫做 启发函数</li>
<li>八数码问题的启发函数：<br> ① 与目标棋局相比，位置不符的数码数目<br> ② 各数码移到目标位置所需移动的距离的总和<br> ③ 对每一对逆转数码对 乘以指定倍数C</li>
</ol>
<h5 id="A-star搜索"><a href="#A-star搜索" class="headerlink" title="A-star搜索"></a>A-star搜索</h5><ol>
<li><p>定义$h^{\ast}(n)$为状态$n$到目的状态的最优路径的代价，则当A搜索算法的启发函数$h(n)$小于等于$h^{\ast}(n)$时，即$h(n)≤h^{\ast}(n)$，则被称为$A^{\ast}$算法</p>
</li>
<li><p>$A^{\ast}$算法启发函数 的 单调性<br>$A^{\ast}$算法不要求一直走最佳路径（$g(n)≤g^{\ast}(n)$），它总能从祖先状态沿着最佳路径到达任一状态<br>$A^{\ast}$算法采用单调性启发函数，可以减少比较代价和调整路径的工作量，从而<strong>减少搜索代价</strong><br>每个节点都有一个启发值H，是对当前点到终点的距离估计，不能大于实际值</p>
</li>
<li><p>$A^{\ast}$算法的<strong>核心步骤</strong><br>① 构造启发式函数$h(n)$，并满足$h(n)≤h^{\ast}(n)$。<br>② 对当前状态计算$f(n)&#x3D;g(n)+h(n)$，从候选项中取f(n)最小值的选项继续迭代。<br>③ 若有相同的最小值选项，取h(n)较小者。若h(n)也相等，则随机选择一个。</p>
</li>
</ol>
<h3 id="第6章-智能计算及其应用"><a href="#第6章-智能计算及其应用" class="headerlink" title="第6章 智能计算及其应用"></a>第6章 智能计算及其应用</h3><ul>
<li>进化算法的设计原则<br>① 适用性原则<br>② 可靠性原则<br>③ 收敛性原则<br>④ 稳定性原则<br>⑤ 生物类比原则</li>
</ul>
<h4 id="6-2-基本遗传算法"><a href="#6-2-基本遗传算法" class="headerlink" title="6.2 基本遗传算法"></a>6.2 基本遗传算法</h4><ol>
<li><p><strong>基本思想</strong>：求解问题时，从多个解开始，然后通过一定的法则进行逐步迭代以产生新的解。</p>
</li>
<li><p><strong>编码</strong><br> (1) 位串编码：主要采用一维染色体编码方法，将问题空间的参数编码为一维排列的染色体<br> a. 二进制编码：用若干二进制数表示一个个体<br> b. Gray编码：将二进制编码通过Gray变换进行转换得到编码<br> (2) 实数编码：不必进行数制转换，直接在解的表现形式上进行遗传操作<br> (3) 多参数级联编码：把每个参数先进行二进制编码得到子串，再把这些子串连成一个完整的染色体，可以有不同的串长度和参数的取值范围</p>
</li>
<li><p><strong>种群</strong><br> (1) <strong>初始种群的产生</strong><br> ① 随机产生群体规模数量的个体<br> ② 随机产生一定数目的个体，从中挑选最好的个体加到初始群体中。该过程不断循环迭代，直到达到了预先确定的种群规模数量<br> ③ 根据问题内容，把握最优解所占空间在整个问题空间中的分布范围，在该范围内设定初始群体。<br> (2) <strong>种群规模的确定</strong><br> 种群规模太小，遗传算法优化性能不好，容易产生局部最优解；种群规模太大计算复杂。根据模式定理，设种群规模为 $M$，则遗传操作可从$M$个个体中生成和检测$M^3$个模式，在再次基础上不断迭代优化，直到找到最优解。</p>
</li>
<li><p><strong>适应度函数</strong><br> (1) 将 <strong>目标函数映射成适应度函数</strong> 的方法<br> 若目标函数为<b>最大化</b>问题，则 $Fit(f(x)) &#x3D; f(x)$<br> 若目标函数为<b>最小化</b>问题，则 $Fit(f(x)) &#x3D; 1&#x2F;f(x) 或 -f(x)$<br> ↓ 将目标函数转换为求最大值的形式，且保证函数值非负<br> 若目标函数为最大化问题，则<br>  $$ f(n)&#x3D; \begin{cases} f(x)-C_{min}, &amp; \text {$f(x)&gt;C_{min}$} \ 0, &amp; \text{其他情况} \end{cases} $$<br> 若目标函数为最小化问题，则<br> $$ f(n)&#x3D; \begin{cases} C_{max}-f(x), &amp; \text {$f(x)&lt;C_{max}$} \ 0, &amp; \text{其他情况} \end{cases} $$<br> 其中 $C_{max}$ 和 $C_{min}$ 分别为 最大值估计和最小值估计<br> (2) **适应度函数的尺度变换**<br> ① 线性变换：$f’&#x3D;af+b$，满足 $f’_{avg}&#x3D;f_{avg}$，$f’_{max}&#x3D;C_{mult}\cdot f_{avg}$<br> 结合图像得到线性参数：<br> $$<br> \begin{array}{cc}<br> a &#x3D; \frac{f_{avg}}{f_{avg}-f_{min}} &amp; b &#x3D; \frac{-f_{min}f_{avg}}{f_{avg}-f_{min}}<br> \end{array}<br> $$<br> <a href="https://imgse.com/i/p9KELKe"><img src="https://s1.ax1x.com/2023/04/25/p9KELKe.png" alt="p9KELKe.png" border="0" style="zoom:50%;" /></a></p>
<p> (2) 幂函数变换：$f’ &#x3D; f^{K}$<br> (3) 指数变换：$f’&#x3D;e^{-af}$</p>
</li>
<li><p><strong>选择（复制）</strong><br> 基于个体的适应度值，分配个体被选择的概率<br> (1) <strong>个体选择概论分配方法</strong><br> ① <strong>适应度比例法</strong>：个体被选择的概率与其适应度值成正比，个体 $i$ 概率为<br> $$<br> p_{si} &#x3D; \frac{f_{i}}{\sum^{M}<em>{i-1}f</em>{i}}<br> $$<br> ② <strong>线性排序</strong>：根据适应值将个体由好到坏排序，个体 $x_{i}$ 分配选择概率，采用转盘方式选择父体<br> $$<br> p_{i} &#x3D; \frac{a-bi}{M(M+1)}<br> $$<br> ③ <strong>非线性选择</strong>：根据适应值将个体由好到坏排序，按下方公式分配选择概率<br> $$<br> p_{i}&#x3D; \begin{cases} q(1-q)^{i-1}, &amp; \text {$i&#x3D;1,2,…,M-1$} \ (1-q)^{M-1}, &amp; \text{$i&#x3D;M$} \end{cases}<br> $$<br> 也可以使用其他非线性函数来分配选择概率，只要满足 <strong>适应度值大的个体被分配的概率大</strong>，且 <strong>所有个体选择概率和为 1</strong> 即可<br> (2) <strong>选择个体方法</strong><br> ① <strong>转盘赌</strong>选择：转盘的角度与选择概率成比例，产生随机数落入转盘进行选择<br> ② <strong>锦标赛</strong>选择：从群体中选择一定数量个体(有放回抽样)，将其中适应度值较高的个体保存到下一代，该过程循环直到下一代个数达到预设数量<br> ③ <strong>随机两两竞争</strong>：每次轮盘赌选择两个个体，选择其中适应度值较高的个体，该过程循环，直到选满为止<br> ④ <strong>最佳个体保存</strong>：把群体中适应度最高的个体不进行交叉变异直接复制到下一代，其他个体进行交叉变异，选择其他的本轮较优个体进入下一代（保证每轮迭代的最优解单调变化，不出现震荡情况）</p>
</li>
<li><p>交叉<br> (1) 一点交叉：在个体串中随机设定一个交叉点，实行交叉时，该点前或后的两个个体的部分结构进行互换，并生成两个新的个体<br> (2) 二点交叉：随机设置两个交叉点，将两个交叉点之间的码串相互交换</p>
</li>
<li><p>变异<br> (1) 位点变异<br> (2) 逆转变异<br> (3) 插入变异<br> (4) 互换变异<br> (5) 移动变异</p>
</li>
</ol>
<h4 id="6-3-遗传算法的一般步骤与特点"><a href="#6-3-遗传算法的一般步骤与特点" class="headerlink" title="6.3 遗传算法的一般步骤与特点"></a>6.3 遗传算法的一般步骤与特点</h4><p>遗传算法的<strong>一般步骤</strong>：</p>
<ol>
<li>创建一个有N个染色体的初始群体 $pop(t&#x3D;1)$，$t$ 表示种群迭代次数</li>
<li>对群体中每一个染色体 $pop_{i}(t)$，计算适应度值 $f_{i} &#x3D; fitness(pop_{i}(t))$</li>
<li>如满足算法终止条件，则停止；否则，以概率 $p_{i} &#x3D; f_{i} &#x2F; \sum^{N}<em>{j&#x3D;1}f</em>{j}$ 从 $pop(t)$ 中选择一些染色体构成新种群：$newpop(t+1)&#x3D;{pop_{j}(t)|j&#x3D;1,2,…,N}$</li>
<li>以预设交叉概率 $p_{cross}$ 进行交叉产生新的染色体，得到同代的新群体 $crosspop(t+1)$</li>
<li>以一个较小的预设变异概率 $p_{m}$ 使染色体的基因发生变异，形成同代的新群体 $mutpop(t+1)$，成为子代的新群体$pop(t+1) &#x3D; mutpop(t+1)$，返回步骤 $2$。</li>
</ol>
<p>流程图如下：<br><a href="https://imgse.com/i/p9KETC6"><img src="https://s1.ax1x.com/2023/04/25/p9KETC6.jpg" alt="p9KETC6.jpg" border="0" style="zoom: 67%;" /></a></p>
<p>遗传算法的<strong>主要特点</strong>：<br>(1) 遗传算法对所求解的优化问题没有太多的数学要求，由于进化特性，搜索过程中不需要问题的内在性质，可直接对结构对象进行操作。<br>(2) 利用随机技术指导对一个被编码的参数空间进行高效率搜索<br>(3) 采用群体搜索策略，易于并行化<br>(4) 只用适应度函数值来评估个体，并再次基础上进行遗传操作，使种群中个体之间进行信息交换<br>(5) 遗传算法能有效地进行概率意义的全局搜索</p>
<h4 id="6-4-遗传算法的改进"><a href="#6-4-遗传算法的改进" class="headerlink" title="6.4 遗传算法的改进"></a>6.4 遗传算法的改进</h4><ol>
<li><p><strong>双倍体遗传算法</strong><br> (1) <strong>基本思想</strong>：双倍体遗传算法采用<strong>显性和隐性两个染色体绑定并同时进化</strong>，提供了一种记忆以前有用的基因块的功能<br> (2) <strong>优点</strong>：双倍体遗传延长了有用基因块的寿命，提高了算法的收敛能力，在变异概率低的情况下能保持一定水平的多样性<br> (3) <strong>算法设计</strong>：<br> a. <strong>编码&#x2F;解码</strong>：一个个体 $i$ 由两个染色体组成(显性、隐性)<br> b. <strong>复制</strong>算子：计算显性染色体的适应度，按照显性染色体的复制概率复制该个体<br> c. <strong>交叉</strong>算子：两个个体的显性染色体和隐性染色体同时交叉<br> d. <strong>变异</strong>算子：个体的显性染色体按正常变异概率，隐性按较大变异概率变异<br> e. <strong>显隐性重排</strong>算子：个体中适应度较大的染色体设为显性，较小的设为隐性<br> 注：多过程&#x2F;复杂算法由一个个计算单元(算子)组成，每个算子对应子过程中的计算逻辑</p>
</li>
<li><p><strong>双种群遗传算法</strong><br> (1) <strong>基本思想</strong>：建立两个遗传算法群体，分别独立进行遗传操作，当每一代同时运行结束以后，<strong>选择两个种群中的随机个体及最优个体进行交换</strong><br> (2) <strong>优点</strong>：可以打破种群内的平衡态达到更高的平衡态，有利于算法跳出局部最优<br> (3) <strong>算法设计</strong>：<br> a. 编码&#x2F;解码    b. 复制算子    c. 交叉算子    d. 变异算子<br> e. <strong>杂交</strong>算子：产生一个随机数$n$，随机选择种群$A$中的$n$个个体与$A$中最优个体，随机选择种群$B$中$n$个个体与$B$中最优个体，交换两者，以打破平衡态</p>
</li>
<li><p><strong>自适应遗传算法</strong><br> (1) <strong>基本思想</strong>：<strong>交叉概率 $p_{c}$ 和变异概率 $p_{m}$ 能跟随适应度值 $f$ 自行改变</strong><br> (2) <strong>算法设计</strong>：<br> ① 当种群各个体适应度趋于一致或者趋于局部最优时，使$P_c$和$P_m$增加，以跳出局部最优；而当群体适应度比较分散时，使$P_c$和$P_m$减少，以利于优良个体的生存<br> ② 对于适应度高于群体平均适应值的个体，选择较低的$P_c$和$P_m$，使得该解得以保护进入下一代；对低于平均适应值的个体，选择较高的$P_c$和$P_m$值，使该解被淘汰。</p>
</li>
</ol>
<h4 id="6-5-遗传算法的应用"><a href="#6-5-遗传算法的应用" class="headerlink" title="6.5 遗传算法的应用"></a>6.5 遗传算法的应用</h4><p>略</p>
<hr>
<h3 id="第7章-专家系统"><a href="#第7章-专家系统" class="headerlink" title="第7章 专家系统"></a>第7章 专家系统</h3><ol>
<li><p>定义：专家系统是一种智能的计算机程序，它运用知识和推理来解决只有专家才能解决的复杂问题</p>
</li>
<li><p>特点：具有专家水平的专业知识，能进行有效的推理，具有启发性、灵活性、透明性、交互性</p>
</li>
<li><p>专家系统与传统程序比较<br> (1) 编程思想不同<br> 传统程序 &#x3D; 数据结构 + 算法<br> 专家系统 &#x3D; 知识 + 推理<br> (2) 存储知识的位置不同<br> 传统程序：关于问题求解的知识隐含于程序中<br> 专家系统：知识单独组成知识库，与推理机分离<br> (3) 处理对象<br> 传统程序：数值计算 和 数据处理<br> 专家系统：符号处理<br> (4) 解释功能<br> 传统程序不具有解释功能，专家系统具有解释功能<br> (5) 答案正确性<br> 传统程序产生正确的答案，专家系统有时会产生错误的答案<br> (6) 系统的体系结构不同</p>
</li>
<li><p>工作原理<br> (1) 专家系统的核心：推理机 + 知识库<br> (2) 网络环境下专家系统结构：知识库和推理机部署在云端服务器<br> (3) 知识获取的过程：抽取知识、知识转换、知识输入、知识检测<br> (4) 知识获取的模式：非自动知识获取、自动知识获取</p>
</li>
</ol>
<hr>
<h3 id="补充1-模式识别系统"><a href="#补充1-模式识别系统" class="headerlink" title="补充1 模式识别系统"></a>补充1 模式识别系统</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ol>
<li><strong>模式</strong>：通过对具体的个别事物进行观测所得到的<strong>具有一定时间或空间分布的信息</strong>，模式不等于事物本身，而是从事物中获得的某些信息</li>
<li><strong>模式识别</strong>：指计算机将某一模式进行分类、聚类或回归分析</li>
<li><strong>模式类</strong>：模式所属的类别 或 同一类中模式的总体</li>
</ol>
<h4 id="系统组成"><a href="#系统组成" class="headerlink" title="系统组成"></a>系统组成</h4><ol>
<li><strong>信息获取</strong>：从具体事物获取原始信息</li>
<li><strong>预处理</strong>：对信息进行分割、增强、复原、去噪等操作</li>
<li><strong>特征提取与选择</strong>：提取最能反映分类本质的特征，同时压缩数据量</li>
<li><strong>分类器的训练&#x2F;设计</strong>：根据训练样本集，在特征空间中确定某种判决规则，该规则的确定是一个反复调整的过程，最后得到的规则即为 分类器</li>
<li><strong>分类决策</strong>：在特征空间中，用设计的分类器将待识别模式归为某一模式类（简单讲，将目标分类）<br>常用 统计学的方法来分析所输入的模式进行识别。</li>
</ol>
<h4 id="主要研究方向"><a href="#主要研究方向" class="headerlink" title="主要研究方向"></a>主要研究方向</h4><ol>
<li>特征选择<br> (1) 去除冗余特征，提高识别性能<br> (2) 减少特征数目，提高识别速度<br> (3) 降低系统成本</li>
<li>监督学习(分类器设计、回归分析)、深度学习、无监督学习(聚类)、弱监督与半监督学习、强化学习</li>
<li>集成学习<br> 如何设计集成方法：① 基分类器  ② 如何集成(融合)</li>
<li>贝叶斯决策：$后验概率&#x3D;\frac{先验\cdot 似然函数}{数据分布}$，理解参考<a href="https://zhuanlan.zhihu.com/p/479174192">贝叶斯公式理解</a></li>
</ol>
<hr>
<h3 id="补充2-模型评估"><a href="#补充2-模型评估" class="headerlink" title="补充2 模型评估"></a>补充2 模型评估</h3><h4 id="机器学习定理"><a href="#机器学习定理" class="headerlink" title="机器学习定理"></a>机器学习定理</h4><ol>
<li>没有天生优越的分类器（没有免费的午餐）</li>
<li>没有天生优越的特征（丑小鸭定理）</li>
<li>在性能得到满足的情况下，模型越简单越好（剃刀定理：避繁就简）</li>
</ol>
<h4 id="经验误差-与-过拟合"><a href="#经验误差-与-过拟合" class="headerlink" title="经验误差 与 过拟合"></a>经验误差 与 过拟合</h4><ol>
<li>经验误差：模型在训练集上的误差</li>
<li>泛化误差：模型在测试集上的误差</li>
</ol>
<h4 id="模型评估方法"><a href="#模型评估方法" class="headerlink" title="模型评估方法"></a>模型评估方法</h4><p>给定一个已知的数据集，将数据集分成训练集$S$ 和 测试集$T$</p>
<ol>
<li><p><strong>留空法</strong>：<br> 直接将数据集划分为两个互斥集合；<br> 训练&#x2F;测试集划分要尽可能保持数据分布的一致性<br> 一般若干次随机划分、重复实验取平均值（避免偶然误差）<br> 训练&#x2F;测试样本比例通常为2:1~4:1</p>
</li>
<li><p><strong>交叉验证法</strong>：<br> 将数据集分层采样划分为k个大小相似的互斥子集，每次用k-1个子集的并集作为训练集，余下的子集作为测试集，最终返回k个测试结果的均值，k最常用的取值是10。<br> <a href="https://imgse.com/i/p9KEXbd"><img src="https://s1.ax1x.com/2023/04/25/p9KEXbd.jpg" alt="p9KEXbd.jpg" border="0" style="zoom: 50%;" /></a><br> 假设数据集D包含m个样本，若令k&#x3D;m，则得到留一法：不受随机样本划分方式的影响；结果往往比较准确；当数据集比较大时，计算开销很高</p>
</li>
<li><p><strong>自助法</strong>：<br> 以自助采样法为基础,对数据集D有放回采样m次得到训练集D’，D \D用做测试集<br> 实际模型与预期模型都使用m个训练样本<br> 约有1&#x2F;3的样本没在训练集中出现，用作测试集√从初始数据集中产生多个不同的训练集，对集成学习有很大的好处<br> 自助法在数据集较小、难以有效划分训练&#x2F;测试集时很有用；由于改变了数据集分布可能引入估计偏差，在数据量足够时，留出法和交叉验证法更常用。</p>
</li>
<li><p>模型评估<strong>三大原则</strong><br> (1) 在性能得到满足的情况下，模型越简单越好<br> (2) 训练集、测试集、验证集的分布应该尽量一致<br> (3) 训练阶段不能以任何理由偷看测试集，包括对测试集的反复评估也不行</p>
</li>
<li><p><strong>训练集、验证集、测试集</strong><br> (1) 训练集 （训练阶段）<br> 用于构建我们的模型，我们的模型在训练集上进行学习，通常在这个阶段我们可以有多种方法进行训练<br> (2) 验证集 （模型挑选阶段）<br> 用于挑选最优模型超参的样本集合：使用验证集可以得到反向传播什么时候结束以及超参怎么设置最合理。主要目的是为了挑选在验证集上表现最好的模型。<br> (3) 测试集 （验证阶段 评估泛化误差）<br> 在我们挑选好验证集上表现最好的模型之后，用于评估该模型泛化能力的数据集。<br> 参考文章：<a href="https://zhuanlan.zhihu.com/p/456037268">在机器学习中验证集和测试集有什么区别</a>；<a href="https://zhuanlan.zhihu.com/p/29133576">测试数据集和验证数据集之间的区别</a></p>
</li>
</ol>
<h4 id="模型性能度量"><a href="#模型性能度量" class="headerlink" title="模型性能度量"></a>模型性能度量</h4><ol>
<li><strong>准确率</strong>：分类结果正确的样本数量 占 总样本数 的比例</li>
<li><strong>错误率</strong>：1 - 准确率</li>
<li>准确率和错误率 要求：每个样本在统计时的权重相同，适用于样本平衡的数据集<br>注：10个稀有样本为正类，990个其余样本为负类，如果全部分类为负类，准确高但没有意义</li>
<li><strong>查准率</strong> $P$：分类结果为正类的样本中，实际结果为正类的比例；$P&#x3D;TP&#x2F;(TP+FP)$</li>
<li>查全率 $R$：实际结果为正类的样本中，实际结果为正类的比例；$R&#x3D;TP&#x2F;(TP+FN)$</li>
<li><strong>平衡点</strong>：$P &#x3D; R$</li>
<li><strong>$F1$度量</strong>：$F1&#x3D;2<em>P</em>R&#x2F;(P+R)$，比平衡点更高效</li>
<li><strong>$F_{\beta}$度量</strong>：$F_{\beta}&#x3D;\frac{(1+\beta^{2})\times P\times R}{(\beta^{2}\times P)+R}$，其中$\beta&#x3D;1$为标准$F1$，$\beta&gt;1$为偏重查全率，$\beta&lt;1$为偏重查准率</li>
</ol>
<hr>
<h3 id="补充3-机器学习模型"><a href="#补充3-机器学习模型" class="headerlink" title="补充3 机器学习模型"></a>补充3 机器学习模型</h3><h4 id="有监督学习-K最近邻-KNN"><a href="#有监督学习-K最近邻-KNN" class="headerlink" title="有监督学习 - K最近邻(KNN)"></a>有监督学习 - K最近邻(KNN)</h4><ol>
<li>基本思想：如果一个待分类样本在特征空间中的k个最相似(即特征空间中K近邻)的样本中的大多数属于某一个类别，则该样本也属于这个类别。</li>
<li>样本间距离的计算方法：欧氏距离、余弦距离、海明距离、曼哈顿距离</li>
<li>K值的选取：K值较小边界复杂，容易过拟合；K值较大会导致模型简单。</li>
<li>优点：简单，易于理解，易于实现，无需参数估计，无需训练；对异常值(个别噪音)不敏感；适合对稀有事件进行分类；适合多分类问题。</li>
<li>缺点：计算量大，内存开销大；可解释性差，不能体现某些样本的重要性；样本不平衡会导致错误；KNN是一种消极学习方法、懒惰算法</li>
</ol>
<h4 id="无监督学习-K均值聚类-K-mean"><a href="#无监督学习-K均值聚类-K-mean" class="headerlink" title="无监督学习 - K均值聚类(K-mean)"></a>无监督学习 - K均值聚类(K-mean)</h4><ol>
<li>k-means算法是一种简单的迭代型聚类算法，采用距离作为相似性指标，从而发现给定数据集中的K个类，且每个类的中心是根据类中所有值的均值得到，每个类用聚类中心来描述。</li>
<li>算法步骤：<br> (1) 选择种子点：选取数据空间中的K个对象作为初始中心，每个对象代表一个聚类中心<br> (2) 样本分类：对于样本中的数据对象，根据它们与这些聚类中心的欧氏距离，按距离最近的准则将它们分到距离它们最近的聚类中心（最相似）所对应的类<br> (3) 更新聚类中心：将每个类别中所有对象所对应的均值作为该类别的新的聚类中心，计算目标函数的值<br> (4) 判断聚类中心和目标函数的值是否发生改变，若不变则输出结果，若改变则返回步骤(2)</li>
</ol>
<h4 id="半监督学习"><a href="#半监督学习" class="headerlink" title="半监督学习"></a>半监督学习</h4><p>只有少量样本带标签，更符合实际需求</p>
<h4 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h4><p>单步没有标签，流程走完时有标签，常用于游戏等人工智能应用中</p>
<h4 id="自监督学习"><a href="#自监督学习" class="headerlink" title="自监督学习"></a>自监督学习</h4><p>略</p>
<hr>
<h3 id="补充4-线性模型与非线性拓展"><a href="#补充4-线性模型与非线性拓展" class="headerlink" title="补充4 线性模型与非线性拓展"></a>补充4 线性模型与非线性拓展</h3><ol>
<li><p>深度神经网络 由 一道线性回归方程推导而成</p>
</li>
<li><p>主要就是介绍激活函数、损失函数、优化器为主，还有深度学习&#x2F;深度神经网络的由来，最后面(60-66)是用分类器来做回归，要是实验三理解的还好 基本可以不看</p>
</li>
</ol>
<hr>
<h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><ul>
<li><a href="https://so.csdn.net/so/search?q=%E8%A5%BF%E7%93%9C%E4%B9%A6%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%AF%BE%E5%90%8E%E7%AD%94%E6%A1%88&t=blog&u=VictoriaW">机器学习(西瓜书) 课后习题答案 - CSDN 含详细代码</a></li>
<li><a href="https://zhuanlan.zhihu.com/c_1013850291887845376">机器学习(西瓜书) 课后习题答案 - 知乎 分类明细</a></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>学习</category>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能概论复习-下半</title>
    <url>/2023/04/20/Review-of-Introduction-to-Artificial-Intelligence-lower-half/</url>
    <content><![CDATA[<blockquote>
<p>备考核心：重点掌握核心知识点概念，理解意义及过程。考试不会难，不会考太多概念，重在理解运用，用自己的语言描述 (过程, 概念) 即可。实验相关内容要重点看，报告要认真写。</p>
<p>考试题型：单选题，简答题，解答题，综合分析题<br>解答题包括简单的计算和问答，主要是问答。综合分析是基于已学知识的扩展，考察灵活应用与分析的能力，有一定难度。</p>
</blockquote>
<hr>
<h3 id="第0章-下半内容简介"><a href="#第0章-下半内容简介" class="headerlink" title="第0章 下半内容简介"></a>第0章 下半内容简介</h3><p>以下课程中，黑色是了解内容，<font color="blue">蓝色是重点</font>，<font color="red">红色是重难点</font><br><font color="red">第8章 人工神经网络及其应用(少部分书上+大部分补充)（重难点）</font><br>第10章 自然语言处理及其应用(NLP)</p>
<hr>
<h3 id="第8章-人工神经网络及其应用"><a href="#第8章-人工神经网络及其应用" class="headerlink" title="第8章 人工神经网络及其应用"></a>第8章 人工神经网络及其应用</h3><h4 id="8-1-神经元与神经网络"><a href="#8-1-神经元与神经网络" class="headerlink" title="8.1 神经元与神经网络"></a>8.1 神经元与神经网络</h4><ol>
<li><p>神经元数学模型<br> <strong>来自第 $i$ 个神经元的输入为 $x_i$</strong><br> <strong>第 $i$ 个神经元的连接权重 $w_i$</strong><br> <strong>阈值：$\theta$</strong><br> <strong>输出：$y &#x3D; f(\sum^{n}_{i&#x3D;1}w_i x_i-\theta)$</strong><br> <a href="https://imgse.com/i/p9KN7GT"><img src="https://s1.ax1x.com/2023/04/26/p9KN7GT.jpg" alt="p9KN7GT.jpg" border="0" style="zoom: 50%;" /></a></p>
</li>
<li><p>激活函数</p>
</li>
<li><p>感知机<br> 参考文章：<a href="https://zhuanlan.zhihu.com/p/74568310">机器学习-单层感知机 - 知乎</a><br> (1) 单层感知机 示例图：（输入层为突触层，输出层为M-P神经元细胞体）<br> <a href="https://imgse.com/i/p9KV98f"><img src="https://s1.ax1x.com/2023/04/25/p9KV98f.jpg" alt="p9KV98f.jpg" border="0" style="zoom:67%;" /></a><br> <a href="https://imgse.com/i/p9KEI4x"><img src="https://s1.ax1x.com/2023/04/25/p9KEI4x.jpg" alt="p9KEI4x.jpg" border="0" style="zoom: 50%;" /></a><br> (2) 学习规则<br> 在单层感知机中，可以将 阈值$\theta$ 视作连接权重 $w_{0}$，其对应输入为 $w_{0}&#x3D;-1$，则可以将权重和阈值学习统一为对权值的学习<br> 对于训练样例 $(x,y)$，若当前感知机输出为 $\hat{y}$，则感知机权重更新规则为：$w_i\leftarrow w_i+\Delta w_i$，$\Delta w_i&#x3D;(l)(y-\hat{y})x_i$，学习率 $l \in (0,1)$<br> 若感知机对训练样例 $(x,y)$ 预测正确，则不发生变化，否则根据错误程度调整权重<br> (3) 单层感知机只能解决二分类的线性可分问题，如：与、或、非问题，不能解决简单的非线性问题，如下图<br> <a href="https://imgse.com/i/p9Ke4Ej"><img src="https://s1.ax1x.com/2023/04/25/p9Ke4Ej.jpg" alt="p9Ke4Ej.jpg" border="0" style="zoom: 50%;" /></a><br> 注：若二分类问题是线性可分的，即存在一个线性超平面能完成分类</p>
</li>
<li><p>神经网络的结构<br> (1) 前馈型（前层输出作为后层输入）<br> (2) 反馈型（后层输出影响前层输入）</p>
</li>
<li><p>神经网络的工作方式<br> (1) 同步：任一时刻网络中所有神经元同时调整状态<br> (2) 异步：任一时刻只有一个神经元调整状态</p>
</li>
<li><p>神经网络的工作过程<br> (1) 从输入端接受输入信号 $ u_j $ $(j&#x3D;1,2,…,n)$<br> (2) 根据连接权值 $w$ 求出所有输入的加权和 $x_i &#x3D; \sum^{n}<em>{j&#x3D;0}w</em>{ij} u_i$<br> (3) 用非线性激励函数进行转换，得到输出 $y_i &#x3D; f(x_i) &#x3D; f(\sum^{n}<em>{j&#x3D;0}w</em>{ij} u_i)$</p>
</li>
<li><p>Hebb学习规则：当某一突触两端的神经元同时处于兴奋状态，那么该连接的权值应该增强</p>
</li>
</ol>
<h4 id="8-2-BP神经网络"><a href="#8-2-BP神经网络" class="headerlink" title="8.2 BP神经网络"></a>8.2 BP神经网络</h4><ol>
<li><p>BP神经网络的机器学习框架<br> (1) 确定网络：前馈型多层神经网络，包含未知参数：连接权值w，偏置b<br> (2) 定义损失函数<br> (3) 参数优化</p>
</li>
<li><p>BP学习算法<br> (1) 连接权值修正量 $\Delta w^{k-1}<em>{ij} &#x3D; -\varepsilon d^{k}</em>{i} y^{k-1}<em>{j}$，（前馈）<br> 隐层连接权重调整公式：计算 $d^{\color{red} k}</em>{i} &#x3D; f’<em>{k}(u^{k}</em>{i} \sum_{l}d^{\color{red} k+1} w^{k}_{li})$ （第$\color{red}k$层用到第$\color{red} k+1$层信息，实现从输出层开始的误差反向传播）</p>
</li>
<li><p>BP算法的设计<br> (1) 隐层数及其神经元数：暂无理论指导<br> (2) 初始权值的设置：以 一个均值为0的随机分布 设置网络的初始权值<br> (3) 训练数据 预处理：尺度变换 或 规格化<br> (4) 后处理过程：当应用神经网络进行分类操作时，通常将输出值编码成所谓的名义变量，具体的值对应类别标号。如1，-1，-1或1，0，0等</p>
</li>
<li><p>BP算法实现流程<br> (1) 初始化：对所有连接权值赋予任意小值<br> (2) 从$N$组输入输出样本中取一个样本：将样本特征向量及其对应类别标签输入到BP网络<br> (3) 正向传播：计算各节点的输出 $y^{k}<em>{i}$<br> (4) 计算 实际输出 与 期望输出 的 误差：$e_i &#x3D; y_i - y^{m}</em>{i}$<br> (5) 反向传播：从输出层开始计算到第一个隐层，按连接权值重调整公式 向减小误差方向调整网络的各个连接权值<br> (6) 取另一个样本重复(2)-(5)步骤，直到N个样本的训练误差达到要求为止</p>
</li>
<li><p>优点<br> ① 很好的逼近特性<br> ② 具有较强的泛化能力<br> ③ 具有较好的容错性</p>
</li>
<li><p>缺点<br> ① 收敛速度慢<br> ② 容易陷入局部极值<br> ③ 难以确定 隐层及其节点数量</p>
</li>
<li><p>应用<br> 用于 计算机模拟生物、人的感知，对模式信息，如图像、文字、语音等进行识别和分类</p>
</li>
</ol>
<h4 id="8-3-离散Hopfield神经网络"><a href="#8-3-离散Hopfield神经网络" class="headerlink" title="8.3 离散Hopfield神经网络"></a>8.3 离散Hopfield神经网络</h4><h2 id="参考文章：反馈神经网络——Hopfield网络-知乎1-Hopfield网络的结构-对于网络的中间层神经元节点，每个神经元的输出-都是-其他神经元的输入，每个神经元的输入都来自于其他神经元（除了输入输出的其他神经元全互连）2-工作过程：由-初态的记忆样本部分信息，通过多次联想记忆循环，达到稳态获得记忆样本。网络计算的过程就是初始输入向量，经过逐次迭代，向吸引子演化的过程。演化的规则是向能量函数减小的方向演化，直到达到稳定状态。3-若从某一时刻开始，网络中所有神经元状态不再改变，则Hopfield网络是稳定的，称一个或若干个稳定的状态为网络的吸引子4-无自反馈的HNN神经元输出：-x-i-k-1-x3D-f-sum-n-j-x3D-1-w-ij-x-j-k-theta-i-text-，其中-w-ii-x3D-0"><a href="#参考文章：反馈神经网络——Hopfield网络-知乎1-Hopfield网络的结构-对于网络的中间层神经元节点，每个神经元的输出-都是-其他神经元的输入，每个神经元的输入都来自于其他神经元（除了输入输出的其他神经元全互连）2-工作过程：由-初态的记忆样本部分信息，通过多次联想记忆循环，达到稳态获得记忆样本。网络计算的过程就是初始输入向量，经过逐次迭代，向吸引子演化的过程。演化的规则是向能量函数减小的方向演化，直到达到稳定状态。3-若从某一时刻开始，网络中所有神经元状态不再改变，则Hopfield网络是稳定的，称一个或若干个稳定的状态为网络的吸引子4-无自反馈的HNN神经元输出：-x-i-k-1-x3D-f-sum-n-j-x3D-1-w-ij-x-j-k-theta-i-text-，其中-w-ii-x3D-0" class="headerlink" title="参考文章：反馈神经网络——Hopfield网络 - 知乎1. Hopfield网络的结构    对于网络的中间层神经元节点，每个神经元的输出 都是 其他神经元的输入，每个神经元的输入都来自于其他神经元（除了输入输出的其他神经元全互连）2. 工作过程：由 初态的记忆样本部分信息，通过多次联想记忆循环，达到稳态获得记忆样本。网络计算的过程就是初始输入向量，经过逐次迭代，向吸引子演化的过程。演化的规则是向能量函数减小的方向演化，直到达到稳定状态。3. 若从某一时刻开始，网络中所有神经元状态不再改变，则Hopfield网络是稳定的，称一个或若干个稳定的状态为网络的吸引子4. 无自反馈的HNN神经元输出：$$x_{i}(k+1)&#x3D;f(\sum^{n}{j&#x3D;1}w{ij}x_{j}(k)-\theta_{i} \text {，其中$w_{ii}&#x3D;0$}$$"></a>参考文章：<a href="https://zhuanlan.zhihu.com/p/457810569">反馈神经网络——Hopfield网络 - 知乎</a><br>1. Hopfield网络的结构<br>    对于网络的中间层神经元节点，每个神经元的输出 都是 其他神经元的输入，每个神经元的输入都来自于其他神经元（<strong>除了输入输出的其他神经元全互连</strong>）<br>2. 工作过程：由 初态的记忆样本部分信息，通过多次联想记忆循环，达到稳态获得记忆样本。网络计算的过程就是初始输入向量，经过逐次迭代，向吸引子演化的过程。演化的规则是向能量函数减小的方向演化，直到达到稳定状态。<br>3. 若从某一时刻开始，网络中所有神经元状态不再改变，则<strong>Hopfield网络是稳定的</strong>，称一个或若干个稳定的状态为网络的<strong>吸引子</strong><br>4. 无自反馈的HNN神经元输出：<br>$$<br>x_{i}(k+1)&#x3D;f(\sum^{n}<em>{j&#x3D;1}w</em>{ij}x_{j}(k)-\theta_{i} \text {，其中$w_{ii}&#x3D;0$}<br>$$</h2><p>$$<br>\begin{array}{cc}<br>        f(s)&#x3D; \begin{cases} 1, &amp; \text {$s \geq 0$} \ -1, &amp; \text{$s&lt;0$} \end{cases} &amp; 或 &amp; f(s)&#x3D; \begin{cases} 1, &amp; \text {$s \geq 0$} \ 0, &amp; \text{$s&lt;0$} \end{cases}<br>    \end{array}<br>$$</p>
<ol start="5">
<li>应用示例<br><a href="https://imgse.com/i/p9MF0ot"><img src="https://s1.ax1x.com/2023/04/26/p9MF0ot.jpg" alt="p9MF0ot.jpg" border="0" style="zoom:50%;" /></a><br>步骤①：设计离散Hopfield神经网络结构(DHNN)，如下图所示<br><a href="https://imgse.com/i/p9MFDFP"><img src="https://s1.ax1x.com/2023/04/26/p9MFDFP.jpg" alt="p9MFDFP.jpg" border="0" style="zoom: 50%;" /></a><br>样本：$x^{(1)}&#x3D;[1,0,1]^{T}(桔子),x^{(2)}&#x3D;[0,1,0]^{T}(苹果)$，$\theta_{i}&#x3D;0(i&#x3D;1,2,3)$<br>步骤②：设计连接权矩阵<br><a href="https://imgse.com/i/p9Mk9SO"><img src="https://s1.ax1x.com/2023/04/26/p9Mk9SO.jpg" alt="p9Mk9SO.jpg" border="0" style="zoom:50%;" /></a><br>经过上面计算得到权重矩阵<br><a href="https://imgse.com/i/p9MkYt0"><img src="https://s1.ax1x.com/2023/04/26/p9MkYt0.jpg" alt="p9MkYt0.jpg" border="0" style="zoom:50%;" /></a><br>步骤③：测试<br>测试用例：$[1, 1, 1]^{T}$，即初始状态 $x_{1}(0)&#x3D;1, x_{2}(0)&#x3D;1, x_{3}(0)&#x3D;1$<br>确定调整次序为：$2 \rightarrow 1 \rightarrow 3$，开始调整<br>(<font color="purple">1</font>) 当前调整 ${\color{red} 2} \rightarrow 1 \rightarrow 3$，$k&#x3D;{\color{green}0}$，$x_{1}({\color{green}0})&#x3D;1，x_{2}({\color{green}0})&#x3D;1，x_{3}({\color{green}0})&#x3D;1$<br>$$<br>x_{\color{red} 2}({\color{purple} 1})&#x3D;f(\sum^{3}<em>{j&#x3D;1}w</em></li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>常用数据库的异同</title>
    <url>/2023/03/14/SQL/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/qq_32392597/article/details/107645823">ISAM、MyISAM、InnoDB、ACID详解</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/362598819">MySQL 与 PostgreSQL 比较</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>PostgreSQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Studio安装教程及踩坑</title>
    <url>/2023/02/27/Ubuntu1604VirtualBox%20install/</url>
    <content><![CDATA[<h2 id="0-准备"><a href="#0-准备" class="headerlink" title="0. 准备"></a>0. 准备</h2><p><a href="https://blog.csdn.net/scene_2015/article/details/83025750">VirtualBox上Ubuntu16.04安装教程</a></p>
<p><a href="https://blog.csdn.net/danshiming/article/details/117997558">在VirtualBox中与主机共享文件夹</a></p>
<p><a href="https://blog.csdn.net/weixin_47158773/article/details/120984124">VirtualBox扩展虚拟机Ubuntu的硬盘容量</a></p>
<hr>
<h2 id="1-安装hadoop"><a href="#1-安装hadoop" class="headerlink" title="1. 安装hadoop"></a>1. 安装hadoop</h2><p><a href="https://blog.csdn.net/jokerys/article/details/108701599">Ubuntu下Hadoop的安装教程</a></p>
<hr>
<h2 id="2-遇到问题及解决"><a href="#2-遇到问题及解决" class="headerlink" title="2. 遇到问题及解决"></a>2. 遇到问题及解决</h2><p><a href="https://blog.csdn.net/yw00yw/article/details/105397976">Android Studio 解决 Error : module not specified错误</a><br><a href="https://blog.csdn.net/weixin_42473228/article/details/118542634">Could not install Gradle distribution from “https://services.gradle.org/..."</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>面向 C++ 开发的 Visual Studio 2019 安装教程</title>
    <url>/2021/09/30/Visual-Studio-2019-installation-tutorial-for-C++-development/</url>
    <content><![CDATA[<h2 id="Visual-Studio-2019-的下载与安装"><a href="#Visual-Studio-2019-的下载与安装" class="headerlink" title="Visual Studio 2019 的下载与安装"></a>Visual Studio 2019 的下载与安装</h2><p>注：<strong>过程中需要登陆 Microsoft 账户，正常登陆即可</strong></p>
<ol>
<li>到<a href="https://visualstudio.microsoft.com/zh-hans/vs/"> Visual Studio官网 </a>下载<strong>Visual Studio 2019 community</strong> ，点击后会自动下载<img src="https://img-blog.csdnimg.cn/8fd6889f973f4ec7b4b7a2dc9ecbd66a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAU2FmZm9ybg==,size_20,color_FFFFFF,t_70,g_se,x_16" style="zoom: 67%;" /></li>
<li>打开下载器，进入Visual Studio 2019 安装界面<img src="https://img-blog.csdnimg.cn/759ee143f64843b8a42f296ffc6fd45a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAU2FmZm9ybg==,size_20,color_FFFFFF,t_70,g_se,x_16" style="zoom: 67%;" /></li>
<li>设置安装选项。使用C++语言的开发者勾选<code>使用 C++ 的桌面开发</code>，使用Python语言的开发者勾选 <code> Python 开发</code><img src="https://img-blog.csdnimg.cn/e29fece6300f4d57a32c169ab147c006.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAU2FmZm9ybg==,size_20,color_FFFFFF,t_70,g_se,x_16" style="zoom: 67%;" /></li>
<li>在右侧的 <strong><code>使用C++的桌面开发</code></strong> 的子目录 <code>可选</code> 和 <strong><code>单个组件</code></strong> 中勾选下图所示组件：<img src="https://img-blog.csdnimg.cn/574083ab13e247888a73f092059f8f99.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAU2FmZm9ybg==,size_15,color_FFFFFF,t_70,g_se,x_16" style="zoom: 80%;" /></li>
<li><strong>语言包</strong>选择 <code>中文(简体)</code> 或 <code>英文</code><img src="https://img-blog.csdnimg.cn/509c2fe2ffe24001937868ec1bb9d663.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAU2FmZm9ybg==,size_20,color_FFFFFF,t_70,g_se,x_16" style="zoom: 67%;" /></li>
<li><strong>安装位置</strong>最好选择在 <strong>C盘以外 的其他地方</strong>，建议是在D盘或其他盘新建一个名为<code>Visual Studio 2019</code>的文件夹，在该文件夹中新建一个名为<code>community</code>的文件夹，将该文件夹设定为VS2019的安装目录；下载缓存和共享组件、工具、SDK等也建议都修改其默认目录<img src="https://img-blog.csdnimg.cn/4f06ba9b525241f4baba4dc64243fb38.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAU2FmZm9ybg==,size_20,color_FFFFFF,t_70,g_se,x_16" style="zoom: 67%;" /></li>
<li>点击 <b><code>安装</code></b>，期间不要断网，全部下载安装完毕后，即可使用VS2019进行C++开发</li>
<li>如果你按照以上教程安装成功后，在<code>我的电脑 -&gt; D:\Visual Studio 2019\Community\Common7\IDE</code>目录下，找到名为 <code>devenv.exe</code> 应用程序，右键添加到桌面快捷方式 <em>（再给快捷方式改个名字就更好了）</em><img src="https://img-blog.csdnimg.cn/cf43915e615a488789d02b752862d7ff.png" style="zoom: 80%;" /></li>
</ol>
<h2 id="Visual-Studio-2019-的使用"><a href="#Visual-Studio-2019-的使用" class="headerlink" title="Visual Studio 2019 的使用"></a>Visual Studio 2019 的使用</h2><ol>
<li>打开 Visual Studio 2019 的界面，选择 <strong><code>创建新项目</code></strong> 或者 **<code>继续但无需代码</code>**（选择后者VS2019将作为文件编辑器使用）<img src="https://img-blog.csdnimg.cn/ac9e74a0e5424be7b6353713c768c97e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAU2FmZm9ybg==,size_20,color_FFFFFF,t_70,g_se,x_16" style="zoom: 67%;" /></li>
<li>选择 <strong><code>创建空项目</code></strong> 后，选择<code>控制台应用</code> 或者 <code>空项目</code>，前者会创建默认有打印Hello World的代码，接着点击 <strong><code>下一步</code></strong><img src="https://img-blog.csdnimg.cn/92cadf51e01a4d90b98bac863d311e7b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAU2FmZm9ybg==,size_20,color_FFFFFF,t_70,g_se,x_16" style="zoom:67%;" /></li>
<li>填写创建的<strong>项目名称</strong>，可以修改<strong>项目的存储位置</strong>（后面会介绍修改默认存储地址的方法），接着点击 **<code>创建</code>**即可<img src="https://img-blog.csdnimg.cn/d9ef172e1f0e49f49f32c99b904e33e8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAU2FmZm9ybg==,size_20,color_FFFFFF,t_70,g_se,x_16" style="zoom:67%;" />
<img src="https://img-blog.csdnimg.cn/64b4434941a64723925bac5ccd3218ab.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAU2FmZm9ybg==,size_20,color_FFFFFF,t_70,g_se,x_16" style="zoom:67%;" /></li>
</ol>
<hr>
<ol start="4">
<li>如果选择 **<code>继续但无需代码</code>**，进入编辑器界面，选择最上方工具栏的 <strong><code>文件 -&gt; 新建 -&gt; 文件</code></strong><img src="https://img-blog.csdnimg.cn/425f4fd566e447d8ab2cf056c2108406.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAU2FmZm9ybg==,size_20,color_FFFFFF,t_70,g_se,x_16" style="zoom:67%;" /></li>
<li>在侧栏中选择 <code>Visual C++</code>，中间栏选择 <code>C++ 文件(.cpp)</code> ，点击<code>打开</code>即可创建新的空文件<img src="https://img-blog.csdnimg.cn/3991e0c16e864090b6dc9b9a63149768.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAU2FmZm9ybg==,size_20,color_FFFFFF,t_70,g_se,x_16" style="zoom:67%;" /></li>
<li>在中央的<strong>代码编辑区</strong>填写完代码后，点击左上角的<code>保存</code>按键或按下<code>Ctrl + S</code>保存文件；建议将代码文件放在 <strong>Visual Studio 2019 安装目录中的自定义文件夹</strong>里，或者放在 <strong>非C盘的集中的代码存放位置</strong>，便于以后查找<img src="https://img-blog.csdnimg.cn/2a699d16b84c45f3a23cfbe93dbcf020.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAU2FmZm9ybg==,size_20,color_FFFFFF,t_70,g_se,x_16" style="zoom:67%;" /></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Visual Studio</tag>
      </tags>
  </entry>
  <entry>
    <title>Win10安装汇编环境masm x64</title>
    <url>/2022/03/14/Win10-64bit-Installation-Assembly-Environment-masm/</url>
    <content><![CDATA[<p>本文转载自 <a href="https://www.cnblogs.com/dgwblog/p/11865850.html">Win10(64位)安装汇编环境(MASM) - 博客园</a>，亲自尝试之后决定转载，并在原文基础上补充了一些 <strong>操作细节</strong>，也<strong>删去了少许内容</strong>，鼓励读者看一遍<a href="https://www.cnblogs.com/dgwblog/p/11865850.html">原文</a>。</p>
<hr>
<ol start="0">
<li>需要的文件：<a href="https://files-cdn.cnblogs.com/files/dgwblog/DOSBox.rar">DOSBox.rar</a></li>
</ol>
<hr>
<ol>
<li><p>将压缩包解压到某一目录下，运行 DOSBox.exe</p>
<img src="https://img-blog.csdnimg.cn/55ae9806ba264c2e83a5df57783b95e8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAU2FmZm9ybg==,size_20,color_FFFFFF,t_70,g_se,x_16" style="zoom: 67%;" /></li>
<li><p>在弹出的小窗口中 输入命令 <code>mount c: d://DOSBox/masm</code>，将指定目录下的 masm 部署到 c: 目录下 <em>（如果你想安装在D盘目录下，<code>d://DOSBox/masm </code>是 DOSBox 下 masm文件夹的目录地址）</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mount c: d://DOSBox/masm</span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/3ff2f91d01e440b3863e59915afd432b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAU2FmZm9ybg==,size_20,color_FFFFFF,t_70,g_se,x_16" style="zoom:80%;" />
</li>
<li><p>查看是否部署成功</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c:</span><br><span class="line"><span class="built_in">dir</span></span><br></pre></td></tr></table></figure>
<p>运行结果如下：<br><img src="https://img-blog.csdnimg.cn/c19cbc5dd00d47079f0bec30676d1f56.png" style="zoom: 80%;" /></p>
<ol start="4">
<li>在 masm 目录下创建 test.asm 文件，编写 helloworld 程序（可以先在 txt 文件中编写，再改文件名和后缀名），保存文件，关闭</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">.model small</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">    strs DB <span class="string">&#x27;hello world&#x27;</span>,<span class="number">13</span>,<span class="number">10</span>,<span class="string">&#x27;$&#x27;</span></span><br><span class="line">.code</span><br><span class="line">start:</span><br><span class="line">    mov ax,@data</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov dx,offset strs</span><br><span class="line">    mov ah,09h</span><br><span class="line">    <span class="built_in">int</span> 21h</span><br><span class="line">    mov ah,4ch</span><br><span class="line">    <span class="built_in">int</span> 21h</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/c79972c356ab4c4e8bf19d87e6b8f0fc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAU2FmZm9ybg==,size_19,color_FFFFFF,t_70,g_se,x_16" style="zoom:80%;" />

<ol start="5">
<li>（假设你之前解压在D盘目录下）再利用 <code>mount c: d://DOSBox/masm</code> 命令 将 test.asm 文件复制到 c: 目录下，利用 <code>dir</code> 命令 检查是否成功 <em>（即 c: 目录下出现 <code>test.asm</code> 文件）</em><img src="https://img-blog.csdnimg.cn/845b2e08b170456e8eefc04a5828055e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAU2FmZm9ybg==,size_14,color_FFFFFF,t_70,g_se,x_16" style="zoom:80%;" />
PS：如果未成功可以把 DOSBox程序关闭，再重新打开（doge</li>
<li>输入汇编命令 <code>masm test.asm</code>，遇到选项默认回车即可<img src="https://img-blog.csdnimg.cn/7e52953540d84130b80472f63bcadbdd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAU2FmZm9ybg==,size_20,color_FFFFFF,t_70,g_se,x_16" style="zoom:80%;" />
可以发现目录下出现了 `test.obj` 文件
<img src="https://img-blog.csdnimg.cn/adf9efd443454715812869b1bdacb4ed.png" style="zoom:80%;" /></li>
<li>运行链接命令 <code>link test.obj</code>，遇到选项默认回车，目录下产生 <code>test.exe</code> 文件；<strong>Link : warning xxxxx: no stack segment 是在提示编程人员程序中没有堆栈段，并非程序或配置出现错误</strong><img src="https://img-blog.csdnimg.cn/226f478f4e2d4f898edd60e8a084dd12.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAU2FmZm9ybg==,size_20,color_FFFFFF,t_70,g_se,x_16" style="zoom:80%;" /></li>
<li>输入运行命令 <code>test.exe</code> 运行exe文件，显示 hello world 即成功<br><img src="https://img-blog.csdnimg.cn/fc4274d37d59444aa99155277d84241c.png"></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Assembly</tag>
        <tag>DOSBox</tag>
        <tag>MASM</tag>
      </tags>
  </entry>
  <entry>
    <title>Win10利用VMware安装StarVCenter(单机版)</title>
    <url>/2022/09/14/Win10-uses-VMware-to-install-StarVCenter-stand-alone/</url>
    <content><![CDATA[<h2 id="0-文件准备"><a href="#0-文件准备" class="headerlink" title="0 文件准备"></a>0 文件准备</h2><p><a href="http://download.starvcs.com/download/StarVCenter/StarVCenter_Community_Download/V4.2.20/starve4-x86_64-StarVCenter-mini-4.2.20.iso">starve4-x86_64-StarVCenter-mini-4.2.20.iso</a><br><a href="https://www.vmware.com/go/getworkstation-win">VMware Workstation 16 Pro</a></p>
<h2 id="1-创建虚拟机"><a href="#1-创建虚拟机" class="headerlink" title="1 创建虚拟机"></a>1 创建虚拟机</h2><ol start="0">
<li><p>安装 VMware Workstation，序列号: ZF3R0-FHED2-M80TY-8QYGC-NPKYF；YF390-0HF8P-M81RQ-2DXQE-M2UT6；ZF71R-DMX85-08DQY-8YMNC-PPHV8.</p>
</li>
<li><p>创建新的虚拟机</p>
<div align="center"> 
 <img src="https://img-blog.csdnimg.cn/91556430407c432ca90c7be931897a15.png" width = "40%"/>
</div>
</li>
<li><p>典型（推荐）（T）</p>
</li>
</ol>
  <div align="center"> 
      <img src="https://img-blog.csdnimg.cn/2893b563b8d9409a88c73ddd969ab3b7.png" width = "40%"/>
  </div>

<ol start="4">
<li><p>安装程序光盘映像文件(iso)(M) -&gt;选择 iso文件</p>
  <div align="center"> 
   <img src="https://img-blog.csdnimg.cn/4e20e699630d4cea8ba8fc295e23d265.png" width = "40%"/>
  </div>

</li>
<li><p>客户机操作系统  -&gt; linux；<br> 版本 -&gt; CentOS 5 和更早版本64位</p>
 <div align="center"> 
 <img src="https://img-blog.csdnimg.cn/542ae2ef42724776bbbbca383936e0d0.png" width = "40%"/>
   </div>
 </li>
<li><p>虚拟机名称 -&gt; 自己设置；<br> 位置 -&gt; 最好不要放在C盘</p>
 <div align="center"> 
   <img src="https://img-blog.csdnimg.cn/8b7af3ec31734b56ad8dee447c4ca7ec.png" width = "40%"/>
 </div>
</li>
<li><p>最大磁盘大小 -&gt; 建议32~64G；将虚拟磁盘 存储&#x2F;拆分 应该都行</p>
  <div align="center"> 
   <img src="https://img-blog.csdnimg.cn/d6e5d3a864f5412c9af8dd9423b2a280.png" width = "40%"/>
  </div>
</li>
<li><p>自定义硬件</p>
  <div align="center"> 
   <img src="https://img-blog.csdnimg.cn/e9a3e1c3ac1745e4a9119003c48f040b.png" width = "50%"/>
  </div></li>
</ol>
<ul>
<li>内存 8G（8192 MB）  <div align="center"> 
  <img src="https://img-blog.csdnimg.cn/0cec64e96b4b4acfbf48268f4ce412ec.png" width = "50%"/>
  </div></li>
<li>处理器数量：2处理器 * 2核；开启 虚拟化  <div align="center"> 
  <img src="https://img-blog.csdnimg.cn/d1e3f8e882d244d38481cf3b18ed0418.png" width = "50%"/>
  </div></li>
<li>网络连接 → 桥接模式 → 复制网络连接状态  <div align="center"> 
  <img src="https://img-blog.csdnimg.cn/06eda98299e04c4b95a4a3c60817da39.png" width = "50%"/>
  </div></li>
</ul>
<ol start="9">
<li>点击 <strong>完成</strong> 即可</li>
</ol>
<h2 id="2-运行虚拟机"><a href="#2-运行虚拟机" class="headerlink" title="2 运行虚拟机"></a>2 运行虚拟机</h2><ol>
<li><p>开启此虚拟机</p>
<div align="center"> 
   <img src="https://img-blog.csdnimg.cn/29d25f6972ed442aacabb0e1169f0271.png" 
   width = "50%"/>
  </div></li>
<li><p>选择”Test this media &amp; install StarVE 4”</p>
<div align="center"> 
   <img src="https://img-blog.csdnimg.cn/2ac123b2795b4e5e8776c34e53889c58.png" 
   width = "50%"/>
  </div></li>
<li><p>设置 节点模式（&#x3D;&#x3D;Basic node&#x3D;&#x3D;） 和 硬盘选项（&#x3D;&#x3D;硬盘的对号打勾&#x3D;&#x3D;）</p>
<div align="center"> 
   <img src="https://img-blog.csdnimg.cn/85131a03b51b4262a97130865ea31166.png" 
   width = "50%"/>
  </div>
</li>
<li><p>设置网络</p>
<div align="center"> 
   <img src="https://img-blog.csdnimg.cn/4091b6b8f1c8421f9dbf03a91848d4d2.png" 
   width = "50%"/>
  </div>
**IPv4 Settings** -> Method: **Manual** → **Add**（==Address填 不与物理主机IP相同的 “任意无关IP”；Netmask 和 Gateway为 Deploy 节点的物理主机的子网掩码【255.255.255.0】 和 默认网关【192.168.43.1】（需要取证一下）==）
<div align="center"> 
   <img src="https://img-blog.csdnimg.cn/693ad5c91df443c0905207d2f24dffec.png" 
   width = "50%"/>
  </div>
Save后，改个主机字（有自己特色的），再点Apply
<div align="center"> 
   <img src="https://img-blog.csdnimg.cn/cac9d2c3bc184137ad7e15124cf6467c.png" 
   width = "50%"/>
  </div></li>
<li><p>点击左上角 <code>Done</code>，回到首页，点击开始安装</p>
</li>
<li><p>设置 root密码 和 用户账户</p>
<div align="center"> 
   <img src="https://img-blog.csdnimg.cn/df964438db2544588d2ff62a4066baab.png" 
   width = "50%"/>
  </div></li>
<li><p>安装完成后 reboot</p>
</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Cloud Computing</tag>
        <tag>VMware</tag>
        <tag>StarVCenter</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows相关问题及解决方案</title>
    <url>/2023/03/16/Windows-related-issues-and-solutions/</url>
    <content><![CDATA[<p><a href="https://www.win7zhijia.cn/win10jc/win10_51994.html">删除文件提示你需要来自system的权限才能对此文件夹进行更改(win7,win10,win11通用)</a></p>
<p><a href="https://www.disktool.cn/jiaocheng/extend-c-drive.html">在Windows中扩大C盘的4种方法</a></p>
<p><a href="https://blog.csdn.net/lingbomanbu628/article/details/121198056">在文件夹页面检索文件的内容</a></p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客现存问题及可能的解决方案</title>
    <url>/2023/03/17/%60problem/</url>
    <content><![CDATA[<ol>
<li><p>切换刷新网页时，音乐播放器会刷新重置<br>​	solution: <a href="https://ariescat.top/2021/01/25/Pjax%E5%8A%A0%E6%8C%81APlayer-%E9%9F%B3%E4%B9%90%E6%97%A0%E9%97%B4%E6%96%AD/">Pjax加持APlayer，音乐无间断 Ariescat Blog</a></p>
</li>
<li><p>Artitalk说说心情发布<br>​	solution: <a href="https://blog.csdn.net/cungudafa/article/details/106224223">Artitalk说说心情发布页面（个性定制）</a></p>
</li>
<li><p>Valine 评论的进一步优化<br>​	solution：<a href="https://cungudafa.gitee.io/post/8202.html">Valine-1.4.4 个性制定（表情包、qq头像、UI样式）</a><br>​	<a href="https://blog.csdn.net/cungudafa/article/details/104281764">Valine - 一款快速、简洁且高效的无后端评论系统</a><br>​	<a href="https://blog.csdn.net/weixin_39531549/article/details/86651038">Valine – 一款极简的评论系统_AYXYJ的博客</a><br>​	<a href="http://www.luckysec.cn/posts/1d6f1579.html#toc-heading-5">Matery之Valine评论优化 | LuckySec</a><br>​	<a href="https://blog.justlovesmile.top/posts/27831.html">Hexo博客 | 如何让你的valine更好看 | Justlovesmile’s BLOG</a></p>
</li>
<li><p>搭建个人图床<br>​	solution：<a href="https://blog.csdn.net/qq_40531408/article/details/126070098">基于jsDelivr+GitHub的免费CDN</a> 他的其他博客也不错</p>
</li>
<li><p>Latex数学公式？？（急）</p>
</li>
</ol>
<hr>
<p>思考？（小心自我精神折磨）<a href="https://www.zhihu.com/question/438831051/answer/1891961165">如何废掉一个大学生？ - 知乎 (zhihu.com)</a></p>
<hr>
<h3 id="优化部分"><a href="#优化部分" class="headerlink" title="优化部分"></a>优化部分</h3><h4 id="网页图标"><a href="#网页图标" class="headerlink" title="网页图标"></a>网页图标</h4><p>SVG素材库：<a href="https://www.iconfont.cn/collections/detail?spm=a313x.7781069.0.da5a778a4&cid=43742">iconfont-阿里巴巴矢量图标库 - Food</a>；<a href="https://www.bilibili.com/read/cv17346758">其他icon网站呢？</a></p>
<p>参考：<a href="https://blog.csdn.net/qq_39181839/article/details/109477357">Hexo更换网页图标</a></p>
<p>Ayer主题原本的网页图标在<code>./themes/ayer/source/favicon.ico</code><br>修改 <code>./themes/ayer/_config.yml</code>中的<code>favicon</code>字段</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 网站图标</span></span><br><span class="line"><span class="attr">favicon:</span> <span class="string">/favicon.ico</span></span><br></pre></td></tr></table></figure>

<h4 id="友链"><a href="#友链" class="headerlink" title="友链"></a>友链</h4><p>在<code>./source/links</code>下新建文件夹<code>image</code>用于存放图片，修改<code>index.md</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;links.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;allLinks&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/图片1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片描述1&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;友情链接地址1&quot;</span>&gt;</span>博客名1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image/图片2.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片描述2&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;友情链接地址2&quot;</span>&gt;</span>博客名2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>新建样式文件 <code>links.css</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.allLinks</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: -webkit-flex; <span class="comment">/* Safari */</span></span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.allLinks</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">    <span class="attribute">display</span>: inline-flex;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">1rem</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20rem</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">8rem</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">3rem</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>:<span class="number">2rem</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden; <span class="comment">/*超出边界部分隐藏*/</span></span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ffffff</span>;  <span class="comment">/*卡片背景颜色*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.allLinks</span> <span class="selector-tag">li</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">6rem</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">6rem</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">1rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.allLinks</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">12rem</span>;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">10%</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.7rem</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&quot;Helvetica Neue&quot;</span>, Helvetica, <span class="string">&quot;PingFang SC&quot;</span>, <span class="string">&quot;Hiragino Sans GB&quot;</span>, <span class="string">&quot;Microsoft YaHei&quot;</span>, 微软雅黑, Arial, sans-serif;</span><br><span class="line">    <span class="attribute">color</span>:<span class="number">#000000</span>;  <span class="comment">/*文字颜色*/</span></span><br><span class="line">    <span class="attribute">word-wrap</span>: break-word; <span class="comment">/*文字换行*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2D看板娘"><a href="#2D看板娘" class="headerlink" title="2D看板娘"></a>2D看板娘</h4><p><a href="https://blog.csdn.net/u013467402/article/details/101443431">在hexo博客加上live2d看板娘</a><br><a href="https://github.com/EYHN/hexo-helper-live2d">live2d官网文档 - hexo-helper-live2d: Add the live2d to your hexo!</a></p>
<h4 id="站内搜索"><a href="#站内搜索" class="headerlink" title="站内搜索"></a>站内搜索</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>在  hexo 根目录下 <code>_config.yml</code> 文件中添加：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hexo-generator-searchdb</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br></pre></td></tr></table></figure>



<h4 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h4><ul>
<li>Valine + LeanCloud<br>参考：<a href="">Valine官方文档 - 快速、简洁且高效的无后端评论系统</a><br>如果使用 Ayer 主题，完成LeanCloud仓库创建后可以直接去<code>./theme/ayer/</code>路径下的<code>_config.yml</code>文件中键入<code>appID</code>和<code>appKey</code>，开启 LeanCloud 和 Valine功能，无需其他操作</li>
<li>Valine 评论背景</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  <span class="selector-class">.v</span><span class="selector-attr">[data-class=v]</span> <span class="selector-class">.veditor</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">https://xxx.xxx/u_pic.png</span>);</span><br><span class="line">    <span class="attribute">background-size</span>: contain;</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">    <span class="attribute">background-position</span>: right;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.05</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h4 id="更改黑夜模式的背景黑度"><a href="#更改黑夜模式的背景黑度" class="headerlink" title="更改黑夜模式的背景黑度"></a>更改黑夜模式的背景黑度</h4><p>在 <code>./themes/ayer/source/dist</code>路径下的 <code>main.css</code> 中查找 <code>body.darkmode</code> 字段</p>
<p>将 <code>background:rgba(0,0,0,.6)</code> 的第四项透明度<code>.6</code> 修改为 <code>.8</code>(变黑)</p>
<h4 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h4><p>参考：<a href="https://blog.csdn.net/nineya_com/article/details/103394315">hexo博客文章置顶功能实现的两种方法</a></p>
<p>Ayer主题包含有文章置顶相关的配置，可以修改<code>./node_modules/hexo-generator-index/lib</code>路径下的<code>generator.js</code>文件</p>
<p>将原排序方式：<code>posts.data.sort((a,b) =&gt; (b.sticky||0)-(a.sticky||0));</code>，修改为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">posts.<span class="property">data</span> = posts.<span class="property">data</span>.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(a.<span class="property">top</span> &amp;&amp; b.<span class="property">top</span>) &#123; <span class="comment">// 两篇文章都有top，top大的在前</span></span><br><span class="line">    <span class="keyword">if</span>(a.<span class="property">top</span> == b.<span class="property">top</span>) </span><br><span class="line">      <span class="keyword">return</span> b.<span class="property">date</span> - a.<span class="property">date</span>; <span class="comment">// 若top值相等，最新的文章在前面</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> b.<span class="property">top</span> - a.<span class="property">top</span>; <span class="comment">// top大的在前面</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(a.<span class="property">top</span> &amp;&amp; !b.<span class="property">top</span>) &#123; <span class="keyword">return</span> -<span class="number">1</span>; &#125;  <span class="comment">// 以下是只有一篇文章top有定义，那么将有top的排在前面</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(!a.<span class="property">top</span> &amp;&amp; b.<span class="property">top</span>) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> b.<span class="property">date</span> - a.<span class="property">date</span>; 	<span class="comment">//都没有top标签，最新的文章在前面</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>然后在需要置顶的文章首部，加入top属性即可，如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: ...</span><br><span class="line">top: 10</span><br><span class="line">---</span><br></pre></td></tr></table></figure>





<hr>
<p>参考文章：</p>
<ul>
<li><p><a href="https://easyhexo.com/2-Theme-use-and-config/2-19-hexo-theme-ayer/">hexo-theme-ayer | Easy Hexo</a></p>
</li>
<li><p><a href="https://blog.justlovesmile.top/posts/c8972b63.html">Hexo博客搭建+Butterfly主题魔改指南</a></p>
</li>
<li><p><a href="https://blog.csdn.net/qq_43701912/article/details/107056483">Hexo博客 | 前端美化</a></p>
</li>
<li><p><a href="https://blog.csdn.net/qq_35982918/article/details/106728754">Hexo博客Ayer主题自定义配置</a></p>
</li>
<li><p><a href="https://blog.csdn.net/The_X_One/article/details/106753814">使用hexo框架+ayer主题+gitalk评论插件搭建个人博客</a> 的 优化部分</p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/69211731">Hexo 博客美化合集</a> 音乐外链 </p>
</li>
<li><p><a href="https://thinkingreedi.github.io/categories/%E5%8D%9A%E5%AE%A2/">会思想的苇草i 从0开始搭建博客</a></p>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>技术</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World Hexo</title>
    <url>/2020/12/27/hexo-hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My-New-Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
</search>
